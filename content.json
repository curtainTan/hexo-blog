{"meta":{"title":"curTain","subtitle":"","description":"","author":"tanTantan","url":"http://blog.curtaintan.club","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-02T08:25:53.803Z","updated":"2019-12-02T08:25:53.803Z","comments":true,"path":"404.html","permalink":"http://blog.curtaintan.club/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-12-04T13:55:14.836Z","updated":"2019-12-04T13:55:14.836Z","comments":true,"path":"about/index.html","permalink":"http://blog.curtaintan.club/about/index.html","excerpt":"","text":"云淡风轻、 关于我：目前就读于成都大学，大三 热爱的： coding 探索 前端 科技 电子产品 技术栈： js flutter nodejs mysql 愿望： 打造一个多端的app 和好朋友们一起吃好多好吃的 和好朋友们一起去海边看海 有自己热爱的东西，平静简单的生活.. 欢迎灌水"},{"title":"所有分类","date":"2019-12-03T08:46:46.735Z","updated":"2019-12-03T08:46:46.735Z","comments":true,"path":"categories/index.html","permalink":"http://blog.curtaintan.club/categories/index.html","excerpt":"","text":""},{"title":"我的收藏夹","date":"2019-12-04T13:53:25.780Z","updated":"2019-12-04T13:53:25.780Z","comments":true,"path":"favorite/index.html","permalink":"http://blog.curtaintan.club/favorite/index.html","excerpt":"","text":"图床又拍图床i.speed 前端面试题 前端 100 问：能搞懂 80% 的请把简历给我 sequelize一点通 Sequelize 快速入门 Sequelize 系列教程之一对一模型关系 Sequelize 系列教程之一对多模型关系 Sequelize 系列教程之多对多模型关系 色彩搭配Paleetes 大家有什么好的东西，可以在下面给我留言...."},{"title":"我的朋友们","date":"2019-12-05T05:53:35.793Z","updated":"2019-12-05T05:53:35.793Z","comments":true,"path":"friends/index.html","permalink":"http://blog.curtaintan.club/friends/index.html","excerpt":"","text":""},{"title":"我的作品","date":"2019-12-04T13:01:28.023Z","updated":"2019-12-04T13:01:28.023Z","comments":true,"path":"projects/index.html","permalink":"http://blog.curtaintan.club/projects/index.html","excerpt":"","text":"2019.11 nextGo使用nextjs搭配koa2搭建的仿写github的ssr项目，项目使用github接口，使用OAuth进行登录。 Features： 使用nextjs构建 使用hooks 使用redux管理状态 集成koa2 使用HOC定制props 接入github—OAuth 使用webpack-bundle-analyzer分析打包依赖 预览地址：nextGo源码地址：github打包分析：点击直达 2019.9 fabric-board 用fabric.js重写的面向对象的画板 使用了同学（胡翔）的ipad和配套的Apple Pencil，体验了记事本的功能，突发奇想，我就实现了一下，使用图层对象的形式来开发画板，体验还是不错的。 这个项目从开始构想，到大体完成只花了两天，后面在完善获取图层组，然后将图层组单独拿出来渲染到右侧的小canvas上的时候，出现了问题， 断断续续的写了下，还是没有解决。 Features： fabric.js canvas vue 图层式操作 预览地址：fabricGo源码地址：github 2019.8 canvasGo 使用canvas构建的画板项目，原生js操作。 Features： 原生js canvas 兼容手机端 拥有发送弹幕功能 截图功能 截图可旋转 撤销/前进 预览地址：canvasGo源码地址：github配套文章：快到碗里来 2019.6 electron-music 是学习electron的小demo吧，后面一定会推出electron的更完善的应用的。 Features： electron 原生js 桌面应用 本地数据缓存 源码地址：github 2019.5 网易云Go 使用flutter构建的模仿网易云音乐app，界面还原度很高， Features： flutter构建 播放视频与vedio 播放音乐 导航栏级联滑动 搜索提示 节流操作 provide状态管理 组件式开发 源码地址：github下载地址： 安卓下载：点我下载 扫码下载： ios：由于没有ios手机和mac，所以没有打包ios版本 2019.3 知程 使用原生小程序构建，工作室团队项目， Features： 微信小程序 城市级联 flex布局 源码地址：github 2018.10 chatGo 使用socket.io搭配express搭建而成的在线聊天系统，后面会使用框架搭建一个更全面，界面更友好的在线聊天系统， Features： socket.io构建而成 bootstrap栅格系统 源码地址：github预览地址：chatGo 2018.10 小小论坛 这是最初的作品，也是心心念念想要去完成的作品，最初是版本是留言板，后来一再一再的扩展，就变成了这样的一个论坛了。其实蛮喜欢这个作品的，最近也在重构中，也在试图添加更多功能… Features： vuejs、vuex、vue-router全家桶 quill富文本编辑器 路由守卫 token鉴权 源码地址：github预览地址：点击直达"},{"title":"","date":"2019-12-03T08:42:54.518Z","updated":"2019-12-03T08:42:54.518Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.curtaintan.club/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-03T08:46:42.440Z","updated":"2019-12-03T08:46:42.440Z","comments":true,"path":"tags/index.html","permalink":"http://blog.curtaintan.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"博客再次启程","slug":"博客再次启程","date":"2019-12-02T09:52:17.000Z","updated":"2019-12-03T09:30:15.449Z","comments":true,"path":"2019/12/02/博客再次启程/","link":"","permalink":"http://blog.curtaintan.club/2019/12/02/%E5%8D%9A%E5%AE%A2%E5%86%8D%E6%AC%A1%E5%90%AF%E7%A8%8B/","excerpt":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！","text":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！ 碎碎念经过一天的配置，博客搭建的差不多了， 整理好心情！！！ 致自己：你要加油啊！活出自己的样子！！ 重新出发！","categories":[{"name":"我的随笔","slug":"我的随笔","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.curtaintan.club/tags/%E7%94%9F%E6%B4%BB/"}],"author":{"name":"作者","avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png","url":"https://baidu.com"}},{"title":"drawing-board画板","slug":"drawing-board画板","date":"2019-08-14T08:04:55.000Z","updated":"2019-12-04T13:49:40.353Z","comments":true,"path":"2019/08/14/drawing-board画板/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/drawing-board%E7%94%BB%E6%9D%BF/","excerpt":"canvas写的画板","text":"canvas写的画板 快到碗里来-画板 预览：点击 前言： 之前学完canvas，一直想自己写一点东西，这两天终于完成了，开心！！ 完成功能： 绘画 画直线 截图 旋转 弹幕 鼠标触碰弹幕，弹幕悬停 撤销/前进 设置画笔信息 兼容移动端 功能截图： 前置说明如果你需要参考代码，你需要看下这里。因为功能复杂，标志的变量有接近10个之多，一下子可能很难看懂，所以我这里说明下我的开发流程，以及定义变量的顺序。 功能顺序： 画笔 → 定义画笔信息 → 橡皮檫 → 删除 → 撤销/前进 → 直线 → 截图 → 弹幕 定义变量的顺序，以及作用： 所有功能变量： 1var isDown = false // 标志鼠标是否按下 绘图三步和剪切三步走时，后面两个事件触发的标志2var points = [] // 滑动时收集的点 绘画三步走时，为了时画的线光滑，记录点，减短画线的距离3var beginPoint = null // 开始的点 绘画三步走时使用45----这三个为一组，画线三人组，为了让画的线更为光滑67var currentMenu = \"icon-pen\" // 初始按钮 底部按钮选中的按钮8var currentColor = 0 // 初始颜色的index 颜色选择，默认第一个9var paintingModal = \"pen\" // 画笔模式 line||pen||cut1011----按钮功能三人组，按钮选中标记，颜色选中，画画的模式，切换前面画笔和画直线的模式1213var lookModal = false // 鼠标模式 按钮第一个功能，此模式不能绘画，只能看14var cuted = false // 标记裁剪时，是否已经裁剪 裁剪后，防止后续的操作再次触发裁剪操作 1516----鼠标模式和剪切模式的定义1718var animationTimer = null // 弹幕动画的timer 动画的timer19var barrageArray = [] // 保存弹幕的数组20var globalPoint = &#123; x : 0, y : 0 &#125; // canvas上鼠标的点 ---弹幕时使用2122----弹幕三人组 globalPoint用来标记鼠标在canvas中的坐标，用于判断鼠标是否触碰到弹幕上2324// 实现撤销和重做的功能25let canvasHistory = [] // canvas数据，在每次画线和橡皮檫使用后保存数据26let step = 0 // 画笔抬起的步数，清空时，步数也清空2728----撤销/前进二人组，画笔抬起时，把画布信息用getImageData存入canvasHistory，用step完成前进和撤销的功能2930var penAttibutes = &#123; // 画笔数据，31 width : 2,32 lineCap : \"round\",33 lineJoin : \"round\",34 strokeStyle: \"#000\",35 fillStyle: \"#000\",36 globalCompositeOperation: \"source-over\",37 globalAlpha : 138&#125; 开发中遇到的难点与重点与解决方案： 保存历史记录使用api对比 我在写代码的时候有做过参考 这篇文章，文章里用是canvas.toDataUrl的方式做的数据保存，评论里说这个数据保存不理想，其实我一开始的时候想的就是用ctx.getImageDaata的方式来做的，我也用这个两个api做了一个对比： 代码： 结果： 可见，使用getImageData获取数据是时间是非常短的，并且获取到是画布像素数据，后续可以直接进行像素操作，从而不用再花时间再去获取画布信息，其次，getImageData获取到是数据是有数据结构的，这样在内存里面保存下来对内存更加友好，而使用toDataUrl方式保存下来的数据有21万行那么长的字符串，对内存并不友好。 后面我还做了他们绘制到画布上的时间对比，他们的时间都在1ms内，到时每次putImageData都要快一点点，但是快这一点时间的意义并不大。 toDataUrl也是有好处的，因为转置出来的是base64的字符串，所以他能够直接作为图片的src属性，让图片显示到页面。 画直线 如何画出一条直线？？当我做了撤销和前进的时候，我就把画板数据给存到canvasHistory里面了，这里刚好用到，鼠标移动是时候，先清空画布，再绘制保存到canvasHistory里最后那个数据，然后就是绘图三步走，就完成了。 注意：这里一定要绘图三步走，或者在绘制前一定要用beginPath()重开一条路径，如果不重开路径，绘制时，会把前面的直线一同绘制出来，因为你一直是一条路径，所以下次绘制时，上次的点也要绘制一遍。 图片旋转 旋转很类似css3，但是，canvas的基点固定在左上角处，所以在旋转的时候，需要先用translate移动画板，可以画一下图， 下面是我画的图： 问题： 当我画笔有rotate属性的时候，当前操作的putImageData不会成功，不知道为什么----- 如何画出一条光滑的曲线 用正常的画法画曲线是时候，画出的曲线不够光滑， 所以我就参考了这篇文章 canvas进阶——如何画出平滑的曲线? （其实我也想到了用二次贝塞尔曲线，在寻找更好的解决方案时，就找到这个方法了，这个方案更优），原理可以看原文。 鼠标触摸弹幕 因为canvas是无记忆性的，所以，你用isPointPath和isPointStroke时，是在当前绘画下才能检测。 在使用isPointPath时，他只与path路径有关，意思就是，你用fillRect直接绘制一个矩形图形是不能检测的， 只能检测rect()和pathTo等围起来的路径内。 所以，这里我做了一个外挂路径-用rect()把每个弹幕框起来——哈哈– 使用drawImage须知： drawImage有三种传参方式，三种方式出来的效果，在书写前可以先参考效果。 参考地址：CanvasRenderingContext2D.drawImage 兼容移动端 当在移动端时，会存在移动端延时300ms的问题，因为移动端有双击放大功能，故存在300ms时间。 我解决的方法是设置meta信息，禁止缩放，就可以防止300ms问题 结语：这个项目大概用了canvas的75%的api，还有像素操作和渐变等api还没用到。 不知道有没有人看呢， 如果你看到了这篇文章，希望对你有帮助。 慢慢来，好好学习，要加油哦！ 与君共勉！！ 参考材料： 手把手教你实现一个canvas智绘画板 参考了楼主项目的样式，但是所有样式都是我自己写的，嘻嘻，实现方式不一样哦。。 canvas进阶——如何画出平滑的曲线? 画一条光滑的曲线，不错哦。 canvas动画包教不包会 可以在这里把所有api的意义和作用和参数等都记下来—– Canvas API中文文档首页地图 canvas所有的api，当然你也可以去mdn看，其实都一样啦—","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://blog.curtaintan.club/tags/canvas/"},{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"正则小记之api速学","slug":"正则小记之api速学","date":"2019-08-14T08:04:55.000Z","updated":"2019-12-03T09:44:21.132Z","comments":true,"path":"2019/08/14/正则小记之api速学/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%E4%B9%8Bapi%E9%80%9F%E5%AD%A6/","excerpt":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章…","text":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章… 前言正则，用简短的一句话概括，正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则的方法和与正则有关的方法共有6个，字符串实例4个，正则实例2个： String#search String#split String#match String#replace RegExp#test RegExp#exec1.search()定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1var regex = /\\d/;2var string = \"abc123\";3console.log( string.search(regex) );4// =&gt; 3 2.split定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 例子： 1var regex = /\\D/2console.log( \"2017/06/26\".split(regex) )3console.log( \"2017.06.26\".split(regex) )4console.log( \"2017-06-26\".split(regex) )5// =&gt; [\"2017\", \"06\", \"26\"]6// =&gt; [\"2017\", \"06\", \"26\"]7// =&gt; [\"2017\", \"06\", \"26\"] 3.match定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则： 匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 案例： 1var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;2var string = \"2017-06-26\";3console.log( string.match(regex) );4// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 4.replace语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. replace后面单独写一篇文章总结 案例： 1var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;2var string = \"2017-06-26\";3var date = [];4string.replace(regex, function(match, year, month, day) &#123;5 date.push(year, month, day);6&#125;);7console.log(date);8// =&gt; [\"2017\", \"06\", \"26\"] 5.test说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1var regex = /\\d/;2var string = \"abc123\";3console.log( regex.test(string) );4// =&gt; true 6.exec说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 这个方法很类似match方法。 案例： 1var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;2var string = \"2017-06-26\";3console.log( regex.exec(string) );4// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 相关API注意要点-1 search和match的参数问题我们知道字符串实例的那4个方法参数都支持正则和字符串。 但search和match，会把字符串转换为正则的。 1var string = \"2017.06.27\";23console.log( string.search(\".\") );4// =&gt; 05//需要修改成下列形式之一6console.log( string.search(\"\\\\.\") );7console.log( string.search(/\\./) );8// =&gt; 49// =&gt; 41011console.log( string.match(\".\") );12// =&gt; [\"2\", index: 0, input: \"2017.06.27\"]13//需要修改成下列形式之一14console.log( string.match(\"\\\\.\") );15console.log( string.match(/\\./) );16// =&gt; [\".\", index: 4, input: \"2017.06.27\"]17// =&gt; [\".\", index: 4, input: \"2017.06.27\"]1819console.log( string.split(\".\") );20// =&gt; [\"2017\", \"06\", \"27\"]2122console.log( string.replace(\".\", \"/\") );23// =&gt; \"2017/06.27\" 2 match返回结果的格式问题match返回结果的格式，与正则对象是否有修饰符g有关。 1var string = \"2017.06.27\";2var regex1 = /\\b(\\d+)\\b/;3var regex2 = /\\b(\\d+)\\b/g;4console.log( string.match(regex1) );5console.log( string.match(regex2) );6// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]7// =&gt; [\"2017\", \"06\", \"27\"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有g，返回的是所有匹配的内容。 3 exec比match更强大当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。 而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配： 1var string = \"2017.06.27\";2var regex2 = /\\b(\\d+)\\b/g;3console.log( regex2.exec(string) );4console.log( regex2.lastIndex);5console.log( regex2.exec(string) );6console.log( regex2.lastIndex);7console.log( regex2.exec(string) );8console.log( regex2.lastIndex);9console.log( regex2.exec(string) );10console.log( regex2.lastIndex);11// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]12// =&gt; 413// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"]14// =&gt; 715// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"]16// =&gt; 1017// =&gt; null18// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 1var string = \"2017.06.27\";2var regex2 = /\\b(\\d+)\\b/g;3var result;4while ( result = regex2.exec(string) ) &#123;5 console.log( result, regex2.lastIndex );6&#125;7// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"] 48// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"] 79// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"] 10 4 修饰符g，对exex和test的影响上面提到了正则实例的lastIndex属性，表示尝试匹配时，从字符串的lastIndex位开始去匹配。 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。 而正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。下面让我们以test为例，看看你是否会迷糊： 1var regex = /a/g;2console.log( regex.test(\"a\"), regex.lastIndex );3console.log( regex.test(\"aba\"), regex.lastIndex );4console.log( regex.test(\"ababc\"), regex.lastIndex );5// =&gt; true 16// =&gt; true 37// =&gt; false 0 注意上面代码中的第三次调用test，因为这一次尝试匹配，开始从下标lastIndex即3位置处开始查找，自然就找不到了。 如果没有g，自然都是从字符串第0个字符处开始尝试匹配： 1var regex = /a/;2console.log( regex.test(\"a\"), regex.lastIndex );3console.log( regex.test(\"aba\"), regex.lastIndex );4console.log( regex.test(\"ababc\"), regex.lastIndex );5// =&gt; true 06// =&gt; true 07// =&gt; true 0 5 test整体匹配时需要使用^和$这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： 1console.log( /123/.test(\"a123b\") );2// =&gt; true3console.log( /^123$/.test(\"a123b\") );4// =&gt; false5console.log( /^123$/.test(\"123\") );6// =&gt; true 6 split相关注意事项split方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： 1var string = \"html,css,javascript\";2console.log( string.split(/,/, 2) );3// =&gt;[\"html\", \"css\"] 7 replace是很强大的 《JavaScript权威指南》认为exec是这6个API中最强大的，而我始终认为replace才是最强大的。 因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号例如，把”2,3,5”，变成”5=2+3”： 1var result = \"2,3,5\".replace(/(\\d+),(\\d+),(\\d+)/, \"$3=$1+$2\");2console.log(result);3// =&gt; \"5=2+3\" 又例如，把”2,3,5”，变成”222,333,555”: 1var result = \"2,3,5\".replace(/(\\d+)/g, \"$&amp;$&amp;$&amp;\");2console.log(result);3// =&gt; \"222,333,555\" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”: 1var result = \"2+3=5\".replace(/=/, \"$&amp;$`$&amp;$'$&amp;\");2console.log(result);3// =&gt; \"2+3=2+3=5=5\" 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： 1\"1234 2345 3456\".replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function(match, $1, $2, index, input) &#123;2 console.log([match, $1, $2, index, input]);3&#125;);4// =&gt; [\"1234\", \"1\", \"4\", 0, \"1234 2345 3456\"]5// =&gt; [\"2345\", \"2\", \"5\", 5, \"1234 2345 3456\"]6// =&gt; [\"3456\", \"3\", \"6\", 10, \"1234 2345 3456\"] 此时我们可以看到replace拿到的信息，并不比exec少。 8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多\\。 1var string = \"2017-06-27 2017.06.27 2017/06/27\";2var regex = /\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/g;3console.log( string.match(regex) );4// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"]56regex = new RegExp(\"\\\\d&#123;4&#125;(-|\\\\.|\\\\/)\\\\d&#123;2&#125;\\\\1\\\\d&#123;2&#125;\", \"g\");7console.log( string.match(regex) );8// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"] 9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline10 source属性正则实例对象属性，除了global、ingnoreCase、multiline、lastIndex属性之外，还有一个source属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： 1var className = \"high\";2var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\");3console.log( regex.source )4// =&gt; (^|\\s)high(\\s|$) 即字符串\"(^|\\\\s)high(\\\\s|$)\" 11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是$1,…,$9之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp[&quot;$&apos;&quot;]测试代码如下： 1var regex = /([abc])(\\d)/g;2var string = \"a1b2c3d4e5\";3string.match(regex);45console.log( RegExp.input );6console.log( RegExp[\"$_\"]);7// =&gt; \"a1b2c3d4e5\"89console.log( RegExp.lastMatch );10console.log( RegExp[\"$&amp;\"] );11// =&gt; \"c3\"1213console.log( RegExp.lastParen );14console.log( RegExp[\"$+\"] );15// =&gt; \"3\"1617console.log( RegExp.leftContext );18console.log( RegExp[\"$`\"] );19// =&gt; \"a1b2\"2021console.log( RegExp.rightContext );22console.log( RegExp[\"$'\"] );23// =&gt; \"d4e5\" 结语： 我搜查列出了相关的6个方法，并对6个方法进行了说明。 后面我会对replace再单独出一篇文章。 参考资料里的第一篇文章真的非常好，值得仔细研读。 如果你想粗略了解正则的方法，看我这篇文章是没错了，后面列出的相应方法的坑点和注意点。 后面，我会再慢慢补充匹配规则，我会单独列出一篇文章，因为匹配规则也有很多注意点呢。 哈哈哈，其实也是在下面的文章里面看的啦，文章真的写得好---嘻嘻 其实正则也没有那么难的啦----- 希望这篇文章对你有帮助，每天都要加油哦。 加油，与君共勉！！！参考资料： JS正则表达式完整教程（略长） 文章真的写的不错，认认真真，细嚼慢咽的看完这篇文章，保证你学会正则。 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。 MDN-RegExp MDN-String","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]}]}