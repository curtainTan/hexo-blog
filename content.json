{"meta":{"title":"curTain","subtitle":"","description":"","author":"tanTantan","url":"http://blog.curtaintan.club","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-02T08:25:53.803Z","updated":"2019-12-02T08:25:53.803Z","comments":true,"path":"404.html","permalink":"http://blog.curtaintan.club/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-12-26T14:01:07.399Z","updated":"2019-12-26T14:01:07.399Z","comments":true,"path":"about/index.html","permalink":"http://blog.curtaintan.club/about/index.html","excerpt":"","text":"云淡风轻、 关于我：目前就读于成都大学，大三 热爱的： coding 探索 前端 科技 电子产品 技术栈： js flutter nodejs mysql 愿望： 打造一个多端的app 和好朋友们一起吃好多好吃的 和好朋友们一起去海边看海 有自己热爱的东西，平静简单的生活.. 欢迎灌水"},{"title":"所有分类","date":"2019-12-26T14:01:52.812Z","updated":"2019-12-26T14:01:52.812Z","comments":true,"path":"categories/index.html","permalink":"http://blog.curtaintan.club/categories/index.html","excerpt":"","text":""},{"title":"我的收藏夹","date":"2020-01-31T06:03:52.343Z","updated":"2020-01-31T06:03:52.343Z","comments":true,"path":"favorite/index.html","permalink":"http://blog.curtaintan.club/favorite/index.html","excerpt":"","text":"图床又拍图床speed路过图床(稳定、推荐使用) 前端面试题 前端 100 问：能搞懂 80% 的请把简历给我 sequelize一点通 Sequelize 快速入门 Sequelize 系列教程之一对一模型关系 Sequelize 系列教程之一对多模型关系 Sequelize 系列教程之多对多模型关系 色彩搭配Paleetes 大家有什么好的东西，可以在下面给我留言...."},{"title":"我的朋友们","date":"2020-02-06T02:23:42.801Z","updated":"2020-02-06T02:23:42.801Z","comments":true,"path":"friends/index.html","permalink":"http://blog.curtaintan.club/friends/index.html","excerpt":"","text":""},{"title":"我的作品","date":"2020-02-06T06:13:38.748Z","updated":"2020-02-06T06:13:38.748Z","comments":true,"path":"projects/index.html","permalink":"http://blog.curtaintan.club/projects/index.html","excerpt":"","text":"2020.1 little chat 一直都想重构之前的chatGo聊天项目，终于重构了！开心… Features： 使用create-react-app构建 hooks redux + redux-saga 状态管理 使用immutable.js 适配移动端 私聊 群聊 申请加群 支持发送图片和emoji 服务端： socket.io搭配koa2 使用单例模式管理状态 使用函数柯理接收参数 一开始用dva构建的项目，后来用create-react-app重构了项目： react版本：react版本预览dva简化版本：dva版本预览地址源码地址：github 2019.11 nextGo使用nextjs搭配koa2搭建的仿写github的ssr项目，项目使用github接口，使用OAuth进行登录。 Features： 使用nextjs构建 使用hooks 使用redux管理状态 集成koa2 使用HOC定制props 接入github—OAuth 使用webpack-bundle-analyzer分析打包依赖 预览地址：nextGo源码地址：github打包分析：点击直达 2019.9 fabric-board 用fabric.js重写的面向对象的画板 使用了同学（胡翔）的ipad和配套的Apple Pencil，体验了记事本的功能，突发奇想，我就实现了一下，使用图层对象的形式来开发画板，体验还是不错的。 这个项目从开始构想，到大体完成只花了两天，后面在完善获取图层组，然后将图层组单独拿出来渲染到右侧的小canvas上的时候，出现了问题， 断断续续的写了下，还是没有解决。 Features： fabric.js canvas vue 图层式操作 预览地址：fabricGo源码地址：github 2019.8 canvasGo 使用canvas构建的画板项目，原生js操作。 Features： 原生js canvas 兼容手机端 拥有发送弹幕功能 截图功能 截图可旋转 撤销/前进 预览地址：canvasGo源码地址：github配套文章：快到碗里来 2019.6 electron-music 是学习electron的小demo吧，后面一定会推出electron的更完善的应用的。 Features： electron 原生js 桌面应用 本地数据缓存 源码地址：github 2019.5 网易云Go 使用flutter构建的模仿网易云音乐app，界面还原度很高， Features： flutter构建 播放视频与vedio 播放音乐 导航栏级联滑动 搜索提示 节流操作 provide状态管理 组件式开发 源码地址：github下载地址： 安卓下载：点我下载 扫码下载： ios：由于没有ios手机和mac，所以没有打包ios版本 2019.3 知程 使用原生小程序构建，工作室团队项目， Features： 微信小程序 城市级联 flex布局 源码地址：github 2018.10 chatGo 使用socket.io搭配express搭建而成的在线聊天系统，后面会使用框架搭建一个更全面，界面更友好的在线聊天系统， Features： socket.io构建而成 bootstrap栅格系统 源码地址：github预览地址：chatGo 2018.10 小小论坛 这是最初的作品，也是心心念念想要去完成的作品，最初是版本是留言板，后来一再一再的扩展，就变成了这样的一个论坛了。其实蛮喜欢这个作品的，最近也在重构中，也在试图添加更多功能… Features： vuejs、vuex、vue-router全家桶 quill富文本编辑器 路由守卫 token鉴权 源码地址：github预览地址：点击直达"},{"title":"","date":"2019-12-03T08:42:54.518Z","updated":"2019-12-03T08:42:54.518Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.curtaintan.club/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-03T08:46:42.440Z","updated":"2019-12-03T08:46:42.440Z","comments":true,"path":"tags/index.html","permalink":"http://blog.curtaintan.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式（二）--观察者模式","slug":"设计模式（二）-观察者模式","date":"2020-02-08T08:21:01.000Z","updated":"2020-02-08T09:33:31.663Z","comments":true,"path":"2020/02/08/设计模式（二）-观察者模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"写一个观察者模式。","text":"写一个观察者模式。 介绍意图： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 关键代码： 在抽象类里有一个 ArrayList&lt;\\Observer&gt; 存放观察者们。 实现观察者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 观察者模式 * state 状态 * observers &#123; Observer &#125; 保存所有的观察者 */class Subject&#123; constructor()&#123; this.state = 0 this.observers = [] &#125; getState()&#123; return this.state &#125; setState( state )&#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers()&#123; this.observers.forEach( observer =&gt; &#123; observer.update() &#125;) &#125; // 添加观察者 attach( observer )&#123; this.observers.push( observer ) &#125;&#125;// 观察者class Observer &#123; constructor( name, subject )&#123; this.name = name this.subject = subject this.subject.attach( this ) &#125; update()&#123; console.log( `$&#123; this.name &#125; -- update, state: $&#123; this.subject.getState() &#125;` ) &#125;&#125;// 测试let s = new Subject()let o1 = new Observer( \"o1\", s )let o2 = new Observer( \"o2\", s )s.setState( 11 )s.setState( 12 )console.log( s ) 测试结果： 总结：观察者模式的要点主要是将观察者放在被观察者里面，当状态变化后，就依次通知观察者。 参考超全的设计模式简介（45种）—观察者模式 JavaScript 中常见设计模式整理 谈谈观察者模式和发布订阅模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（一）--单例模式","slug":"设计模式（一）-单例模式","date":"2020-02-08T06:00:08.000Z","updated":"2020-02-08T08:07:23.641Z","comments":true,"path":"2020/02/08/设计模式（一）-单例模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"写一个单例模式。","text":"写一个单例模式。 定义确保一个类只有一个实例，使每次获取的实例都是同一个。 代码实现123456789101112131415161718192021222324252627282930class Store &#123; constructor( name )&#123; this.name = name &#125; getName()&#123; return this.name &#125; setName( data )&#123; this.name = data &#125;&#125;// 获取单例的方法 --- 使用闭包获取单例Store.getInstance = ( function()&#123; let instance return function( name )&#123; if( !instance )&#123; instance = new Store( name ) &#125; return instance &#125; &#125;)()let store1 = Store.getInstance( \"你好\" )let store2 = Store.getInstance( \"你好----\" )console.log( store1 )console.log( store2 )console.log( store1 === store2 ) 运行结果 总结单例模式运用非常广泛，只要在代码中涉及到只存在一个实例，就可以使用单例模式， vuex 和 redux 就是使用单例模式构建。 写一个单例模式的要点： 使用一个特定函数来获取单例， 此函数使用闭包来确保但会单例是唯一的， 使用函数柯理化–接收传入参数 参考JavaScript设计模式 JavaScript设计模式es6（23种) JavaScript 中常见设计模式整理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"javascript之防抖与节流","slug":"javascript之节流与防抖","date":"2020-02-07T05:27:55.000Z","updated":"2020-02-08T05:59:26.654Z","comments":true,"path":"2020/02/07/javascript之节流与防抖/","link":"","permalink":"http://blog.curtaintan.club/2020/02/07/javascript%E4%B9%8B%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"写一个防抖与节流。","text":"写一个防抖与节流。 1. 防抖什么是防抖： 当一个事件触发后，在 n 秒后才执行相关函数，如果在 n 秒内再次触发事件，则在新事件 n 秒后才执行相关函数。 函数功能设计与实现原理： 用户可以根据需求自传定义执行函数、间隔时间、是否立即执行来传入对应的参数。 使用闭包函数，设置一个定时器作为标志放在闭包内，使用函数柯理化接收传入参数。 代码： 123456789101112131415161718192021/** * 防抖函数 * @param fn 回调函数 * @param time 间隔时间 type number * @param immediate 立刻执行 type boolean */function debounce( fn, time, immediate = false )&#123; let timeount return function()&#123; if( timeount )&#123; clearTimeout( timeount ) &#125; if( immediate &amp;&amp; !timeount )&#123; fn.apply( this, arguments ) &#125; timeount = setTimeout( () =&gt; &#123; // 此处运用函数柯理化 arguments 为调用函数时的参数 fn.apply( this, arguments ) // 此处放开注释-会让每一次执行完后，第一次都会立即执行一次 // timeount = null &#125;, time || 500 ) &#125;&#125; 测试： 自建html文件测试123456function go( e )&#123; console.log( e )&#125;document.addEventListener( \"mousemove\", debounce( go, 500, false ) )// 自传参数debounce( go, 500, false )( \"我是自己传进去的参数--\" ) 2. 节流什么是节流： 节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。 代码： 1234567891011121314151617181920212223/** * 节流函数 * @param fn 回调函数 * @param time 间隔时间 type number * @param immediate 立刻执行 type boolean */function throttle( fn, time, immediate = false )&#123; let timeount let isFrist = true return function()&#123; if( immediate &amp;&amp; isFrist )&#123; fn.apply( this, arguments ) isFrist = false &#125; if( !timeount )&#123; timeount = setTimeout( () =&gt; &#123; fn.apply( this, arguments ) timeount = null &#125;, time || 500 ) &#125; &#125;&#125; 测试： 自建html文件测试123456function go( e )&#123; console.log( e )&#125;document.addEventListener( \"mousemove\", throttle( go, 500, true ) )// 自传参数throttle( go, 500, false )( \"我是自己传进去的参数--\" ) 总结：防抖和节流在代码中被使用的频率还是蛮大的， 函数的编写有借鉴，也有自己的思考，感觉自己思考过后，才会对函数有更深的理解。 防抖可以运用在： window 的 resize、scroll mousedown、mousemove keyup、keydown 搜索自动弹出 搜索联想 防抖函数要点： 每一次触发事件，都要清除定时器，并重置 timeout 定时器。 节流函数要点： 每次执行完函数后，都要把标志置为null 参考wclimb–JavaScript之节流与防抖 函数防抖和节流 JavaScript专题之跟着 underscore 学节流 JavaScript专题之跟着underscore学防抖","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"javascript之继承","slug":"javascript之继承","date":"2020-02-06T06:07:35.000Z","updated":"2020-02-08T06:01:06.340Z","comments":true,"path":"2020/02/06/javascript之继承/","link":"","permalink":"http://blog.curtaintan.club/2020/02/06/javascript%E4%B9%8B%E7%BB%A7%E6%89%BF/","excerpt":"在 es6 之前，javaScript 不能使用 extends 来显式继承的，所以，继承需要程序员手动完成。 那么，让我们来看一看 js 中的各种继承方式吧。","text":"在 es6 之前，javaScript 不能使用 extends 来显式继承的，所以，继承需要程序员手动完成。 那么，让我们来看一看 js 中的各种继承方式吧。 前置知识原型链 我们需要了解原型和原型链，需要知道构造函数与原型对象之间的关系，需要知道原型对象是一个对象，它有个属性 constructor 就是构造函数 Object.creact() 方法 传入原型对象，返回原型对象和属性。 1. 原型链继承原理说明： 就是将已经 new 出来的对象实例的 prototype 变成父对象，从而，把父对象的属性和方法都继承到了当前对象的 prototype 上，当前对象的实例本身没有父对象的属性与方法，当调用这些方法时，他会自动到此对象的 prototype 上依次去找，直到找到 null 为止，这就称为原型链继承。 实现 123456789101112131415161718192021222324function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12 )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125;&#125;// 修改原型对象，并改回构造函数Student.prototype = new Person()Student.prototype.constuctor = Studentvar S = new Student( 12 )console.log( \"实例S：\", S )S.run()console.log( S instanceof Student ) 运行结果： 1.1 总结： 由上面的例子可见，当继承的对象需要传参时，极度不灵活，因为 prototype 是一个父类的实例。 故：此继承方法适合继承方法，而不适合继承属性。 2. 借用构造函数继承原理说明： 在构造函数中，改变父类构造函数的 this 并执行构造函数。 实现： 1234567891011121314151617181920212223function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 也可以使用 apply 改变 this Person.call( this, name, age )&#125;var S = new Student( 12, \"yu\", 12 )console.log( \"实例S：\", S )S.run()console.log( S instanceof Student ) 运行结果： 总结： 可以传参给父类构造函数了，但是此方法不能继承父类原型链（ prototype ）上的方法和参数。 3. 组合继承原理说明： 将上面两种方法结合起来，目的是继承到父类原型链上的方法。 实现： 1234567891011121314151617181920212223242526function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 Person.call( this, name, age )&#125;// 继承父类原型链Student.prototype = new Person()Student.prototype.constuctor = Studentvar S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 运行结果： 总结： 很好的继承了父类，并继承了原型链，但是多了一些属性在原型链上。下面我们将解决这个问题。 4. 组合继承变种——借用原型链继承原理说明： 将子类的原型链指向父类的原型链，达到继承父类原型链的目的： 实现： 修改组合继承的代码：1234567// 继承父类原型链Student.prototype = new Person()Student.prototype.constuctor = Student// 修改为：Student.prototype = Object.create( Person.prototype )Student.prototype.constuctor = Student 运行结果： 总结： 完美的继承了父类，干净利索。 5. ES6 类继承 extends实现说明：extends 关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中 constructor 表示构造函数，一个类中只能有一个构造函数，有多个会报出 SyntaxError 错误,如果没有显式指定构造方法，则会添加默认的 constructor 方法，使用 super 方法传参到父类构造函数。 实现： es6 extends 继承1234567891011121314151617181920212223242526class Person&#123; constructor( name=\"tan\", age=18 )&#123; this.name = name this.age = age &#125; run = function() &#123; console.log(`$&#123; this.name &#125; can run...`) &#125; getName = function (params) &#123; return this.name &#125;&#125;class Student extends Person&#123; constructor( id, name, age )&#123; super( name, age ) this.id = id &#125; study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125;&#125;var S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 运行结果： 总结： 简单、完美 疑问：在第四种继承方式中，为什么不能直接改成 Student.prototype = Person.prototype，而要使用 Object.create( Person.prototype ), 代码： 12345678910111213141516171819202122232425function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 Person.call( this, name, age )&#125;Student.prototype = Person.prototypeStudent.prototype.constuctor = Studentvar S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 结果是： 如果你知道原因，请在下方评论区给我留言。感谢！ 总结：尽管继承方式五花八门，但是继承的目的却是不变的： 将父类属性和方法复制到当前类 ( 在构造函数内改变父类构造函数的this并执行 ) 继承父类的原型链 （ 修改构造函数的 prototype 指向父类的 prototype ） 参考：看了都知道继承也就那么回事儿 JavaScript常用八种继承方案","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"javascript 之 new 的实现","slug":"javascript 之 new 的实现","date":"2020-02-06T02:30:46.000Z","updated":"2020-02-08T06:00:56.389Z","comments":true,"path":"2020/02/06/javascript 之 new 的实现/","link":"","permalink":"http://blog.curtaintan.club/2020/02/06/javascript%20%E4%B9%8B%20new%20%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"网上有很多讲原型、原型链、new 的执行与实现的文章，我也看了很多。 本文描述一下 new 的执行过程与手写实现一个 new 的实现。","text":"网上有很多讲原型、原型链、new 的执行与实现的文章，我也看了很多。 本文描述一下 new 的执行过程与手写实现一个 new 的实现。 1. new 的执行过程 我们以上图为例阐述 new 的执行过程。 创建一个中间对象 将该中间对象的原型指向构造函数的原型 将构造函数的 this 指向该中间对象并执行 返回该中间对象，即返回实例对象 2. 代码实现1234567891011121314function myNew()&#123; // 取出传入参数 let argArray = Array.from( arguments ) // 取出构造函数与需要传入构造函数的参数 let constructorFun = argArray.shift() // 创建中间函数 let obj = &#123;&#125; // 将该中间对象的原型指向构造函数的原型 obj.__proto__ = constructorFun.prototype // 绑定 this 并传入参数执行 constructorFun.apply( obj, argArray ) // 返回创建的对象 return obj&#125; 3. 运行测试12345678910111213141516function Animal( name, age )&#123; this.name = name this.age = age&#125;function myNew()&#123; let argArray = Array.from( arguments ) let constructorFun = argArray.shift() let obj = &#123;&#125; obj.__proto__ = constructorFun.prototype constructorFun.apply( obj, argArray ) return obj&#125;console.log( \"myNew：\",myNew( Animal, \"dog\", \"12\" ) )console.log( \"new：\", new Animal( \"cat\", \"11\" ) ) 测试结果： 总结写出 new 的执行过程与实现，基本算是考察对 prototype 原型链的理解。 参考：彻底捋清楚 new 的实现","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---写一个深拷贝","slug":"思路清晰-写一个深拷贝","date":"2020-01-31T09:38:59.000Z","updated":"2020-02-06T15:05:37.998Z","comments":true,"path":"2020/01/31/思路清晰-写一个深拷贝/","link":"","permalink":"http://blog.curtaintan.club/2020/01/31/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-%E5%86%99%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"写一个深拷贝，考虑数组、对象和循环引用。","text":"写一个深拷贝，考虑数组、对象和循环引用。 1.准备两个对象 无循环引用的对象 12345678910111213var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125; 有循环引用的对象1234567891011121314var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;target.target = target 2.使用 JSON.parse(JSON.stringify())2.1复制一个无循环引用的对象，代码如下：12345678910111213141516var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;var res = JSON.parse( JSON.stringify( target ) )console.log( \"target: \", target )console.log( \"res: \", res ) 得到的结果是： 总结：可见，JSON.stringify() 不能处理undefined和function。 2.2复制一个循环应用的对象1234567891011121314151617var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;target.target = targetvar res = JSON.parse( JSON.stringify( target ) )console.log( \"target: \", target )console.log( \"res: \", res ) 结果： 总结：可见，JSON.stringify() 不能处理处理循环引用的结构 3.手写一个深拷贝3.1浅拷贝1234567function clone( target )&#123; let cloneTarget = &#123;&#125; for( let key in target )&#123; cloneTarget[key] = target[key] &#125; return cloneTarget&#125; 上面是一个浅拷贝，没有考虑数组与对象。 3.2 考虑对象我们可以使用 typeof 来判断数据类型： typeof可以查看数据的类型有 7 种：typeof 12345 === numbertypeof “999” === stringtypeof {} === object null []typeof undefined === undefinedtypeof true === booleantypeof symbol(23) === symboltypeof console.log === function typeof小提示 使用递归处理引用对象的拷贝： 1234567891011function clone( target )&#123; if( typeof target === \"object\" )&#123; let cloneTarget = &#123;&#125; for( let key in target )&#123; cloneTarget[key] = clone( target[key] ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 结果： 总结 因为typeof会把数组识别成object，所以，代码还需要再度改进。 3.3 考虑数组1234567891011function clone( target )&#123; if( typeof target === \"object\" )&#123; let cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; for( let key in target )&#123; cloneTarget[key] = clone( target[key] ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 测试结果： 总结： 可见，数组也可以复制了，下面我们要解决循环引用。 3.4 考虑循环引用当学习过设计模式后，我们会发现，有很多情况存在循环引用的问题，所以，在深拷贝时，循环引用的问题是必须要解决的。 解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。 —引用自：如何写出一个惊艳面试官的深拷贝? es6中，有这样一种数据结构叫 Map，他能将对象作为键，这样，我们就能很好的保存对象，并判断对象是否被拷贝过了。 整体流程如下： 是对象，检查map中是否存在此对象 存在—-返回保存在map中的键 不存在—将值存入map，键的值使用当前cloneTarget（这里其实用什么都行） 继续递归拷贝，并传入此时的map 代码如下： 123456789101112131415function clone( target, map = new Map() )&#123; if( typeof target === \"object\" )&#123; var cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; if( map.get( target ) )&#123; return map.get( target ) &#125; map.set( target, cloneTarget ) for( let key in target )&#123; cloneTarget[key] = clone( target[key], map ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 测试结果： 可以看见，已经解决了循环引用的问题。 3.5 简单性能优化使用 WeakMap 数据结构，将复制对象属性的强引用变为弱引用。 WeakMap的作用，请参考 es6 WeakMap. 修改后的代码： 123456789101112131415function clone( target, map = new WeakMap() )&#123; if( typeof target === \"object\" )&#123; var cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; if( map.get( target ) )&#123; return map.get( target ) &#125; map.set( target, cloneTarget ) for( let key in target )&#123; cloneTarget[key] = clone( target[key], map ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 最后，我们就完成了一个简单的深拷贝，解决了对象、数组、循环引用的问题。 结语总结一下写出一个深拷贝的过程： 需要传入两个参数，一个是拷贝目标，一个是作为拷贝过属性的容器 WeakMap 判断拷贝目标是否一个对象 或是 数组 是 使用 WeakMap 判断是否已经拷贝，并递归拷贝每个属性 不是 直接返回此属性的值 js中还有很多其他的数据结构，比如 Set 和 Map，这里就不做继续的深入了， 如果你想继续深入深拷贝，你可以参考：如何写出一个惊艳面试官的深拷贝? 参考如何写出一个惊艳面试官的深拷贝? 阮一峰 es6","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---socket.io的总结","slug":"思路清晰-socket-io的总结","date":"2020-01-30T07:35:36.000Z","updated":"2020-01-31T06:46:04.954Z","comments":true,"path":"2020/01/30/思路清晰-socket-io的总结/","link":"","permalink":"http://blog.curtaintan.club/2020/01/30/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-socket-io%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"思路清晰的使用socket.io…..","text":"思路清晰的使用socket.io….. 引入：先看官网api： 可以看见，主要有这三个对象：server，namespace和socket 如果你掌握了这三个对象，那么你就已经基本学会socket.io的使用了。 在服务端，我们会写出这样的socket.io服务端代码：12345678910111213141516171819202122const Koa = require('koa') // 引入koaconst app = new Koa() // 创建一个koa实例// 引入http模块，并在Server函数中传入app的回调函数const http = require(\"http\").Server( app.callback() )// 引入socket.io 传入http，并配置socketconst IO = require(\"socket.io\")( http, &#123; pingTimeout: 1000 * 10, pingInterval: 1000 * 2.5&#125;)// 默认命名空间（\"/\"）总线IO监听连接事件 当前IO为默认命名空间IO.on( \"connection\", ( socket ) =&gt; &#123; // 当前socket连接收到event事件，触发callback函数 socket.on( \"event\", callBack ) // 向当前socket连接客户端触发event事件，返回数据sendData socket.emit( \"event\", sendData )&#125;)// 相当于如下代码：var mainSpace = IO.of(\"/\")mainSpace.on( \"connection\", ( socket ) =&gt; &#123; ....&#125; 看了上面的代码，不难发现socket.io暴露两个对象供我们使用，一个是当前命名空间总线IO，一个是当前连接的socket，他们的关系如图： 这里就不得不说一下命名空间了 关于命名空间（namespace）：默认命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192amespace &#123; name: '/', server: Server &#123; nsps: &#123; '/': [Circular] &#125;, parentNsps: Map &#123;&#125;, _path: '/socket.io', _serveClient: true, parser: &#123; protocol: 4, types: [Array], CONNECT: 0, DISCONNECT: 1, EVENT: 2, ACK: 3, ERROR: 4, BINARY_EVENT: 5, BINARY_ACK: 6, Encoder: [Function: Encoder], Decoder: [Function: Decoder] &#125;, encoder: Encoder &#123;&#125;, _adapter: [Function: Adapter], _origins: '*:*', sockets: [Circular], eio: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125;, httpServer: Server &#123; domain: null, _events: [Object], _eventsCount: 5, _maxListeners: undefined, _connections: 0, _handle: null, _usingSlaves: false, _slaves: [], _unref: false, allowHalfOpen: true, pauseOnConnect: false, httpAllowHalfOpen: false, timeout: 120000, keepAliveTimeout: 5000, _pendingResponseData: 0, maxHeadersCount: null, [Symbol(asyncId)]: -1 &#125;, engine: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125; &#125;, sockets: &#123;&#125;, connected: &#123;&#125;, fns: [], ids: 0, rooms: [], flags: &#123;&#125;, adapter: Adapter &#123; nsp: [Circular], rooms: &#123;&#125;, sids: &#123;&#125;, encoder: Encoder &#123;&#125; &#125; &#125; 命名空间与socket当前命名空间总线IO的总结通过上面的命名空间的定义的代码，我们可以知道，在总线IO上，拥有所有连接的socket的信息，拥有所有的rooms信息， 故： 可以向指定房间里发送消息 可以向连接到当前命名空间里的所有socket发送消息 等… 官网api截图： 可知，总的是对room和连接的sockets进行操作。 当前连接socket总结： 个人总结当理解了总线IO与当前连接的socket的关系后，就能思路清晰的写出优秀的的代码了。 写下这篇文章，希望对你有帮助，与君共勉！参考资料：socket.io官网 socket.io命名空间的详细解析 WebSocket协议-Socket.io 服务端API","categories":[{"name":"socket.io","slug":"socket-io","permalink":"http://blog.curtaintan.club/categories/socket-io/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://blog.curtaintan.club/tags/%E5%85%A5%E9%97%A8/"},{"name":"总结","slug":"总结","permalink":"http://blog.curtaintan.club/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"vscode相关配置","slug":"vscode相关配置","date":"2020-01-06T02:57:53.000Z","updated":"2020-01-06T03:05:25.798Z","comments":true,"path":"2020/01/06/vscode相关配置/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/vscode%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"记录自己常用的一些配置…","text":"记录自己常用的一些配置… 打开setting.json配置文件 VSCode实现用Ctrl+滚轮实现代码的缩放配置文件如下： 在文件–&gt;首选项–&gt;设置–&gt;用户设置中添加如下代码： 1\"editor.mouseWheelZoom\": true","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.curtaintan.club/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vsCode","slug":"vsCode","permalink":"http://blog.curtaintan.club/tags/vsCode/"}]},{"title":"一个小demo弄懂vue的$nextTick","slug":"一个小demo弄懂vue的$nextTick","date":"2020-01-06T01:51:23.000Z","updated":"2020-01-31T01:31:37.853Z","comments":true,"path":"2020/01/06/一个小demo弄懂vue的$nextTick/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/%E4%B8%80%E4%B8%AA%E5%B0%8Fdemo%E5%BC%84%E6%87%82vue%E7%9A%84$nextTick/","excerpt":"一个小demo弄懂vue的$nextTick的作用","text":"一个小demo弄懂vue的$nextTick的作用 有这样一段代码： 代码截图： 123456789101112131415161718192021222324252627&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;span id=\"span\" v-if=\"showSpan\" &gt;span&lt;/span&gt; &lt;button @click=\"btn\" &gt;显示&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data: &#123; showSpan: false &#125;, methods: &#123; btn()&#123; this.showSpan = true console.log( document.querySelector(\"span\") ) setTimeout( () =&gt; &#123; console.log( \"200毫秒后\" ) console.log( document.querySelector(\"span\") ) &#125;, 200 ) this.$nextTick( () =&gt; &#123; console.log( \"$nextTick执行的结果\" ) console.log( document.querySelector(\"span\") ) &#125; ) &#125; &#125; &#125;)&lt;/script&gt; 执行结果： 分析第一个结果为null，因为没有找到dom元素，第二个出现的是$nextTick执行的结果，是确定dom重新渲染挂载完毕执行的回调函数第三个才是定时器的结果，是在最后执行的函数。 结论可知，vue中数据更新引起的dom更新是异步执行的。 小拓展v-if和v-show的区别当我们把上文的 v-if 改成 v-show 后，我们可以看到： 可以看出，v-if=false 时，元素不会渲染到页面，使用 v-show 元素一直在页面中，只是设置样式 display: none; 没有显示而已，","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.curtaintan.club/tags/vue/"}]},{"title":"正则之给字符串来一套增删改查服务","slug":"正则之给字符串来一套增删改查服务","date":"2020-01-03T13:47:46.000Z","updated":"2020-01-04T15:16:16.829Z","comments":true,"path":"2020/01/03/正则之给字符串来一套增删改查服务/","link":"","permalink":"http://blog.curtaintan.club/2020/01/03/%E6%AD%A3%E5%88%99%E4%B9%8B%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E4%B8%80%E5%A5%97%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%9C%8D%E5%8A%A1/","excerpt":"想学习正则的操作吗？？那就进来吧…","text":"想学习正则的操作吗？？那就进来吧… 导读嗨咯，亲爱的读者你好！既然你点进来了，那么想必你一定对正则感兴趣吧。 如果你对正则充满畏惧心理，不懂也不理解正则，没关系，往下看， 看完这篇文章，相信你一定会对正则充满兴趣，并且不再畏惧，消灭恐惧的最好办法，就是面对恐惧！！ 加油！！读完它，理解正则操作，然后爱上正则！ 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 @老姚JS正则表达式完整教程（略长） 老姚对正则的评价非常到位，我很赞同，希望你能记住，这篇文章就是在匹配的基础上做的相关的操作。 如果你没有正则的基础，请不要害怕，这篇文章会一步一步的带你了解正则相关的操作，每个操作的案例相对简单易理解，但是展示出了每个操作的作用。在阅读文章前，请仔细的阅读前置知识，了解相关api的作用。 如果你学习过正则，对正则有一定了解，那么这篇文章非常适合你，这篇文章可以加深你对正则用法的理解。 如果你是正则高手，文中有写的不对的和写得不妥当的，也请指出错误。 本文不涉及正则表达式的书写教学，但是并影响你对每个增删查改操作的理解。如果你想学习正则表达式的书写，在文章后面我有推荐学习正则的优秀文章。 相信你看过这篇文章后，会提高你对正则的理解与学习正则的兴趣。加油！ 前置知识既然是用正则对字符串的操作，那么，我们得需要了解相关的方法，对吧？？与正则相关的方法就6个（真的很少很容易理解！！）：如果你对下面六个方法非常熟悉了，你可以直接从前置知识的总结处开始看（￣︶￣）↗ 与正则相关的6个方法12345678// 字符串四个String#search // 查找匹配到字符串的位置，返回位置indexString#split // 以正则匹配到的字符串截断原字符串，返回数组String#match // 匹配字符串并返回一些信息String#replace // 对匹配到的字符串进行替换，返回修改后的字符串// 正则两个RegExp#test // 匹配字符串是否有符合正则的部分RegExp#exec // 匹配字符串，并返回相关信息 1.String#search语法：str.search(regexp) 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. search1234var regex = /\\d/var string = \"abc123\"console.log( string.search(regex) )// =&gt; 3 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 2.String#split语法：str.split(separator, limit) 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 split1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex, 2) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.String#match语法：str.match(regexp) 定义：查找出与正则相匹配的项。 返回值： 正则的匹配模式为全局匹配：返回匹配的数组或则null 正则的匹配模式不是为全局匹配：返回匹配到的项，groups：分组，index:找到结果的索引,input:原字符串 match1234567var str = \"aa22bb313cc444ff\"var reg = /\\d+/gvar reg1 = /(\\d+)([a-z]+)(\\d+)/console.log( str.match( reg ) )console.log( str.match( reg1 ) )// =&gt; [\"22\", \"313\", \"444\"]// =&gt; [\"22bb313\", \"22\", \"bb\", \"313\", index: 2, input: \"aa22bb313cc444\", groups: undefined] 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 4.String#replace语法：str.replace( regexp | substr, newSubStr | function ) 参数说明： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 用来创建新子字符串的函数，该子字符串用于替换与给定regexp或的匹配项substr。 参数function的参数说明： 第一个参数：整个正则或者字符串匹配到的字符串， 中间的参数：依次为正则中分组匹配到的字符串， 倒数第二个参数：找到结果的索引 倒数第一个参数：原字符串 str.replace( regexp, function )12345678var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; console.log( \"参数列表：\", str, s1, s2, index, sour ) console.log( arguments ) return s1 + \"---\" + s2&#125;)console.log( str ) 5.RegExp#test语法：reg.test( str ) 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false reg.test()1234var regex = /\\d/var string = \"abc123\"console.log( regex.test(string) )// =&gt; true 6.RegExp#exec语法：reg.exec( str ) 说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 reg.exec( str )12345var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gconsole.log( reg.exec( str ))console.log( reg.exec( str ))console.log( reg.exec( str )) 注意当使用全局模式时，exec函数会把这次匹配到的位置存放在当前正则reg的lastIndex里面，下次调用时，会从这次的最后位置开始查找。 总结通过上面简单的案例与说明，相信你已经可以看出我们要进行的增删改查操作应该用哪个方法了吧？我们来总结一下： 增：6个方法中，只有replace可以对匹配到的字符串进行操作，所以当我们需要在字符串中增加内容时，我们就可以使用replace方法。 删：6个方法中，split方法以匹配到的字符串为断点截断字符串返回数组，replace也可以对匹配到的字符串进行操作，所以删除可以使用split和replace方法。 查：6个方法中，除了split方法，都或多或少可以得到一些匹配到字符串的信息。 改：6个方法中，只有replace方法可以操作匹配到的字符串，所以修改只有用replace方法。 好了，下面详细的介绍下各种操作的详细情况。 1.增相信你一定遇到过往字符串里面加字符串的情况，你一般是怎么操作的呢？我们来分析下： 当向字符串中添加字符串时，有两种添加情况，一种：添加到匹配的字符串前，另一种是：添加到匹配的字符串后面。 是吧？？好，开始操作吧！ 添加到匹配字符串前：我们可以使用正则位置匹配表达式：(?=p)，正向肯定预查，其中p是一个子模式，即p前面的位置。 123var result = \"hello\".replace(/(?=ll)/g, '#')console.log(result)// =&gt; \"he#llo\" 也可以直接使用函数操作： 12345var result = \"hello\".replace(/(?=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"he#llo\" 添加到匹配字符串后：我们可以使用正则位置匹配表达式：(?&lt;=p)，反向肯定预查，就是p后面的位置。 12345var result = \"hello\".replace(/(?&lt;=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"hell#o\" 当然，你也可以直接使用replace的函数操作完成。 补充 在整个字符串前和后面添加， 12345var result = \"hello\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello#\" 在每个单词的前后面添加 12345var result = \"hello world\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello# #world#\" 2.删：经过我们前面的总结，删除可以使用String.split和String.replace完成。 String.splite可以知道，使用splite方法返回的是一个数组，操作后，我们可以使用join()函数，返回字符串 1234var str = \"aa22bb313cc444ff\"var reg = /\\d+/console.log( str.split( reg ).join(\"\") )// =&gt; \"aabbccff\" String.replace使用replace就非常简单了，我们可以把第二个参数传 &quot;&quot; ,也可以用函数操作，返回 &quot;&quot;即可。 12345var str = \"aa22bb313cc444ff\"var reg = /\\d+/g // 全局模式，不加全局模式，只会替换一次str = str.replace( reg, \"\" )console.log( str )// =&gt; \"aabbccff\" 3.查查找可以分为两类：一种是需要详细结果的，一种是不需要详细结果的。 不需要详细结果不需要详细结果就是返回 true 和 false 就可以了。这里可以使用test 验证电话号码123var reg = /^1[345789]\\d&#123;9&#125;$/var res = reg.test( \"13882628333\" )// =&gt; true 需要详细结果使用String.match()获取时间123var reg = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( \"2017-06-10\".match( reg ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var string = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( string.match( reg ))// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] match获取全部的颜色代码（正则使用g全局匹配模式）1234var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"console.log( str.match( reg ) )// =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 使用reg.exec()获取时间123var regex = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( reg.exec( \"2017-06-10\" ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var str = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( reg.exec( str ) )// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] exec获取全部的颜色代码（正则使用g全局匹配模式）12345678var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"var arr = []var tempwhile( temp = reg.exec( str ) )&#123; arr.push( temp[0] )&#125;console.log( arr ) 4.改经过前面的终结，我们知道只有replace可以进行修改操作： 1234567var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; return s1 + \"---\" + s2&#125;)console.log( str )// =&gt; \"aa22---bb313---cc444---ff\" 后记写下这篇文章，就是想让自己梳理下正则相关的api与用法，加强一下自己写正则的信心。 看了这篇文章，你是否对正则又有了新的理解呢？对自己写正则是否又增加了几分信心呢？ 总结本文主要讲述了正则的相关用法，考虑到正则新手，所以每个操作都只是做的很简单的案例，正则表达式大都很简单，但是，我相信，看了本文，你会更有信心去学习正则。 学习正则：如果你想学习正则表达式的书写，我这里将推荐一些好的文章给你： 老姚-JS正则表达式完整教程（略长） 非常推荐的一篇文章，我就是看这篇文章学习的正则，适合有一点正则基础的同学 考拉海前端团队—JS 的正则表达式 条理清晰–适合初学者学习正则的书写 文章在精不在多，这两篇文章对初学正则的同学非常友好，能引导你写出优秀的正则表达式，再结合这篇文章对正则表达式的运用，相信你会对正则的运用游刃有余。 参考资料：老姚-JS正则表达式完整教程（略长） MDN-String.prototype.match() MDN-String.prototype.replace() 共勉写下这篇文章，希望对你有帮助，与君共勉！","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"博客再次启程","slug":"博客再次启程","date":"2019-12-02T09:52:17.000Z","updated":"2020-02-07T15:56:26.796Z","comments":true,"path":"2019/12/02/博客再次启程/","link":"","permalink":"http://blog.curtaintan.club/2019/12/02/%E5%8D%9A%E5%AE%A2%E5%86%8D%E6%AC%A1%E5%90%AF%E7%A8%8B/","excerpt":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！","text":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！ 碎碎念经过一天的配置，博客搭建的差不多了， 整理好心情！！！ 重新出发！","categories":[{"name":"我的随笔","slug":"我的随笔","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.curtaintan.club/tags/%E7%94%9F%E6%B4%BB/"}],"author":{"avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png","url":"http://blog.curtaintan.club/"}},{"title":"drawing-board画板","slug":"drawing-board画板","date":"2019-08-14T08:04:55.000Z","updated":"2020-02-06T05:21:32.102Z","comments":true,"path":"2019/08/14/drawing-board画板/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/drawing-board%E7%94%BB%E6%9D%BF/","excerpt":"canvas写的画板","text":"canvas写的画板 快到碗里来-画板 预览：点击 前言： 之前学完canvas，一直想自己写一点东西，这两天终于完成了，开心！！ 完成功能： 绘画 画直线 截图 旋转 弹幕 鼠标触碰弹幕，弹幕悬停 撤销/前进 设置画笔信息 兼容移动端 功能截图： 前置说明如果你需要参考代码，你需要看下这里。因为功能复杂，标志的变量有接近10个之多，一下子可能很难看懂，所以我这里说明下我的开发流程，以及定义变量的顺序。 功能顺序： 画笔 → 定义画笔信息 → 橡皮檫 → 删除 → 撤销/前进 → 直线 → 截图 → 弹幕 定义变量的顺序，以及作用： 所有功能变量： 1234567891011121314151617181920212223242526272829303132333435363738var isDown = false // 标志鼠标是否按下 绘图三步和剪切三步走时，后面两个事件触发的标志var points = [] // 滑动时收集的点 绘画三步走时，为了时画的线光滑，记录点，减短画线的距离var beginPoint = null // 开始的点 绘画三步走时使用----这三个为一组，画线三人组，为了让画的线更为光滑var currentMenu = \"icon-pen\" // 初始按钮 底部按钮选中的按钮var currentColor = 0 // 初始颜色的index 颜色选择，默认第一个var paintingModal = \"pen\" // 画笔模式 line||pen||cut----按钮功能三人组，按钮选中标记，颜色选中，画画的模式，切换前面画笔和画直线的模式var lookModal = false // 鼠标模式 按钮第一个功能，此模式不能绘画，只能看var cuted = false // 标记裁剪时，是否已经裁剪 裁剪后，防止后续的操作再次触发裁剪操作 ----鼠标模式和剪切模式的定义var animationTimer = null // 弹幕动画的timer 动画的timervar barrageArray = [] // 保存弹幕的数组var globalPoint = &#123; x : 0, y : 0 &#125; // canvas上鼠标的点 ---弹幕时使用----弹幕三人组 globalPoint用来标记鼠标在canvas中的坐标，用于判断鼠标是否触碰到弹幕上// 实现撤销和重做的功能let canvasHistory = [] // canvas数据，在每次画线和橡皮檫使用后保存数据let step = 0 // 画笔抬起的步数，清空时，步数也清空----撤销/前进二人组，画笔抬起时，把画布信息用getImageData存入canvasHistory，用step完成前进和撤销的功能var penAttibutes = &#123; // 画笔数据， width : 2, lineCap : \"round\", lineJoin : \"round\", strokeStyle: \"#000\", fillStyle: \"#000\", globalCompositeOperation: \"source-over\", globalAlpha : 1&#125; 开发中遇到的难点与重点与解决方案： 保存历史记录使用api对比 我在写代码的时候有做过参考 这篇文章，文章里用是canvas.toDataUrl的方式做的数据保存，评论里说这个数据保存不理想，其实我一开始的时候想的就是用ctx.getImageDaata的方式来做的，我也用这个两个api做了一个对比： 代码： 结果： 可见，使用getImageData获取数据是时间是非常短的，并且获取到是画布像素数据，后续可以直接进行像素操作，从而不用再花时间再去获取画布信息，其次，getImageData获取到是数据是有数据结构的，这样在内存里面保存下来对内存更加友好，而使用toDataUrl方式保存下来的数据有21万行那么长的字符串，对内存并不友好。 后面我还做了他们绘制到画布上的时间对比，他们的时间都在1ms内，到时每次putImageData都要快一点点，但是快这一点时间的意义并不大。 toDataUrl也是有好处的，因为转置出来的是base64的字符串，所以他能够直接作为图片的src属性，让图片显示到页面。 画直线 如何画出一条直线？？当我做了撤销和前进的时候，我就把画板数据给存到canvasHistory里面了，这里刚好用到，鼠标移动是时候，先清空画布，再绘制保存到canvasHistory里最后那个数据，然后就是绘图三步走，就完成了。 注意：这里一定要绘图三步走，或者在绘制前一定要用beginPath()重开一条路径，如果不重开路径，绘制时，会把前面的直线一同绘制出来，因为你一直是一条路径，所以下次绘制时，上次的点也要绘制一遍。 图片旋转 旋转很类似css3，但是，canvas的基点固定在左上角处，所以在旋转的时候，需要先用translate移动画板，可以画一下图， 下面是我画的图： 问题： 当我画笔有rotate属性的时候，当前操作的putImageData不会成功，不知道为什么----- 如何画出一条光滑的曲线 用正常的画法画曲线是时候，画出的曲线不够光滑， 所以我就参考了这篇文章 canvas进阶——如何画出平滑的曲线? （其实我也想到了用二次贝塞尔曲线，在寻找更好的解决方案时，就找到这个方法了，这个方案更优），原理可以看原文。 鼠标触摸弹幕 因为canvas是无记忆性的，所以，你用isPointPath和isPointStroke时，是在当前绘画下才能检测。 在使用isPointPath时，他只与path路径有关，意思就是，你用fillRect直接绘制一个矩形图形是不能检测的， 只能检测rect()和pathTo等围起来的路径内。 所以，这里我做了一个外挂路径-用rect()把每个弹幕框起来——哈哈– 使用drawImage须知： drawImage有三种传参方式，三种方式出来的效果，在书写前可以先参考效果。 参考地址：CanvasRenderingContext2D.drawImage 兼容移动端 当在移动端时，会存在移动端延时300ms的问题，因为移动端有双击放大功能，故存在300ms时间。 我解决的方法是设置meta信息，禁止缩放，就可以防止300ms问题 结语：这个项目大概用了canvas的75%的api，还有像素操作和渐变等api还没用到。 不知道有没有人看呢， 如果你看到了这篇文章，希望对你有帮助。 慢慢来，好好学习，要加油哦！ 与君共勉！！ 参考材料： 手把手教你实现一个canvas智绘画板 参考了楼主项目的样式，但是所有样式都是我自己写的，嘻嘻，实现方式不一样哦。。 canvas进阶——如何画出平滑的曲线? 画一条光滑的曲线，不错哦。 canvas动画包教不包会 可以在这里把所有api的意义和作用和参数等都记下来—– Canvas API中文文档首页地图 canvas所有的api，当然你也可以去mdn看，其实都一样啦—","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://blog.curtaintan.club/tags/canvas/"}]},{"title":"正则小记（一）之api速学","slug":"正则小记（一）之api速学","date":"2019-08-14T08:04:55.000Z","updated":"2020-01-02T04:43:51.427Z","comments":true,"path":"2019/08/14/正则小记（一）之api速学/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8Bapi%E9%80%9F%E5%AD%A6/","excerpt":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章…","text":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章… 前言正则，用简短的一句话概括，正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则的方法和与正则有关的方法共有6个，字符串实例4个，正则实例2个： String#search String#split String#match String#replace RegExp#test RegExp#exec 1.search()定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1234var regex = /\\d/;var string = \"abc123\";console.log( string.search(regex) );// =&gt; 3 2.split定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 例子： 1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.match定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则： 匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( string.match(regex) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 4.replace语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. replace后面单独写一篇文章总结 案例： 12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";var date = [];string.replace(regex, function(match, year, month, day) &#123; date.push(year, month, day);&#125;);console.log(date);// =&gt; [\"2017\", \"06\", \"26\"] 5.test说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1234var regex = /\\d/;var string = \"abc123\";console.log( regex.test(string) );// =&gt; true 6.exec说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 这个方法很类似match方法。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( regex.exec(string) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 相关API注意要点-1 search和match的参数问题我们知道字符串实例的那4个方法参数都支持正则和字符串。 但search和match，会把字符串转换为正则的。 1234567891011121314151617181920212223var string = \"2017.06.27\";console.log( string.search(\".\") );// =&gt; 0//需要修改成下列形式之一console.log( string.search(\"\\\\.\") );console.log( string.search(/\\./) );// =&gt; 4// =&gt; 4console.log( string.match(\".\") );// =&gt; [\"2\", index: 0, input: \"2017.06.27\"]//需要修改成下列形式之一console.log( string.match(\"\\\\.\") );console.log( string.match(/\\./) );// =&gt; [\".\", index: 4, input: \"2017.06.27\"]// =&gt; [\".\", index: 4, input: \"2017.06.27\"]console.log( string.split(\".\") );// =&gt; [\"2017\", \"06\", \"27\"]console.log( string.replace(\".\", \"/\") );// =&gt; \"2017/06.27\" 2 match返回结果的格式问题match返回结果的格式，与正则对象是否有修饰符g有关。 1234567var string = \"2017.06.27\";var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; [\"2017\", \"06\", \"27\"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有g，返回的是所有匹配的内容。 3 exec比match更强大当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。 而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配： 123456789101112131415161718var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"]// =&gt; 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"] 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"] 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"] 10 4 修饰符g，对exex和test的影响上面提到了正则实例的lastIndex属性，表示尝试匹配时，从字符串的lastIndex位开始去匹配。 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。 而正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。下面让我们以test为例，看看你是否会迷糊： 1234567var regex = /a/g;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 1// =&gt; true 3// =&gt; false 0 注意上面代码中的第三次调用test，因为这一次尝试匹配，开始从下标lastIndex即3位置处开始查找，自然就找不到了。 如果没有g，自然都是从字符串第0个字符处开始尝试匹配： 1234567var regex = /a/;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 0// =&gt; true 0// =&gt; true 0 5 test整体匹配时需要使用^和$这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： 123456console.log( /123/.test(\"a123b\") );// =&gt; trueconsole.log( /^123$/.test(\"a123b\") );// =&gt; falseconsole.log( /^123$/.test(\"123\") );// =&gt; true 6 split相关注意事项split方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： 123var string = \"html,css,javascript\";console.log( string.split(/,/, 2) );// =&gt;[\"html\", \"css\"] 7 replace是很强大的 《JavaScript权威指南》认为exec是这6个API中最强大的，而我始终认为replace才是最强大的。 因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号例如，把”2,3,5”，变成”5=2+3”： 123var result = \"2,3,5\".replace(/(\\d+),(\\d+),(\\d+)/, \"$3=$1+$2\");console.log(result);// =&gt; \"5=2+3\" 又例如，把”2,3,5”，变成”222,333,555”: 123var result = \"2,3,5\".replace(/(\\d+)/g, \"$&amp;$&amp;$&amp;\");console.log(result);// =&gt; \"222,333,555\" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”: 123var result = \"2+3=5\".replace(/=/, \"$&amp;$`$&amp;$'$&amp;\");console.log(result);// =&gt; \"2+3=2+3=5=5\" 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： 123456\"1234 2345 3456\".replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function(match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; [\"1234\", \"1\", \"4\", 0, \"1234 2345 3456\"]// =&gt; [\"2345\", \"2\", \"5\", 5, \"1234 2345 3456\"]// =&gt; [\"3456\", \"3\", \"6\", 10, \"1234 2345 3456\"] 此时我们可以看到replace拿到的信息，并不比exec少。 8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多\\。 12345678var string = \"2017-06-27 2017.06.27 2017/06/27\";var regex = /\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/g;console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"]regex = new RegExp(\"\\\\d&#123;4&#125;(-|\\\\.|\\\\/)\\\\d&#123;2&#125;\\\\1\\\\d&#123;2&#125;\", \"g\");console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"] 9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline10 source属性正则实例对象属性，除了global、ingnoreCase、multiline、lastIndex属性之外，还有一个source属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： 1234var className = \"high\";var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\");console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串\"(^|\\\\s)high(\\\\s|$)\" 11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是$1,…,$9之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp[&quot;$&apos;&quot;]测试代码如下： 1234567891011121314151617181920212223var regex = /([abc])(\\d)/g;var string = \"a1b2c3d4e5\";string.match(regex);console.log( RegExp.input );console.log( RegExp[\"$_\"]);// =&gt; \"a1b2c3d4e5\"console.log( RegExp.lastMatch );console.log( RegExp[\"$&amp;\"] );// =&gt; \"c3\"console.log( RegExp.lastParen );console.log( RegExp[\"$+\"] );// =&gt; \"3\"console.log( RegExp.leftContext );console.log( RegExp[\"$`\"] );// =&gt; \"a1b2\"console.log( RegExp.rightContext );console.log( RegExp[\"$'\"] );// =&gt; \"d4e5\" 结语： 我搜查列出了相关的6个方法，并对6个方法进行了说明。 后面我会对replace再单独出一篇文章。 参考资料里的第一篇文章真的非常好，值得仔细研读。 如果你想粗略了解正则的方法，看我这篇文章是没错了，后面列出的相应方法的坑点和注意点。 后面，我会再慢慢补充匹配规则，我会单独列出一篇文章，因为匹配规则也有很多注意点呢。 哈哈哈，其实也是在下面的文章里面看的啦，文章真的写得好---嘻嘻 其实正则也没有那么难的啦----- 希望这篇文章对你有帮助，每天都要加油哦。 加油，与君共勉！！！参考资料： JS正则表达式完整教程（略长） 文章真的写的不错，认认真真，细嚼慢咽的看完这篇文章，保证你学会正则。 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。 MDN-RegExp MDN-String","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]}]}