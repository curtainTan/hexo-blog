{"meta":{"title":"curTain","subtitle":"","description":"","author":"tanTantan","url":"http://blog.curtaintan.club","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-02T08:25:53.803Z","updated":"2019-12-02T08:25:53.803Z","comments":true,"path":"404.html","permalink":"http://blog.curtaintan.club/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2019-12-26T14:01:52.812Z","updated":"2019-12-26T14:01:52.812Z","comments":true,"path":"categories/index.html","permalink":"http://blog.curtaintan.club/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-19T14:19:43.681Z","updated":"2020-02-19T14:19:43.681Z","comments":true,"path":"about/index.html","permalink":"http://blog.curtaintan.club/about/index.html","excerpt":"","text":"纸上得来终觉浅、 关于我：目前就读于成都大学，大三 热爱的： coding 探索 前端 科技 电子产品 技术栈： js flutter nodejs mysql 愿望： 打造一个多端的app 和好朋友们一起吃好多好吃的 和好朋友们一起去海边看海 有自己热爱的东西，平静简单的生活.. 欢迎灌水"},{"title":"我的朋友们","date":"2020-02-06T02:23:42.801Z","updated":"2020-02-06T02:23:42.801Z","comments":true,"path":"friends/index.html","permalink":"http://blog.curtaintan.club/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-03T08:42:54.518Z","updated":"2019-12-03T08:42:54.518Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.curtaintan.club/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-03T08:46:42.440Z","updated":"2019-12-03T08:46:42.440Z","comments":true,"path":"tags/index.html","permalink":"http://blog.curtaintan.club/tags/index.html","excerpt":"","text":""},{"title":"我的收藏夹","date":"2020-02-22T06:58:25.188Z","updated":"2020-02-22T06:58:25.188Z","comments":true,"path":"favorite/index.html","permalink":"http://blog.curtaintan.club/favorite/index.html","excerpt":"","text":"1. 图床 又拍图床 speed 路过图床(稳定、推荐使用) 2. 前端 前端 100 问：能搞懂 80% 的请把简历给我 22 道高频 JavaScript 手写面试题及答案 11道浏览器原理面试题 手写题:9道字符串类高频面试题 MDN-web api 一览 2.1 React相关面试官:既然React/Vue可以用Event Bus进行组件通信,你可以实现下吗? 面试官(8): React 强调的『不可变数据结构』怎么实现? 三千字讲清TypeScript与React的实战技巧 2019年17道高频React面试题及详解 2.2 面试技巧「技术面试」问答中有什么十分实用的面试技巧? 3. sequelize一点通 Sequelize 快速入门 Sequelize 系列教程之一对一模型关系 Sequelize 系列教程之一对多模型关系 Sequelize 系列教程之多对多模型关系 4. 色彩搭配Paleetescss 渐变 大家有什么好的东西，可以在下面给我留言...."},{"title":"我的作品","date":"2020-02-29T07:24:32.159Z","updated":"2020-02-29T07:24:32.159Z","comments":true,"path":"projects/index.html","permalink":"http://blog.curtaintan.club/projects/index.html","excerpt":"","text":"2020.2 lazy-load-img-tan 一个 typescript 构建的图片懒加载插件 Features： typescript npm 源码地址：github使用文档：github-lazy-load-img-tan 2020.1 little chat 一直都想重构之前的chatGo聊天项目，终于重构了！开心… Features： 使用create-react-app构建 hooks redux + redux-saga 状态管理 使用immutable.js 适配移动端 私聊 群聊 申请加群 支持发送图片和emoji 服务端： socket.io搭配koa2 使用单例模式管理状态 使用函数柯理接收参数 一开始用dva构建的项目，后来用create-react-app重构了项目： react版本：react版本预览dva简化版本：dva版本预览地址源码地址：github 2019.11 nextGo使用nextjs搭配koa2搭建的仿写github的ssr项目，项目使用github接口，使用OAuth进行登录。 Features： 使用nextjs构建 使用hooks 使用redux管理状态 集成koa2 使用HOC定制props 接入github—OAuth 使用webpack-bundle-analyzer分析打包依赖 预览地址：nextGo源码地址：github打包分析：点击直达 2019.9 fabric-board 用fabric.js重写的面向对象的画板 使用了同学（胡翔）的ipad和配套的Apple Pencil，体验了记事本的功能，突发奇想，我就实现了一下，使用图层对象的形式来开发画板，体验还是不错的。 这个项目从开始构想，到大体完成只花了两天，后面在完善获取图层组，然后将图层组单独拿出来渲染到右侧的小canvas上的时候，出现了问题， 断断续续的写了下，还是没有解决。 Features： fabric.js canvas vue 图层式操作 预览地址：fabricGo源码地址：github 2019.8 canvasGo 使用canvas构建的画板项目，原生js操作。 Features： 原生js canvas 兼容手机端 拥有发送弹幕功能 截图功能 截图可旋转 撤销/前进 预览地址：canvasGo源码地址：github配套文章：快到碗里来 2019.6 electron-music 是学习electron的小demo吧，后面一定会推出electron的更完善的应用的。 Features： electron 原生js 桌面应用 本地数据缓存 源码地址：github 2019.5 网易云Go 使用flutter构建的模仿网易云音乐app，界面还原度很高， Features： flutter构建 播放视频与vedio 播放音乐 导航栏级联滑动 搜索提示 节流操作 provide状态管理 组件式开发 源码地址：github下载地址： 安卓下载：点我下载 扫码下载： ios：由于没有ios手机和mac，所以没有打包ios版本 2019.3 知程 使用原生小程序构建，工作室团队项目， Features： 微信小程序 城市级联 flex布局 源码地址：github 2018.10 chatGo 使用socket.io搭配express搭建而成的在线聊天系统，后面会使用框架搭建一个更全面，界面更友好的在线聊天系统， Features： socket.io构建而成 bootstrap栅格系统 源码地址：github预览地址：chatGo 2018.10 小小论坛 这是最初的作品，也是心心念念想要去完成的作品，最初是版本是留言板，后来一再一再的扩展，就变成了这样的一个论坛了。其实蛮喜欢这个作品的，最近也在重构中，也在试图添加更多功能… Features： vuejs、vuex、vue-router全家桶 quill富文本编辑器 路由守卫 token鉴权 源码地址：github预览地址：点击直达"}],"posts":[{"title":"10.4-每日一题--两数相加(链表)","slug":"10-4-每日一题","date":"2020-10-04T14:14:22.000Z","updated":"2020-10-04T14:20:36.581Z","comments":true,"path":"2020/10/04/10-4-每日一题/","link":"","permalink":"http://blog.curtaintan.club/2020/10/04/10-4-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"两数相加","text":"两数相加 2. 两数相加 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 实现123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; let node = new ListNode(0) // 记录下返回的节点 let res = node let flag = 0 while( l1 || l2 )&#123; // 当其中一个节点为 null 时取 0 let now = ( l1 &amp;&amp; l1.val || 0 ) + ( l2 &amp;&amp; l2.val || 0 ) + flag // 超过十，标记进位 flag = now &gt;= 10 ? 1 : 0 node.next = new ListNode( now % 10 ) node = node.next l1 = l1 &amp;&amp; l1.next l2 = l2 &amp;&amp; l2.next &#125; // 计算完后，有进位，需要加上进位 if( flag )&#123; node.next = new ListNode( flag ) &#125; return res.next&#125;; 总结答题要点： 记录首节点 记录进位 添加进位数","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.curtaintan.club/tags/leetcode/"},{"name":"链表","slug":"链表","permalink":"http://blog.curtaintan.club/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"10.3-每日一题--缺失数字","slug":"10-3-每日一题-缺失数字","date":"2020-10-03T00:46:51.000Z","updated":"2020-10-03T00:46:51.809Z","comments":true,"path":"2020/10/03/10-3-每日一题-缺失数字/","link":"","permalink":"http://blog.curtaintan.club/2020/10/03/10-3-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"位操作符","slug":"位操作符","date":"2020-10-02T10:22:51.000Z","updated":"2020-10-03T01:46:40.210Z","comments":true,"path":"2020/10/02/位操作符/","link":"","permalink":"http://blog.curtaintan.club/2020/10/02/%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"缺失数字","text":"缺失数字 268. 缺失数字给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1]输出: 2示例 2: 输入: [9,6,4,2,3,5,7,0,1]输出: 8 解法一 高斯求和公式使用数学解法： 利用高斯求和公式求出序列长度值总和 遍历数列，求出现有总和 相减得差 可知，和为 0 到 n 的和，高斯求和公式：总个数 / 2 * ( 最小的数 + 最大的数 ) 实现12345678910var missingNumber = function(nums) &#123; // 因为缺失了一个数，所以长度要加一， // 最大的数就是数组的长度那个数，那个数加上 0 let allcount = ( nums.length + 1 ) / 2 * ( nums.length + 0 ) let res = 0 for( let i = 0; i &lt; nums.length; i ++ )&#123; res += nums[i] &#125; return allcount - res&#125;; 解法二 位运算异或运算满足结合律，两个相同的数异或运算返回 0，不相同的数异或返回原来的数 异或运算的真值表： a b a^b 0 0 0 0 1 1 1 0 1 1 1 0 案例： 1^1 // 01^2 // 3 10^1 -&gt; 11 -&gt; 2+1=34^5 // 1 4-&gt;100 5-&gt;101 100^101 -&gt; 001 -&gt; 1 解释：会把数字转换为二进制，再进行异或运算 案例： 有这样的案例： |下标|0|1|2|3||–|–|–|–||数字|0|1|3|4| 得到公式：4^(0^0)^(1^1)^(2^3)^(3^4)交换律： = (4^4)^(0^0)^(1^1)^(3^3)^2最后结果：= 0^0^0^0^2 = 2 实现1234567var missingNumber = function(nums) &#123; let n = nums.length for( let i = 0; i &lt; nums.length; i ++ )&#123; n ^= nums[i] ^ i &#125; return n&#125;; 总结当涉及到数字运算时，可以优先考虑数学公式和位运算","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://blog.curtaintan.club/tags/js-%E5%9F%BA%E7%A1%80/"}]},{"title":"10.2-每日一题-宝石与石头","slug":"10-2-每日一题","date":"2020-10-02T00:54:32.000Z","updated":"2020-10-02T01:11:42.667Z","comments":true,"path":"2020/10/02/10-2-每日一题/","link":"","permalink":"http://blog.curtaintan.club/2020/10/02/10-2-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"宝石与石头","text":"宝石与石头 771. 宝石与石头给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1: 输入: J = “aA”, S = “aAAbbbb”输出: 3示例 2: 输入: J = “z”, S = “ZZ”输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 解题思路一解题原理：使用正则搭配 replace() 完成计数 在 J 的每个元素后面加上 * ，表示宝石有任意个 构建正则，使用 g 全局模式 使用 replace 函数计数并替换元素 实现123456789101112var numJewelsInStones = function(J, S) &#123; // 创建正则 let Jstr = J.split(\"\").join(\"*\") + \"*\" let reg = new RegExp( Jstr, \"g\" ) let res = 0 // 替换元素并技术 S = S.replace( reg, (all) =&gt; &#123; res += all.length return \"\" &#125;) return res&#125;; 解题思路二使用两次遍历 遍历 J 将每一个元素存在对象内 遍历 S 判定元素是否存在对象上 计数返回结果 实现12345678910111213var numJewelsInStones = function(J, S) &#123; let map = &#123;&#125; let res = 0 // 存入 map for( let item of J )&#123; map[item] = true &#125; // 计数 for( let item of S )&#123; map[item] &amp;&amp; res ++ &#125; return res&#125;; 总结适当的使用 map 来存储值，可以减小时间复杂度","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.curtaintan.club/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://blog.curtaintan.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"红宝书第三章-语言基础","slug":"红宝书第三章-语言基础","date":"2020-09-30T02:17:45.000Z","updated":"2020-10-02T09:44:48.856Z","comments":true,"path":"2020/09/30/红宝书第三章-语言基础/","link":"","permalink":"http://blog.curtaintan.club/2020/09/30/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、语法1.1 变量命名规则 第一个字符必须是一个字符、下划线（_）或美元符号（$） 剩下的字符可以是字母、下划线、美元符号和数字，也可以是 Unicode 的字母字符 1.2 严格模式概念：ES5 添加了严格模式，严格模式是一个预处理指令，严格模式的目的是处理一些不规范写法，对于不安全的活动抛错误 如何添加严格模式： 12345678// 在脚本开头添加一行\"use strict\"// 或在函数体内第一行添加function fn()&#123; \"use strict\" // 函数体&#125; 严格模式的影响： 1.2.1 针对变量： 不允许以外创建全局变量，给一个没有声明的变量赋值，抛错 ReferenceError 引用错误 不能对变量使用 delete 操作符 不能使用保留字作为变量名 案例： 12345678// 非严格模式:创建全局变量 // 严格模式:抛出 ReferenceErrorname = \"tan\";//非严格模式:静默失败 //严格模式:抛出 ReferenceErrorvar color = \"red\";delete color; 1.2.2 针对对象： 为只读属性赋值会抛出 TypeError 对不可配置的属性（noConfigurable）使用 delete 操作会抛出 TypeError 对不可扩展的对象添加属性会抛出 TypeError 使用对象字面量时，属性名必须唯一 案例： 12345678910111213let obj = &#123;&#125;Object.defineProperty( obj, \"name\", &#123; configurable: true, enumerable: true, // read-only writable: false, value: \"tan\"&#125;)// 非严格模式: 默认修改失败// 严格模式: 抛出错误 Cannot assign to read only property \"name\"obj.name = \"yu\" 1.2.3 针对函数： 要求命名函数的参数必须唯一 在非严格模式下，修改命名参数的值会反映到 arguments 对象中，而在严格模式下，值是独立的 arguments.callee 和 arguments.caller，在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError 只能在脚本的顶级和函数内部生命函数 案例： 1234567891011121314151617181920212223242526272829303132333435363738//非严格模式: 没有错误，后面的参数覆盖前面的值//严格模式: 抛出语法错误function fn( num, str, num )&#123; // 非严格模式：undefined 12 // 严格模式: 抛出语法错误 console.log( num, str )&#125;fn( 12, \"tan\" )//非严格模式: 修改会反映到 arguments 中 //严格模式: 修改不会反映到 arguments 中function showValue(value) &#123; value = \"yu\"; console.log(value); // \"yu\" console.log(arguments[0]); // 非严格模式:\"yu\"，严格模式:\"tan\"&#125;showValue(\"tan\");//访问 arguments.callee //非严格模式:没有问题 //严格模式:抛出 TypeErrorfunction factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;var result=factorial(5);//在 if 语句中声明函数 //非严格模式:将函数提升到 if 语句外部 //严格模式:抛出语法错误if (true)&#123; function doSomething()&#123; // todo &#125;&#125; 1.2.4 针对 eval() 函数中的变量 在严格模式中，它在包含上下文中不再创建变量或函数 在 eval() 函数中声明的变量和函数，只在特殊的终于用中有效，随后将被销毁 案例： 123456789//使用 eval()创建变量//非严格模式:弹出对话框显示 10//严格模式:调用 alert(x)时会抛出 ReferenceErroreval(\"var x=10\");console.log(x);\"use strict\";var result = eval(\"var x=10, y=11; x+y\");alert(result); // 21 执行结果存在变量内 1.2.5 抑制 this 指向在非严格模式下使用函数的 apply()或 call()方法时，null 或 undefined 值会被转换为全局 对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值 案例： 12345678// 访问属性// 非严格模式: 传入null, 函数的this值是全局对象// 严格模式: 抛出错误，因为this的值为 nullvar color = \"red\";function displayColor()&#123; console.log(this.color);&#125;displayColor.call(null); 1.2.6 其他影响 严格模式去掉了 JavaScript 中的八进制字面量 严格模式下 parseInt()的行为，八进制字面量在严格模式下会被当作以 0 开头的十进制字面量 案例： 123456789//使用八进制字面量 //非严格模式:值为 8 //严格模式:抛出语法错误var value = 010;//使用 parseInt()解析八进制字面量 //非严格模式:值为 8 //严格模式:值为 10var value = parseInt(\"010\"); 1.2.7 总结简单的概括一下，严格模式会造成以下影响： 变量必须定义后才能赋值，且不能随意删除 修改对象中只读属性和不可配置的属性时，会报错 函数中，arguments 与参数独立，操作互不影响 显式绑定 this 时，不能将函数绑定到 null 上 其他影响，eval 函数执行中的变量定义和定义数字时的进制问题 严格模式的目的： 消除 js 语法不严谨的地方，减少奇怪行为（不定义变量，直接赋值，八进制数字） 消除代码运行不安全的地方（修改只读属性） 提高编译效率和运行速度 为未来做铺垫 二、变量有三个关键字可以声明变量：var、let、const 2.1 var、let、const 的区别 关键字 变量提升 块级作用域 重新赋值 重复声明 var 存在 不存在 可以 可以 let 不存在 存在 可以 不可以 const 不存在 存在 不可以 不可以 注意： const 必须初始化一个值 var 声明的变量在浏览器环境会挂载到 window 上，而 let 和 const 不会 2.2 var、let、const 的使用 不使用 var 定义变量 使用 let 定义需要改变的基础变量 使用 const 定义常量或不会直接更改引用的对象 三、数据类型ECMAScript 有其中简单数据类型（原始类型）： number string boolean null undefined symbol bigInt 复杂数据类型：object（包含对象、function） 3.1 typeof 操作符对一个值使用 typeof 会返回以下字符串之一： undefined 表示值未定义 boolean 表示值为布尔值 string 表示值为字符串 number 表示值为数字 object 表示值为对象（不是函数）或 null function 表示值为函数 symbol 表示值为符号 bigint 表示值为bigint 案例： 12345678910typeof undefined // undefinedtypeof null // objecttypeof true // booleantypeof \"tan\" // stringtypeof 12 // numbertypeof 12n // biginttypeof &#123; name: \"yuuu\" &#125; // objectfunction fn()&#123;&#125;typeof fn // function","categories":[{"name":"红宝书","slug":"红宝书","permalink":"http://blog.curtaintan.club/categories/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"9.30-每日一题","slug":"9-30-每日一题","date":"2020-09-30T00:30:49.000Z","updated":"2020-09-30T02:16:18.856Z","comments":true,"path":"2020/09/30/9-30-每日一题/","link":"","permalink":"http://blog.curtaintan.club/2020/09/30/9-30-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"二叉搜索树中的插入操作","text":"二叉搜索树中的插入操作 701. 二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如： .bg-pre { padding: 10px; background: rgba(33,150,243,.2); border-radius: 4px; } 给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3 和 插入的值: 5 你可以返回这个二叉搜索树: 4 / \\ 2 7 / \\ / 1 3 5 或者这个树也是有效的: 5 / \\ 2 7 / \\ 1 3 \\ 4 提示： 新值和原始二叉搜索树中的任意节点值都不同 解题思路由题可知，题目是搜索二叉树，搜索二叉树的特点是，左子节点的值小于当前节点的值，右子节点的值大于当前节点的值 迭代进行比较，一直比较到下一个位置为 null 时停止，并创建一个节点放在最后就完成了插入 实现1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; val * @return &#123;TreeNode&#125; */var insertIntoBST = function(root, val) &#123; if( !root ) return new TreeNode(val) let node = root // 依次迭代 while( node )&#123; if( val &lt; node.val )&#123; // 迭代到最后，插入节点 if( !node.left )&#123; node.left = new TreeNode(val) break &#125; else &#123; node = node.left &#125; &#125; else &#123; if( !node.right )&#123; node.right = new TreeNode(val) break &#125; else &#123; node = node.right &#125; &#125; &#125; // 返回首节点 return root&#125;; 递归递归实现： 递归结束条件：当前节点为 null，返回以 val 新建的节点将节点的左右节点进行赋值，赋值为当前函数的调用最后返回当前节点 递归实现123456789var insertIntoBST = function(root, val) &#123; if( !root ) return new TreeNode(val) if( val &lt; root.val )&#123; root.left = insertIntoBST( root.left, val ) &#125; else &#123; root.right = insertIntoBST( root.right, val ) &#125; return root&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.curtaintan.club/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"9.29-每日一题--二叉树后序遍历","slug":"9-29-每日一题","date":"2020-09-29T00:47:28.000Z","updated":"2020-09-29T01:36:51.539Z","comments":true,"path":"2020/09/29/9-29-每日一题/","link":"","permalink":"http://blog.curtaintan.club/2020/09/29/9-29-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"二叉树的后序遍历","text":"二叉树的后序遍历 145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 .bg-pre { padding: 10px; background: rgba(33,150,243,.2); border-radius: 4px; } 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归 当前节点存在左节点，递归左节点 当前节点存在右节点，递归右节点 将当前节点的值存到结果中 实现12345678910111213var postorderTraversal = function(root) &#123; // 保存最后结果 let res = [] let dfs = ( node ) =&gt; &#123; if( !node ) return // 左右子树递归 node.left &amp;&amp; dfs( node.left ) node.right &amp;&amp; dfs( node.right ) res.push( node.val ) &#125; dfs( root ) return res&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.curtaintan.club/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"js类型转换","slug":"js类型转换","date":"2020-09-28T08:58:25.000Z","updated":"2020-10-02T07:40:24.915Z","comments":true,"path":"2020/09/28/js类型转换/","link":"","permalink":"http://blog.curtaintan.club/2020/09/28/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"js 中类型转换分为显式类型转换和隐式类型转换 显式类型转换方法：Number()、parseInt()、parseFloat()、toString()、String、Boolean() 隐式类型转换：逻辑运算符（ &amp;&amp;、||、！ ）、运算符（+、-、*、/）、关系运算符（&gt;、&lt;、&lt;=、&gt;=）、相等运算符（==）、if/while 条件运算 一、显式类型转换1.1 Number() Number() 能将任意类型的参数转换为数值类型 规则如下： 布尔值：true 和 false 分别被转换为 1 和 0 数字：返回本身 null：返回 0 undefined：返回 NaN 字符串： 只包含数字（0X/0x开头的十六进制数字字符串，允许正负号），返回十进制数 包含有效浮点数，返回浮点数 空字符串，返回0 不是以上形式的字符串，返回 NaN Symbol：抛错 对象：调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值，如果转换的结果是 NaN，则调用对象的 toString() 方法，再次按照前面的规则转换返回的字符串 强调： 当对象转换为数字时，调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值，如果转换的结果是引用类型，则调用对象的 toString() 方法，再次按照前面的规则转换返回的字符串，如果返回还是引用类型，最后返回 NaN table th:first-of-type { width: 100px; } table th:nth-of-type(3) { width: 100px; } 部分内置对象默认调用的 valueOf() 方法的行为： 对象 返回值 类型 Boolean 布尔值 基础类型 Date 返回毫秒数-从1970.1.1 0:0:0 开始计算 基础类型 Nunber 数字值 基础类型 String 字符串值 基础类型 Array 返回数组本身 对象类型 Object 对象本身 对象类型 Function 函数本身 对象类型 注意： 当数组只有一个元素时，会将第一个元素提取出来做转换 案例： 1234567891011121314151617181920212223242526272829303132// Number() 类型转换Number(true) // 1Number(null) // 0Number(undefined) // NaNNumber(\"0x15\") // 21 0x15 -&gt; 16+5=21Number(\"\") // 0Number(\"-0X16\") // NaNNumber(Symbol(12)) // error// valueOf() 方法返回值[1,2,3,4].valueOf() // [1, 2, 3, 4] 对象类型Number( [1,2,3,4] ) // NaNNumber( [ 12 ] ) // 12Number( [ \"12\" ] ) // 12let empty = [].valueOf() // [] 对象类型Number( empty ) // 0 [].valueOf()=[]-&gt;NaN, 再调用empty.toString()='' Number(\"\") -&gt; 0Boolean().valueOf() // falseNumber( Boolean() ) // 0let date = new Date()date.valueOf() // 1601345955850Number( date ) // 1601345955850function fn()&#123; var a = 1 &#125;fn.valueOf() // fn()&#123; var a = 1 &#125;Number( fn ) // NaNlet obj = &#123; name: \"tan\" &#125;obj.valueOf() // &#123;name: \"tan\"&#125; // 对象本身Number( fn ) // NaN 1.2 parseInt( param，radix )传入两个参数，第一个是需要进行转换的参数，第二是转换的进制，最终返回十进制数字或NaN 1.2.1 第一个参数是字符串： 忽略字符串前面的空格，从非空字符开始计算 空字符串返回 NaN 第一个字符超过进制，返回 NaN，进制从0-9a-z开始计算，最大进制为 36 如果第一个字符在进制内，则解析到第一个超出进制的符号为止 案例： 123456parseInt(\" 0111\") // 111parseInt(\"\") // NaNparseInt(\"1c\", 13) // 25 13+12parseInt(\"1cd\", 13) // 25 13+12parseInt(\"dc1\", 13) // NaN d进制超过13parseInt(\"-1cd\", 13) // -25 1.2.2 第一个参数是数字： 第一个参数不是以 0 开头的，以第二个参数作为进制进行转换 第一个参数是以 0 开头的，先进行八进制转换，再以第二个参数作为进制进行转换 第一个参数是以 0X/0x 开头的，先进行十六进制转换，在以第二个参数作为进制进行转换 案例： 1234parseInt(111) // 111parseInt(13, 16) // 19 16+3parseInt(013, 16) // 17 013-&gt;8+3=11 11-&gt;16+1=17parseInt(0X13, 16) // 25 0X13-&gt;16+3=19 19-&gt;16+9=25 1.2.3 第一个参数是 null 或 undefined返回 NaN 1.2.4 第一个元素是数组取数组的第一个元素作为第一个参数，再进行进制转换 空数组返回 NaN 案例： 1234parseInt([11], 16) // 17 16+1=17parseInt([11, 12, 13, 23], 16) // 17parseInt([]) // NaN 1.2.5 第一个参数是 Symbol 类型抛出错误 1.3 parseFloat( string: string )将参数转为浮点型数字，没有进制转换，转换规则与 parseInt 基本相同 案例： 12parseFloat( \"123.45abc\" ) // 123.45parseFloat( [\"123.45abc\", \"78\", \"9\"] ) // 123.45 1.4 toString() 方法转换规则如下： Number类型：输出数字字符串，函数可以填入转换进制 null 或 undefined：抛错 数组：将数组展开，空数组返回 &quot;&quot; 对象：返回 [object Object] Date：返回日期的文字表示法 函数：函数的字符串 Symbol：输出 Symbol 字符串 Boolean：返回字符串 案例： 12345678910111213141516171819202122232425let num = 29num.toString() // '29'num.toString(15) // '1e' 15+14 14-&gt;e29.5 .toString(15) // '1e.7777777777778'let nul = nullnul.toString() // 抛错[1,2,3].toString() // '1,2,3'[&#123;name:\"tan\"&#125;,1,3].toString() // '[object Object],1,3'[].toString() // ''let obj = &#123;name:\"tan\"&#125;obj.toString() // '[object Object]'let date = new Date()date.toString() // 'Tue Sep 29 2020 18:20:50 GMT+0800 (中国标准时间)'function fn()&#123; console.log(\"tan\") &#125;fn.toString() // 'function fn()&#123; console.log(\"tan\") &#125;'let tan = Symbol(\"tan\")tan.toString() // 'Symbol(tan)'true.toString() // 'true' 1.5 String( value?: any )将参数转为字符串，与 toString 转换规则基本类似，只能传一个参数 与 toString() 不同，String() 可以转换 null 和 undefined 案例： 1234567891011String(123) // '123'String(true) // 'true'String(&#123;&#125;) // '[object Object]'String([]) // \"\"String([1,2,3]) // '1,2,3'String(null) // 'null'String( undefined ) // 'undefined'function fn()&#123; console.log(\"tan\") &#125;String(fn) // 'function fn()&#123; console.log(\"tan\") &#125;' 1.6 Boolean( value?: any )undefined、null、false、&#39;&#39;、0，+-0、NaN 转换为 false 其余都是 true，负数转为 true 案例： 1234567Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(-0) // falseBoolean(NaN) // falseBoolean(-34) // trueBoolean([]) // true 二、隐式类型转换 逻辑运算符（ &amp;&amp;、||、！ ）、运算符（+、-、*、/）、关系运算符（&gt;、&lt;、&lt;=、&gt;=）、相等运算符（==）、if/while 条件运算 2.1 条件判断 &amp;&amp;、||、!、if/while 条件判断 会将数据转换成 Boolean 类型，转换规则同 Boolean 强制类型转换 案例： 123if( [] ) // trueif( ![] ) // falseif( -1 ) // true 2.2 运算符 运算符：+ - * / 2.2.1 + 运算符用于数字相加和字符串拼接 当一侧为 String 类型时，被识别为字符串拼接，优先将另一侧调用 String() 转换为字符串 当一侧为 Number 类型时，另一侧为原始类型时，将原始类型调用 Number() 转化为数字类型 当一侧为 Number 类型时，另一侧为引用类型时，将引用类型作为参数调用 String() 和 Number 类型转换为字符串后拼接 以上三点，优先级从高到低 案例： 123456789101112123 + \"123\" // 123123123 + true // 124123 + null // 123\"1\" + 4 + 5 + \"6\" // 1456123 + &#123;&#125; // 123[object Object] &#123;&#125; -&gt; String(&#123;&#125;) -&gt; [object Object]123 + function fn()&#123;&#125; // 123function fn()&#123;&#125;let nul = null\"tan\" + nul // tannull null -&gt; String(null) -&gt; null12 + [ 5, 4 ] // 125,4 [5, 4] -&gt; String([5,4]) =&gt; 5,4 2.2.1 - * / 运算符将各种非 Number 类型隐式调用 Number() 函数将值转换为数值类型，如果其中一个转换为 NaN，结果为 NaN 案例： 12345678true + true // 22 - true // 35 - 012 // -5 012 -&gt; Number(012) -&gt; 8+2=105 - 0x12 // -13 0x12 -&gt; Number(0x12) -&gt; 16+2=185 - [ 2 ] // 3 [2] -&gt; Number([2]) -&gt; 25 - [ 2, 3 ] // NaN [2, 3] -&gt; Number([2, 3]) -&gt; NaN5 - &#123;&#125; // NaN &#123;&#125; -&gt; Number(&#123;&#125;) -&gt; NaN 2.3 关系操作符 关系操作符：==、&lt;、&gt;、&lt;=、&lt;= 2.3.1 &lt;、&gt;、&lt;=、&lt;= 操作符 两个操作值都是数值，进行数值比较 都是字符串，比较字符对应的字符编码值 一方是 Symbol，抛错 除了上述情况，都使用 Number() 函数进行隐式转换，再进行比较 注意： NaN 与任何数值比较都不相等，都返回 false 案例： 12345678[26] &gt; [12] // true [26] -&gt; Number([26]) -&gt; 26 [24] -&gt; 24 \"abc\" &lt; \"acb\" // true b &lt; c77 &gt; \"76\" // true77 &gt; \"76a\" // false 76a -&gt; Number(\"76a\") -&gt; NaN77 &gt; [] // true Number([]) -&gt; 018 &gt; \"0x11\" // true 0x11 -&gt; Number(0x11) -&gt; 16+1=1717 &gt; \"0x11\" // false 0x11 -&gt; Number(0x11) -&gt; 16+1=17 2.3.1 == 操作符 NaN 不与其他任何值相等 null 与 undefined 进行比较为 true null、undefined 与其他任何值比较结果都为 false Boolean 与其他类型比较，Boolean 先转换为 Number String 与 Number 进行比较，String 转换为 Number 引用类型与基础类型进行比较，引用类型先转换为基础类型（调用 ToPrimitive） 引用类型与引用类型，直接判断是否指向同一对象 注意： 如果没有部署 [Symbol.toPrimitive] 接口，则先返回 valudeOf() 的值，若返回的不是基础类型，再返回 toString() 的值，若返回的不是基础类型的值，则抛出错误 案例： 12345678910[] == ![] // true// ![] -&gt; false// 再运用规则一：false -&gt; 0// 再运用规则三：[] 调用 toPrimitive 返回 0// 0 == 0 返回 true\"[object Object]\" = &#123;&#125; // true// 引用类型与基础类型进行比较，引用类型先调用 ToPrimitive 函数，// 没有 ToPrimitive 函数，则调用 &#123;&#125;.valueOf() 返回引用类型的值// 返回值不是基础类型，继续调用 &#123;&#125;.toString() 返回 [object Object] 附加知识点–对象转换成原始数据类型如果部署了 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基础数据类型，抛出错误。 如果没有部署 [Symbol.toPrimitive] 接口，那么先返回 valueOf() 的值，若返回的不是基础类型的值，再返回 toString() 的值，若返回的不是基础类型的值， 则抛出异常。 案例： 123456789101112131415//先调用 valueOf, 后调用 toStringlet obj = &#123; [Symbol.toPrimitive]() &#123; return 200; &#125;, valueOf() &#123; return 300; &#125;, toString() &#123; return 'Hello'; &#125;&#125;//如果 valueOf 返回的不是基本数据类型，则会调用 toString， //如果 toString 返回的也不是基本数据类型，会抛出错误console.log(obj + 200); //400 总结js 类型转换分为显式转换和隐式转换 通过本文可知，隐式转换也是间接的调用显式转换的方法来进行转换的，但是我们需要记住隐式转换的规则 在显式转换的方法中，需要注意的以下几点： Number( value: any ): 参数以 0 开头会进行八进制转换，以 0x/0X 开头会进行十六进制转换 parseInt( value, radix )：参数是数组时，取第一个元素转换，与 Number() 处理数组的方式不同，传空数组时，会返回 NaN,而 Number([]) 会返回 0 toString(): toString 方法可以将数字转为特定进制的字符串 显式转换的使用： 实现进制互相转换 1234let num = 29let str = num.toString( 16 ) // 1d 16+13=29 13-&gt;dlet strToNum = parseInt( str, 16 )console.log( str, strToNum ) // 1d 29 生成随机字符串 12let randomStr = Math.random().toString(36).slice(2)console.log( randomStr ) // j40a2j457ojg 36进制可以包含所有字母 数组去重 123456789101112let arr = [ 123, 123, &#123; name: \"tan\" &#125;, [ 123 ], [ 1,2 ], &#123; name: \"tan\" &#125;, [ 1,2 ] ]let copyArr = arr.map( item =&gt; JSON.stringify( item ) )let flatArr = [ ...new Set( copyArr ) ]let newArr = flatArr.map( item =&gt; JSON.parse( item ) )// [\"123\", \"123\", \"&#123;\"name\":\"tan\"&#125;\", \"[123]\", \"[1,2]\", \"&#123;\"name\":\"tan\"&#125;\", \"[1,2]\"]console.log( copyArr )// [\"123\", \"&#123;\"name\":\"tan\"&#125;\", \"[123]\", \"[1,2]\"]console.log( flatArr ) 函数深拷贝 1234567891011121314function fn()&#123; console.log( \"hello\" ) console.log( \"hello1111\" )&#125;let bodyStr = \"\"fn.toString().replace( /\\&#123;(.*)\\&#125;/sm, function( all, one )&#123; bodyStr = arguments[1] return \"\"&#125;)let newFn = new Function( bodyStr )// hello// hello1111newFn() 写下这篇文章希望对你有帮助，共勉- 参考材料刘小夕–JS 类型转换的规则是什么？ 粥里有勺糖–offer收割机–js的隐式类型转换规则整理 freeCodeCamp–Javascript 隐式类型转换，一篇就够了！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"科普","slug":"科普","permalink":"http://blog.curtaintan.club/tags/%E7%A7%91%E6%99%AE/"}]},{"title":"红宝书第二章-HTML中的js","slug":"红宝书第二章-HTML中的js","date":"2020-09-28T00:51:11.000Z","updated":"2020-09-28T08:33:24.832Z","comments":true,"path":"2020/09/28/红宝书第二章-HTML中的js/","link":"","permalink":"http://blog.curtaintan.club/2020/09/28/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0-HTML%E4%B8%AD%E7%9A%84js/","excerpt":"","text":"一、&lt;script&gt; 元素&lt;script&gt; 元素由网景公司创造出来，并在网景浏览器2中实现，&lt;script&gt; 元素有以下 8 个属性 table th:first-of-type { width: 130px; } table th:nth-of-type(2) { width: 100px; } 属性名 填写 说明 async 选填 表示立即下载该脚本，但不阻止其他页面操作，比如下载资源或等待掐他脚本加载 charset 可选 使用 src 属性指定的代码字符集，很少使用 corssorigin 可选 配置相关请求的CORS设置，默认不使用 CORS defer 可选 立即下载脚本，不阻止页面其他操作，在文档解析完成后再执行脚本 integrity 可选 允许对比接收到的资源和指定的加密签名以验证资源的完整性，如果接收到的资源的签名与这个属性指定的签名不匹配，页面会报错，脚本不执行 language 废弃 用来标识代码块中的脚本语言，如 VB、JS src 可选 包含要执行代码的外部文件 type 可选 代替language，表示代码块中脚本语言的内容类型，一般是text/javascript，如果这个值是 module ，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字 注意： 使用了 src 属性的 &lt;script&gt; 元素不应该再在元素中包含其他 javascript 代码，如果两者都提供的话，则浏览器只会下载并执行脚本，从而忽略行内代码 &lt;script&gt; 标签位置由于 script 标签会打断 DOM 的解析，所以将脚本放置在文档首部会阻塞 DOM 的解析，导致页面加载变慢，所以一般将 script 标签放在 body 元素中的内容后面，页面会在处理 js 代码之前完成渲染页面 推迟脚本执行HTML4.0.1 为 script 标签定义了 defer 属性，这个属性表示脚本在整个页面解析完成之后再运行，HTML5 规范要求脚本要求脚本按照他们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前运行（defer脚本按顺序执行），并且两者都会在 DOMContentLoaded 事件之前执行 异步执行脚本HTML5 为 script 元素定义了 async 属性，async 与 defer 类似，脚本的加载不会阻塞 DOM 的解析，但是 async 脚本加载完成会立即执行，如果此时还在进行 ODM 的解析，会打断 DOM 解析，被标记为 async 的脚本不能保证按照他们出现的顺序执行，异步脚本会在页面的 load 事件前执行 动态加载脚本除了 script 标签，还有其他方式加载脚本， 使用 js 创建 script 标签 在文档头部预加载：&lt;link rel=&quot;preload&quot; href=&quot;a.js&quot;&gt; &lt;noscript&gt; 元素针对早期浏览器不支持 javascript 的问题，需要一个页面优雅降级的处理方案，&lt;noscript&gt; 元素出现，对不支持 javascript 的浏览器提供替代内容，与 &lt;canvas&gt; 元素中添加内容的目的一样，用于提示用户不支持相关操作 小结 使用外部 javascript 文件时，必须将 src 属性设置为包含文件的 URL 对于不推迟执行的脚本，通常会把 &lt;script&gt; 元素放到页面尾部，介于主内容尾部和&lt;/body&gt;标签之前 使用 defer 属性会把脚本推迟到文档渲染完毕之后执行，推迟的脚本总是按照他们被列出的次序执行 使用 async 属性异步加载脚本，让脚本加载完成立马执行 通过使用 &lt;noscript&gt; 元素指定浏览器不支持脚本时显示的内容","categories":[{"name":"红宝书","slug":"红宝书","permalink":"http://blog.curtaintan.club/categories/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"}],"tags":[{"name":"科普","slug":"科普","permalink":"http://blog.curtaintan.club/tags/%E7%A7%91%E6%99%AE/"}]},{"title":"9.28-每日一题-填充节点的next指针","slug":"9-28-每日一题","date":"2020-09-28T00:17:23.000Z","updated":"2020-09-28T00:45:17.033Z","comments":true,"path":"2020/09/28/9-28-每日一题/","link":"","permalink":"http://blog.curtaintan.club/2020/09/28/9-28-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"填充每个节点的下一个右侧节点指针 II","text":"填充每个节点的下一个右侧节点指针 II 117. 填充每个节点的下一个右侧节点指针 II给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next;} 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 解题思路 层序遍历，将节点一层一层的放到数组内 使用一个变量记录数组的长度 遍历这个长度的元素（一层的元素）， 将前一个元素的 next 指向下一个元素即可 实现123456789101112131415161718192021222324252627282930313233/** * // Definition for a Node. * function Node(val, left, right, next) &#123; * this.val = val === undefined ? null : val; * this.left = left === undefined ? null : left; * this.right = right === undefined ? null : right; * this.next = next === undefined ? null : next; * &#125;; *//** * @param &#123;Node&#125; root * @return &#123;Node&#125; */var connect = function(root) &#123; if( !root ) return root // 将首节点存入数组 let arr = [ root ] while( arr.length )&#123; // 按层遍历元素 let size = arr.length while( size-- )&#123; let item = arr.shift() if( size )&#123; item.next = arr[0] &#125; // 将子节点存入数组 item.left &amp;&amp; arr.push( item.left ) item.right &amp;&amp; arr.push( item.right ) &#125; &#125; return root&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.curtaintan.club/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"红宝书第一章--什么是js","slug":"红宝书第一章-什么是js","date":"2020-09-27T06:41:42.000Z","updated":"2020-09-27T08:50:00.671Z","comments":true,"path":"2020/09/27/红宝书第一章-什么是js/","link":"","permalink":"http://blog.curtaintan.club/2020/09/27/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AFjs/","excerpt":"","text":"js 历史回顾 问世缘由 1995年，javascript 问世。在此之前，要验证某个必填字段是否已填写，或某个输入值是否有效，需要与服务端进行一次往返通信，js 的用途就是代替服务端语言处理输入验证。 ECMAScript 与 javascript 的关系 1995 年 Brandan Eich 花了 10 天写出 javascript，并把它内置到网景浏览器2中，让 web 大受欢迎，此时，微软决定向 IE 投入更多资源，网景浏览器3发布不久，微软发布了 IE3，其中包含了自己名为 JScript 的 javascript 实现。微软的 javascript 实现意味着出现了两个版本的 javascript：网景的 javascript 和 微软的 JScript，1997 年，javascript1.1 作为题提案被提交给欧洲计算机制造商协会（Ecma），第 39 技术委员会承担了“标准化一门通用、跨平台、厂商中立的脚本语言的语法和语义”的任务，此后，各家浏览器均以 ECMAScript 作为自己 JavaScript 实现的一句，虽然具体实现各不相同 JavaScript 的实现虽然 JavaScript 和 ECMAScript 基本上是同义词，但是 js 不限于 ECMAScript，完整的 JavaScript 包含以下三个部分： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） ECMAScript 概述ECMAScript 作为一门语言的基准定义，目的是在它之上再构建更稳定的脚本语言 web 浏览器只是 ECMAScript 实现的一种宿主环境，宿主环境提供 ECMAScript 的基准实现和自身交互必须的扩展。扩展（比如 DOM 和 BOM）使用 ECMAScript 核心类型和语法，提供特定环境的额外功能 ECMAScript 版本概述 ES1：本质上与网景的JavaScript1.1相同，删除所有浏览器特定的代码 ES2：只做了一些编校工作 ES3：第一次对标准进行更新，新增字符串处理、错误定义和数值输出，添加了正则、新的控制语句、try/catch的支持 ES4：进行彻底修订，包括强类型变量、新语句和数据结构、真正的类和经典的继承，以及操作数据的新手段，为了避免改动太大，又制定了 ES3.1 ES5：ES3.1 变成了 ES5，于2009年12月发布，添加了序列化和解析 JSON 数据的 JSON 对象、继承、增强 ES 引擎解释和执行代码能力的严格模式 ES6：于2015年6月发布，这一版包含了有史以来最重要的一批增强特性，正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型 ES7：于2016年6月发布，新增少量api，如 Array.prototype.includes 和指数操作 ES8：完成于2017年6月，添加异步函数（async/await）、SharedArrayBuffer 等 ES9：发布于2018年6月，对原始对象添加方法，如正则和promise ES10：发布于2019年6月，对原始对象添加方法，如数组，并添加新的语法如：obj?.name?.first DOM 简介DOM 通过创建表示文档的树，让开发者可以随心所欲的控制网页中的内容和结构。使用 DOM API，可以轻松的删除、添加、替换、修改节点 BOM简介IE3 和 网景浏览器3 提供了浏览器对象模型 API，用于支持访问和操作浏览器的窗口，它是唯一一个没有相关标准的 JavaScript 实现。但是 HTML5 正在规范尽可能多的 BOM 特性 BOM的能力 弹出新浏览器窗口 移动、缩放和关闭浏览器窗口 navigator 对象，获取浏览器相关信息 location 对象，网页信息 screen 对象，屏幕信息 performance 对象，提供浏览器占用内存、导航行为等信息 cookie 其他自定义对象：XMLHttpRequest 和 ActiveXObject","categories":[{"name":"红宝书","slug":"红宝书","permalink":"http://blog.curtaintan.club/categories/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"}],"tags":[{"name":"科普","slug":"科普","permalink":"http://blog.curtaintan.club/tags/%E7%A7%91%E6%99%AE/"}]},{"title":"9.27-每日一题-二叉搜索树的最近公共祖先","slug":"9.27-每日一题","date":"2020-09-27T02:33:54.000Z","updated":"2020-09-27T06:27:02.312Z","comments":true,"path":"2020/09/27/9.27-每日一题/","link":"","permalink":"http://blog.curtaintan.club/2020/09/27/9.27-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"二叉搜索树的最近公共祖先","text":"二叉搜索树的最近公共祖先 235. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。 解题思路主要分为两步： 遍历一次二叉树，节点的值与两个目标值对比，对比成功，将路径存到两个数组内 以较短的数组作为标准，再比对两个数组，当两个节点的值不一样时，取数组的前一个节点返回，当遍历结束依然没有找到不相等的节点，返回短数组的尾节点 实现12345678910111213141516171819202122232425262728var lowestCommonAncestor = function(root, p, q) &#123; let dfs = ( node, path=[], target, target2, res=[], res2=[] ) =&gt; &#123; if( !node ) return path path = [ ...path, node ] if( target === node.val )&#123; res.push( ...path ) &#125; if( target2 === node.val )&#123; res2.push( ...path ) &#125; node.left &amp;&amp; dfs( node.left, [...path], target, target2, res, res2 ) node.right &amp;&amp; dfs( node.right, [...path], target, target2, res, res2 ) &#125; let res = [] let res2 = [] let ret = 0 // 找两个路径，放入数组 dfs( root, [], p.val, q.val, res, res2 ) // 进行对比，获取公共节点 let map = res.length &lt; res2.length ? res : res2 for( let i = 0; i &lt; map.length; i ++ )&#123; if( res[i].val !== res2[i].val )&#123; ret = res[ i-1 ] break &#125; &#125; return ret ? ret : map[ map.length - 1 ]&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.curtaintan.club/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"拖拽 DOM 碰撞检测","slug":"碰撞检测","date":"2020-05-07T01:56:28.000Z","updated":"2020-09-27T06:33:28.750Z","comments":true,"path":"2020/05/07/碰撞检测/","link":"","permalink":"http://blog.curtaintan.club/2020/05/07/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/","excerpt":"拖拽 DOM 碰撞检测","text":"拖拽 DOM 碰撞检测 分析：总共分为两步： 实现拖拽 碰撞检测 实现拖拽123456789101112131415161718192021let red = document.getElementsByClassName(\"red\")[0];red.addEventListener( \"mousedown\", (event) =&gt; &#123; // 事先记录下与元素左上角的偏移 let left = event.clientX - red.offsetLeft; let top = event.clientY - red.offsetTop; // 使用 addEventListener 方式添加事件监听，后期不好移除，故使用 onmousemove document.onmousemove = move.bind( this, left, top )&#125;)// 监听抬起事件document.addEventListener(\"mouseup\", () =&gt; &#123; document.onmousemove = \"\"&#125;)function move( left, top )&#123; let event = Array.from(arguments)[2]; // 先固定左上角的偏移量 - 偏移量，让元素跟随鼠标移动 red.style.left = event.clientX - left + \"px\"; red.style.top = event.clientY - top + \"px\";&#125; DOM 碰撞检测 当div1在div2的上边线(t2)以上的区域活动时，始终碰不上 当div1在div2的右边线(r2)以右的区域活动时,始终碰不上 当div1在div2的下边线(b2)以下的区域活动时,始终碰不上 当div1在div2的左边线(r2)以左的区域活动时,始终碰不上 除了以上四种情况，其他情况表示div1和div2碰上了，下面试完整测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"red\"&gt;&lt;/div&gt; &lt;div class=\"green\"&gt;&lt;/div&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; &#125; .red &#123; position: absolute; background-color: red; &#125; .green&#123; background-color: green; position: relative; top: 300px; left: 300px; &#125; .blue &#123; background-color: blue; &#125; &lt;/style&gt; &lt;script&gt; /** * 题目描述：在页面中写一个红色正方形，实现红色正方形拖拽到页面的任意位置，随鼠标一起动， * 页面中有另一个绿色正方形，当鼠标拖动红色正方形移动到绿色正方形时，绿色正方形变蓝色 * * 实现思路：1.实现随鼠标拖拽，2.拖拽的过程中判定是否碰撞 */ let red = document.getElementsByClassName(\"red\")[0]; let green = document.getElementsByClassName(\"green\")[0]; function move( left, top )&#123; let event = Array.from(arguments)[2]; // 先固定左上角的偏移量 - 偏移量，让元素跟随鼠标移动 red.style.left = event.clientX - left + \"px\"; red.style.top = event.clientY - top + \"px\"; // 获取目标元素四个边框的偏移 let greenleft = green.offsetLeft let greenTop = green.offsetTop let greenRight = green.offsetLeft + green.offsetWidth let greenbottom = green.offsetTop + green.offsetHeight // 拖拽元素的左边框偏移 大于 目标元素的右边框偏移 // 拖拽元素的顶部边框偏移 大于 目标元素的底部偏移 // 拖拽元素的右边框偏移 小于 目标元素的左边框偏移 // 拖拽元素的底部边框偏移 大于 目标元素的顶部边框偏移 // 其中一个成立，就代表没有碰撞，反之则表示已经碰撞 if( red.offsetLeft &gt; greenRight || red.offsetTop &gt; greenbottom|| red.offsetLeft + red.offsetWidth &lt; greenleft || red.offsetTop + red.offsetHeight &lt; greenTop)&#123; // 移除 css 类 green.classList.remove(\"blue\") &#125; else &#123; green.classList.add(\"blue\") &#125; &#125; red.addEventListener( \"mousedown\", (event) =&gt; &#123; // 事先记录下与元素左上角的偏移 let left = event.clientX - red.offsetLeft; let top = event.clientY - red.offsetTop; // 使用 addEventListener 方式添加事件监听，后期不好移除，故使用 onmousemove document.onmousemove = move.bind( this, left, top ) &#125;) // 监听抬起事件 document.addEventListener(\"mouseup\", () =&gt; &#123; document.onmousemove = \"\" &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考材料JS实现碰撞检测的方法分析","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"从 0 写一个简单的 React.js","slug":"从0写一个简单的React.js","date":"2020-02-22T17:11:26.000Z","updated":"2020-02-24T03:55:56.398Z","comments":true,"path":"2020/02/23/从0写一个简单的React.js/","link":"","permalink":"http://blog.curtaintan.club/2020/02/23/%E4%BB%8E0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84React.js/","excerpt":"从 0 写一个简单的 React.js","text":"从 0 写一个简单的 React.js 从 0 写一个简单的 React.js预览：点击直达源码地址：github文章地址：博客-从 0 写一个简单的 React.js 简单的实现如下功能： 将 jsx 使用 babel 转换成 vnode 组件是实现 生命周期的实现 diff 算法（这里没懂） 异步的setState 下面，我将总结一下整体的实现过程。 1. React.createElement() 的实现当我们在写 React 组件的时候，你是否有疑惑我们为什么要引入 React ，但是从来没用到呢？？ 其实我们用到了，因为我们用到了 React.createElement() 函数，此方法搭配 babel 插件将 jsx 转化成 vnode。 2. 将 jsx 使用 babel 转换成 vnode使用 babel 插件 @babel/plugin-transform-react-jsx 将 jsx 转换成 vnode 对象。 jsx123456const ele = ( &lt;div className=\"active\" title=\"tan\"&gt; hello,&lt;span&gt;react&lt;/span&gt; &lt;/div&gt;)console.log( ele ) 3. react-dom 将 vnode 转换成真正的 DOM (此时没有实现组件)react-dom 上有一个 render 函数，将获得到的 vnode 转换成真实的 dom，并把它挂在到dom节点（第二个参数）上。 根据 vnode 的结果可以得到，vnode 有两种情况： vnode 是直接渲染的内容（文字） vnode 是一个对象，代表一个 dom 元素（拥有 tag 属性） 此时，我们只需递归创建元素，最后依次挂载到父元素上即可： render函数12345678910111213141516171819202122232425262728function _render( vnode, container )&#123; // 第一种情况 if( vnode === undefined || vnode === null || typeof vnode === \"boolean\" ) return // 数字转换成 字符串 if( typeof vnode === \"number\" ) vnode = String( vnode ) // 如果 vnode 是字符串，直接渲染 if( typeof vnode === \"string\" )&#123; // 创建文本节点 return document.createTextNode( vnode ) &#125; // 第二种情况 // vnode 是虚拟 DOM 对象 const &#123; tag, attrs &#125; = vnode // 创建节点对象 const dom = document.createElement( tag ) // 绑定属性 if( attrs )&#123; Object.keys( attrs ).forEach( key =&gt; &#123; const value = attrs[key] setAttribute( dom, key, value ) &#125;) &#125; // 递归 渲染子节点 vnode.childrens &amp;&amp; vnode.childrens.forEach( child =&gt; render( child, dom ) ) // 返回节点 并挂载子节点 return container.appendChild( dom )&#125; 4. 实现函数组件和类组件实现思路：将函数组件封装成类组件，通过执行类组件的 render 函数得到 vnode 先看 vnode 结构： 组件1234567891011121314151617import React from \"../react/index.js\"const ele = ( &lt;div className=\"active\" title=\"tan\"&gt; hello,&lt;span&gt;react&lt;/span&gt; &lt;Home name=\"arr name\" /&gt; &lt;/div&gt;)// 函数组件function Home()&#123; return ( &lt;div className=\"active\" title=\"tan\"&gt; hello,&lt;span&gt;react&lt;/span&gt; &#123;/* &lt;Tan tan=\"我是传进来的参数\" /&gt; */&#125; &lt;/div&gt; )&#125;console.log( ele ) 可见，&lt;Home /&gt; 被转换成了一个函数，此时，在 render 函数中，我们要多一个判断，并且我们将函数组件封装成类组件，方便统一管理、注入生命周期等，执行过程： 判定是函数，调用 createComponent() 函数 使用 createComponent() 函数，将函数封装成类组件，返回类实例 使用 setComponentProps() 函数，设置组件的 props 调用 renderComponent() 函数，获取 vnode 使用 vnode 生成 dom 并返回渲染 实现代码请参考：react-dom/index.js 5. 实现生命周期在上述执行的过程中，插入生命周期。 实现代码请参考：react-dom/index.js 6. 实现 diff 算法实质：与 dom 节点的 attribute 进行对比，替换数据已经变化的 DOM 节点，是 DOM 节点 实现思路：获取当前 dom 下一层的子节点，分出 vnode 下有 key 属性的节点（这里没懂）（ diffChildren 函数），遍历虚拟节点，对比是否改变，移除原组件，并在原位置插入新 dom（使用兄弟组件实现插入到原位置） 实现代码请参考：react-dom/index.js，react-dom/diff.js 7. 实现异步 setState异步 setState 可以优化整体的性能，避免不必要的渲染。 实质：使用 Object.assign() 合并多次 setState 的结果，只返回最终的结果。 实现思路：使用两个队列，一个保存 setState， 一个保存当前组件，一个组件一个组件的完成 setState，当完成 setState 后，执行 renderComponent() 函数，渲染组件 8. 总结跟着教程从0撸一个丐版React.js一步一步搭建而成，虽有不懂，但是收获良多。 首先，感谢视频的分享，让我有机会一步一步的学习并实践。 通过一步一步的实际操作，对 react 整体的执行流程有了一定的认识， 加油！ 2020.2.23 1.03","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"javascript之DOM事件","slug":"javascript之DOM事件","date":"2020-02-22T06:34:43.000Z","updated":"2020-02-24T03:56:07.771Z","comments":true,"path":"2020/02/22/javascript之DOM事件/","link":"","permalink":"http://blog.curtaintan.club/2020/02/22/javascript%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6/","excerpt":"本文主要介绍 DOM 事件级别、DOM 事件模型、事件流、Event 对象常见的应用和自定义 DOM 事件。","text":"本文主要介绍 DOM 事件级别、DOM 事件模型、事件流、Event 对象常见的应用和自定义 DOM 事件。 1. DOM 事件级别DOM 事件分为3个级别：DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理。 1.1 DOM 0级事件el.onclick=function(){} DOM 0级事件1234var btn = document.getElementById('btn'); btn.onclick = function()&#123; alert(this.innerHTML); &#125; 为元素的一种事件绑定一个方法，这些方法都在冒泡阶段执行。 1.2 DOM 2级事件el.addEventListener(event-name, callback, useCapture) event-name: 事件名称，可以是标准的DOM事件 callback: 回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象 event useCapture: 默认是false，代表事件句柄在冒泡阶段执行 DOM 2级事件123456789var btn = document.getElementById('btn');btn.addEventListener(\"click\", test, false);function test(e)&#123; e = e || window.event; alert((e.target || e.srcElement).innerHTML); btn.removeEventListener(\"click\", test)&#125;//IE9-:attachEvent()与detachEvent()。//IE9+/chrom/FF:addEventListener()和removeEventListener() IE9以下的IE浏览器不支持 addEventListener()和removeEventListener()，使用 attachEvent()与detachEvent() 代替，因为IE9以下是不支持事件捕获的，所以也没有第三个参数，第一个事件名称前要加on。 1.3 DOM 3级事件在DOM 2级事件的基础上添加了更多的事件类型。 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 动画事件，当css3 animation动画执行开始和结束时触发，如：webkitAnimationEnd mozAnimationEnd 同时DOM3级事件也允许使用者自定义一些事件。 说明： 动画事件中不同浏览器的AnimationEnd写法： 谷歌浏览器：webkitAnimationEnd 火狐浏览器：mozAnimationEnd IE系浏览器：MSAnimationEnd 欧朋浏览器：oanimationend 通用浏览器：animationend 2、DOM事件模型和事件流DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。 （1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段；（2）目标阶段：真正的目标节点正在处理事件的阶段；（3）冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。 DOM事件捕获的具体流程 捕获是从上到下，事件先从window对象，然后再到document（对象），然后是html标签（通过document.documentElement获取html标签），然后是body标签（通过document.body获取body标签），然后按照普通的html结构一层一层往下传，最后到达目标元素。 这一系列的事件，就构成了事件流.. 3、Event对象常见的应用3.1 阻止默认事件event. preventDefault() 调用此方法，将阻止默认事件的触发，例如：a 标签的跳转 阻止默认事件触发的方法： 阻止默认事件1234567891011121314151617181920// 1. 使用空的 js &lt;a href=\"javascript:;\"&gt;链接&lt;/a&gt;// 2. 返回 false&lt;a id=\"test\" href=\"http://www.cnblogs.com\"&gt;链接&lt;/a&gt;&lt;script&gt;test.onclick = function(e)&#123; e = e || window.event; return false;&#125;&lt;/script&gt;// 3. 使用 preventDefault&lt;a id=\"test\" href=\"http://www.cnblogs.com\"&gt;链接&lt;/a&gt;&lt;script&gt;test.onclick = function(e)&#123; e = e || window.event; e.preventDefault();&#125;&lt;/script&gt; 3.2 阻止事件冒泡event.stopPropagation() 调用此方法，事件将停止冒泡。 3.3 停止事件传播event.stopImmediatePropagation() 调用此方法，将阻止此方法后面的方法执行。例如：一个事件绑定多个方法，方法依次调用，调用此方法后面的方法将不会执行，且阻止事件冒泡。 停止事件传播 stopImmediatePropagation12345678910111213141516171819202122var btn = document.querySelector(\".btn\")// 第一个事件btn.addEventListener(\"click\", function( e )&#123; console.log( \"我是第一个注册的事件\" )&#125;)// 注册第二个事件btn.addEventListener(\"click\", function( e )&#123; console.log( \"我是第二个注册的事件，我要调用 event.stopImmediatePropagation()方法\" ) e.stopImmediatePropagation()&#125;)// 注册第三个事件btn.addEventListener(\"click\", function( e )&#123; console.log( \"我是第三个注册的事件\" )&#125;)// document 捕获阶段事件document.addEventListener( \"click\", function()&#123; console.log( \"document---我在捕获阶段执行\" )&#125;, true )// document 冒泡阶段事件document.addEventListener( \"click\", function()&#123; console.log( \"document---我在冒泡阶段执行\" )&#125;) 运行结果 3.4 获取被点击的子元素event.target 将被点击的子元素绑定在此属性上，我们可以用此 event.target + data-** 自定义属性 实现事件代理。 12345678910111213141516&lt;ul&gt; &lt;li data-index=\"1\" &gt;1&lt;/li&gt; &lt;li data-index=\"2\" &gt;2&lt;/li&gt; &lt;li data-index=\"3\" &gt;3&lt;/li&gt; &lt;li data-index=\"4\" &gt;4&lt;/li&gt; &lt;li data-index=\"5\" &gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector(\"ul\") ul.addEventListener( \"click\", function(e)&#123; console.log( \"e.target:\" ) console.dir( e.target ) // 使用 dataset 获取绑定在元素上的标记属性（例如：元素下标） console.log( \"e.target.dataset\", e.target.dataset ) &#125;)&lt;/script&gt; 运行结果： 3.5 获取当前注册事件元素event.currentTarget 使用该属性，获取当前注册事件的元素。 4. 自定义事件可以使用两种方式自定义事件：new Event( eventType ) 和 new CustomEvent( eventType, params ) 4.1 new Event()语法：event = new Event(eventType, eventInit); 一般只传递第一个参数``eventType`，后面为 Event 对象上的参数 4.2 CustomEvent()语法：event = new CustomEvent(eventType, { detail：params }); eventType：事件名称params：自定义参数 4.3 合并案例自定义事件123456789101112131415161718192021var btn = document.querySelector(\".btn\")// Event 自定义事件var eve = new Event(\"go\")btn.addEventListener( \"go\", function( e )&#123; console.log( \"我是自定义事件：\", e )&#125;)// CustomEvent 事件构造函数function createCustomEvent( eventType = \"mock-event\", params = &#123;&#125; )&#123; return new CustomEvent( eventType, &#123; detail: params &#125; )&#125;// CustomEvent 事件var event = createCustomEvent( \"customGo\", &#123; name: \"tan\" &#125; )btn.addEventListener( \"customGo\", function( data )&#123; console.log( \"我是传参事件------\", data )&#125;)// 触发事件各个btn.addEventListener( \"click\", function()&#123; console.log( \"我的定义的 Click 事件\" ) btn.dispatchEvent( eve ) btn.dispatchEvent( event )&#125;) 运行结果： 5. 总结关于事件，需要记住 addEventListener() 函数的使用， e.preventDefault() 禁止默认事件 e.stopPropagation() 阻止冒泡 e.target.dataset 获取 dom 中 data-** 自定义属性 自定义时间需要了解，并且自定义事件类似观察者模式，需要手动触发事件。 6. 参考材料浪里行舟-DOM事件机制 DOM 事件详解 css3判断animation动画是否完成，以及在动画完成后执行事件 CSS浏览器前缀兼容写法 自定义事件——Event和CustomEvent MDN-CustomEvent","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---一次搞懂几种content-type的区别","slug":"思路清晰-一次搞懂几种content-type的区别","date":"2020-02-19T13:28:03.000Z","updated":"2020-02-19T14:08:06.724Z","comments":true,"path":"2020/02/19/思路清晰-一次搞懂几种content-type的区别/","link":"","permalink":"http://blog.curtaintan.club/2020/02/19/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82%E5%87%A0%E7%A7%8Dcontent-type%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"当使用 ajax 时，你是否还对 setRequestHeader( &quot;content-type&quot;, &quot;*&quot; ) 的几种值傻傻分不清？？ 不要慌，一次性记住他们…..","text":"当使用 ajax 时，你是否还对 setRequestHeader( &quot;content-type&quot;, &quot;*&quot; ) 的几种值傻傻分不清？？ 不要慌，一次性记住他们….. 1、Content-Type 的值类型 application/json：消息主体是序列化后的 JSON 字符串 application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式 multipart/form-data： 需要在表单中进行文件上传时，就需要使用该格式。常见的媒体格式是上传文件之时使用的 text/plain：数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符 2、application/json 和 application/x-www-form-urlencoded的区别2.1 application/json：作用： 告诉服务器请求的主题内容是json格式的字符串，服务器端会对json字符串进行解析。好处： 前端人员不需要关心数据结构的复杂度，只要是标准的 json 格式就能提交成功。 使用案例： 12345let xhr = new XMLHttpRequest()xhr.open( type, url, true )xhr.setRequestHeader( \"Content-Type\" , \"application/json\" )// 传入参数是 JSON 字符串xhr.send( JSON.stringify( data ) ) 2.1 application/x-www-form-urlencoded：作用：在请求发送过程中会对数据进行序列化处理，以键值对形式 key1=value1&amp;key2=value2 的方式发送到服务器，好处： 所有浏览器都支持缺点：需要处理传入的参数为 key1=value1&amp;key2=value2 格式 3、multipart/form-dataform 表单默认编码格式是：application/x-www-form-urlencoded 当表单需要发送文件或图片时，需要设置 enctype 为 multipart/form-data 案例： 12345&lt;form action=\"http://**/uploadImage\" method=\"post\" enctype=\"multipart/form-data\" &gt;&lt;input type=\"text\" name=\"name\" &gt;&lt;input type=\"file\" name=\"file\" &gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 4. 使用 xhr 发送文件和图片只需将数据和文件放入 FormData 即可. 案例： xhr发送文件1234567891011121314151617181920// 获取文件放入 FormDatavar formdata = new FormData()var elFile = document.getElementById( \"myfile\" )elFile.addEventListener( \"change\", () =&gt; &#123; formdata.append( \"file\", elFile.files[0] ) // 调用发送文件 sendFile()&#125;)// 创建 xhrvar xhr = new XMLHttpRequest()xhr.open( \"post\", \"http://***/uploadImage\" )xhr.onreadystatechange = function()&#123; if( xhr.status === 200 &amp;&amp; xhr.readyState === 4 )&#123; console.log( \"请求成功----\" ) console.log( xhr.response ) &#125;&#125;function sendFile()&#123; xhr.send( formdata )&#125; 5. 总结这四个属性都能设置在 from 表达上的 enctype 上， application/json 和 application/x-www-form-urlencoded 设置在 xhr 上，主要的区别是对上传参数的格式不同 multipart/form-data 设置在 form 表单上，用于上传文件和图片. 6. 参考材料关于Content-Type几种值的区别及用法 http请求content-type包括几种，区别是什么？ XMLHTTP中setRequestHeader方法和参数","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"ajax","slug":"ajax","permalink":"http://blog.curtaintan.club/tags/ajax/"}]},{"title":"封装一个ajax","slug":"封装一个ajax","date":"2020-02-19T09:06:53.000Z","updated":"2020-02-19T14:11:40.280Z","comments":true,"path":"2020/02/19/封装一个ajax/","link":"","permalink":"http://blog.curtaintan.club/2020/02/19/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAajax/","excerpt":"简单的封装一个 ajax： 自动处理参数 支持 get 和 post 支持取消操作","text":"简单的封装一个 ajax： 自动处理参数 支持 get 和 post 支持取消操作 1. 基于 XMLHttpRequest 封装XMLHttpRequest 相关信息请参考：MDN–XMLHttpRequest XMLHttpRequest 对象主要的属性： 1.1 原生 XHR 创建步骤总共分 5 步： 第一步：使用 new XMLHttpRequest() 创建 XHR 实例 第二步：使用 xhr.open() 创建一个请求，并初始化相关 http 请求信息 设置请求头 设置响应 http 状态变化的函数 调用 send 方法，发送 http 请求 整体结构： 12345678910function myAjax( obj )&#123; this.url = obj.url || \"\" this.type = obj.type || \"GET\" this.data = obj.data ||&#123;&#125; this.success = obj.success || null this.error = obj.error || null this.xhr = new XMLHttpRequest()&#125;myAjax.prototype.send = function()&#123;&#125;myAjax.prototype.abort = function()&#123;&#125; 完成结果： ajax ---- XMLHttpRequest1234567891011121314151617181920212223242526272829303132333435363738394041424344function myAjax( obj )&#123; this.url = obj.url || \"\" this.type = obj.type || \"GET\" this.data = obj.data ||&#123;&#125; this.success = obj.success || null this.error = obj.error || null this.xhr = new XMLHttpRequest()&#125;myAjax.prototype.send = function()&#123; // 将数据取出来 以 key=value 的形式保存到数组中，方便后续操作 let dataArr = [] for( let key in this.data )&#123; dataArr.push( key + \"=\" + this.data[key] ) &#125; if( this.type === \"GET\" || this.type === \"get\" )&#123; this.url = this.url + \"?\" + dataArr.join(\"&amp;\") // 删除尾部的 ?，当 data 为空的时候会多出来 ? this.xhr.open( this.type, this.url.replace(/\\?$/g, \"\"), true ) this.xhr.send() &#125; if( this.type === \"POST\" || this.type === \"post\" )&#123; this.xhr.open( this.type, this.url, true ) this.xhr.setRequestHeader( \"content-type\", \"application/x-www-form-urlencoded\" ) this.xhr.send( dataArr.join( \"&amp;\" ) ) &#125; // 使用箭头函数 将 this 指向当前对象 this.xhr.onreadystatechange = () =&gt; &#123; if( this.xhr.readyState === 4 &amp;&amp; // 200 是请求成功，304 重定向使用缓存资源 ( this.xhr.status === 200 || this.xhr.status === 304 ) )&#123; if( this.success &amp;&amp; this.success instanceof Function )&#123; var res = this.xhr.responseText if( typeof res === \"string\" )&#123; this.success( JSON.parse( res ) ) &#125; &#125; &#125; &#125;&#125;myAjax.prototype.abort = function()&#123; console.log( \"已经取消请求...\" ) this.xhr.abort()&#125; 2. 基于 fetch 封装若果你不知道 fetch 的使用，请参考 MDN-fetch 文档 MDN-fetch 使用相关 fetch 第二个参数选项： method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers 的对象或包含 ByteString 值的对象字面量。 body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者 include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 cache: 请求的 cache 模式: default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached 。 redirect: 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者 manual (手动处理重定向). 在Chrome中，Chrome 47之前的默认值是 follow，从 Chrome 47开始是 manual。 referrer: 一个 USVString 可以是 no-referrer、client或一个 URL。默认是 client。 referrerPolicy: 指定了HTTP头部referer字段的值。可能为以下值之一： no-referrer、 no-referrer-when-downgrade、 origin、 origin-when-cross-origin、 unsafe-url 。 integrity: 包括请求的 subresource integrity 值 signal: 用于取消请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function myFetch( obj )&#123; this.url = obj.url || \"\" this.type = obj.type || \"GET\" this.data = obj.data ||&#123;&#125; this.success = obj.success || null this.error = obj.error || null // 用于取消 fetch 请求 this.controller = new AbortController()&#125;myFetch.prototype.send = function()&#123; // 将数据取出来 以 key=value 的形式保存到数组中，方便后续操作 let dataArr = [] for( let key in this.data )&#123; dataArr.push( key + \"=\" + this.data[key] ) &#125; if( this.type === \"GET\" || this.type === \"get\" )&#123; this.url = this.url + \"?\" + dataArr.join(\"&amp;\") // 删除尾部的 ?，当 data 为空的时候会多出来 ? fetch( this.url.replace(/\\?$/g, \"\"), &#123; mode: \"cors\", method: \"GET\", signal: this.controller.signal &#125;).then( res =&gt; &#123; return res.json() &#125;).then( resObj =&gt; &#123; this.success( resObj ) &#125;) &#125; if( this.type === \"POST\" || this.type === \"post\" )&#123; fetch( this.url, &#123; mode: \"cors\", headers: &#123; \"Content-Type\" : \"application/x-www-form-urlencoded\" &#125;, body: dataArr.join(\"&amp;\"), method: \"POST\", signal: this.controller.signal &#125;).then( res =&gt; &#123; console.log( \"新鲜的数据：\" ,res ) return res.json() &#125;).then( resObj =&gt; &#123; this.success( resObj ) &#125;) &#125;&#125;myFetch.prototype.abort = function()&#123; console.log( \"取消请求--\" ) this.controller.abort()&#125; 3. 总结XMLHttp使用原生 XMLHttpRequest 创建 ajax 的步骤分 5 步，一定要记住， 使用 new XMLHttpRequest() 创建 xhr 实例 调用 open 方法初始化请求信息 设置 请求头 设置请求响应函数 调用 send 方法发送请求 4. 关于发送文件和图片发送文件和图片，需要搭配 FormData 直接将 FormData 作为参数发送即可。 案例: 1234567891011121314151617181920// 获取文件放入 FormDatavar formdata = new FormData()var elFile = document.getElementById( \"myfile\" )elFile.addEventListener( \"change\", () =&gt; &#123; formdata.append( \"file\", elFile.files[0] ) // 调用发送文件 sendFile()&#125;)// 创建 xhrvar xhr = new XMLHttpRequest()xhr.open( \"post\", \"http://***/uploadImage\" )xhr.onreadystatechange = function()&#123; if( xhr.status === 200 &amp;&amp; xhr.readyState === 4 )&#123; console.log( \"请求成功----\" ) console.log( xhr.response ) &#125;&#125;function sendFile()&#123; xhr.send( formdata )&#125; 5. 参考材料MDN–XMLHttpRequest MDN-fetch 文档 创建ajax过程 AJAX实现步骤,XMLHttpRequest对象的方法","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"ajax","slug":"ajax","permalink":"http://blog.curtaintan.club/tags/ajax/"}]},{"title":"页面布局之居中","slug":"页面布局之居中","date":"2020-02-18T06:42:19.000Z","updated":"2020-02-18T16:57:50.954Z","comments":true,"path":"2020/02/18/页面布局之居中/","link":"","permalink":"http://blog.curtaintan.club/2020/02/18/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B9%8B%E5%B1%85%E4%B8%AD/","excerpt":"水平居中 + 垂直居中 + 水平垂直居中","text":"水平居中 + 垂直居中 + 水平垂直居中 前期准备下文的所有 css 都是基于如下 html 结构： 123&lt;div class=\"parent\"&gt; &lt;div class=\"son\"&gt;son&lt;/div&gt;&lt;/div&gt; go–go–go—- 1. 水平居中1.1 使用 margin: 0 auto形成原理： 元素为块级元素 元素需要设置宽度 margin: 0 auto 123456789101112131415161718*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px;&#125;.son&#123; font-size: 38px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; margin: 0 auto;&#125; 运行结果： 1.2 使用 text-align:center形成原理： 子元素为行内元素（可以使用 display: inline-block 实现转换） 父元素设置 text-align:center 12345678910111213141516171819*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px; text-align: center;&#125;.son&#123; font-size: 38px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; display: inline-block;&#125; 1.3 使用 flex 布局形成原理： 父元素使用 flex 布局 父元素设置 justify-content: center 12345678910111213141516171819*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px; display: flex; justify-content: center;&#125;.son&#123; font-size: 38px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px;&#125; 1.4 使用 absolute + transform形成原理： 子元素绝对定位 position: absolute; 以父元素宽度为基准向右偏移 50%，设置 left: 50%; 基于自己的宽度向左偏移 50%，设置：transform: translate( -50%, 0 ); 存在问题： 因为使用了绝对定位，元素脱离文档流，父元素捕获不到子元素高度导致父元素高度塌陷… 如果子元素是动态高度，则只能通过 js 获取子元素高度，再设置父元素高度. 1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px;&#125;.son&#123; font-size: 38px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; position: absolute; left: 50%; transform: translate( -50%, 0 );&#125; 运行结果： 1.5 使用 absolute + 负margin形成原理： 子元素绝对定位 position: absolute; 以父元素宽度为基准向右偏移 50%，设置 left: 50%; 需要设置固定宽度 使用负 margin ，基于自己的宽度向左偏移 50% 宽度，margin-left: -0.5 * width; 1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px;&#125;.son&#123; font-size: 38px; line-height: 81px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; position: absolute; left: 50%; margin-left: -150px;&#125; 1.6 使用 absolute + width + margin形成原理： 子元素绝对定位 position: absolute; 设置子元素宽度 设置左右偏移为 0，left:0; right:0; 设置 margin 上下为 0，左右自适应占满整行. margin: 0 auto; 123456789101112131415161718192021*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px;&#125;.son&#123; font-size: 38px; line-height: 81px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; position: absolute; left: 0; right: 0; margin: 0 auto;&#125; 1.7 水平居中总结总共使用了 6 总方法，还有一种没有使用，就是使用 grid 实现， 三种使用绝对定位，但是绝对定位会导致父元素高度塌陷，需谨慎使用（其实也不算了…哈哈哈） 最推荐 flex 实现，兼容性优良，实现简单可靠. 2. 垂直居中2.1 行内元素的实现行内元素 –&gt; 使用 line-height: height 实现 实现原理： 父元素固定高度，并设置行高为高度值：line-height: height 子元素必须是行内元素（可以使用 display: inline-block 实现转换） 1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px; height: 800px; line-height: 800px;&#125;.son&#123; font-size: 50px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; display: inline-block;&#125; 2.2 使用 flex 布局实现原理： 父元素使用 flex 布局 父元素设置 align-items: center; 1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px; height: 600px; display: flex; align-items: center;&#125;.son&#123; font-size: 50px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px;&#125; 2.3 使用 position：absolute三种方式， absolute + transform absolute + -margin absolute + margin: auto 0 2.4 总结垂直居中还有表格、grid 和 vertical-align 可以实现。 推荐使用 flex 布局实现，简单易理解. 3. 水平垂直居中3.1 使用 absolute + margin实现原理： 父元素使用定位（除了 static 定位都行） 子元素使用绝对定位 上下左右偏移为 0 设置 margin: auto 占满整个父元素，居中 12345678910111213141516171819202122232425*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px; height: 600px; position: relative;&#125;.son&#123; font-size: 50px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 3.2 使用 absolute + transform 父元素使用定位（除了 static 定位都行） 子元素使用绝对定位 上左各偏移基于父元素的 50% 使用 transform 再拉回多的偏移 transform: translate( -50%, -50% ); 1234567891011121314151617181920212223*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: #ccc; padding: 20px; height: 600px; position: relative;&#125;.son&#123; font-size: 50px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate( -50%, -50% );&#125; 3.2 使用 absolute + -margin原理同上，需要知道子元素的高度， 负 margin 的值等于高度的一半 3.3 使用 flex 布局实现原理： 父元素使用 flex 布局 设置属性水平居中：justify-content: center; 设置属性垂直居中：align-items: center; 123456789101112131415161718192021*&#123; padding: 0; margin: 0;&#125;.parent&#123; background-color: rgb(117, 117, 117); padding: 20px; height: 600px; display: flex; justify-content: center; align-items: center;&#125;.son&#123; font-size: 50px; line-height: 100px; color: #ccc; background-color: aquamarine; text-align: center; width: 300px; height: 100px;&#125; 4. 总结个人最喜欢 flex 布局.推荐多使用 flex 布局. 加油！！ 5. 参考材料16种方法实现水平居中垂直居中 CSS实现文本，DIV垂直居中 一劳永逸的搞定 flex 布局","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.curtaintan.club/tags/css/"}]},{"title":"页面布局之三栏布局","slug":"页面布局之三栏布局","date":"2020-02-18T02:38:43.000Z","updated":"2020-02-18T06:37:18.484Z","comments":true,"path":"2020/02/18/页面布局之三栏布局/","link":"","permalink":"http://blog.curtaintan.club/2020/02/18/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B9%8B%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/","excerpt":"实现三栏布局….","text":"实现三栏布局…. 三栏布局的定义三栏布局，顾名思义就是两边固定，中间自适应。 开写….. 1. 使用 BFC实现原理：BFC 元素不会与浮动元素重叠。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; width: 180px; height: 200px; &#125; .left&#123; float: left; background-color: rgb(104, 104, 104); &#125; .right &#123; float: right; background-color: rgb(133, 133, 133); &#125; .main&#123; overflow: hidden; height: 200px; background-color: rgb(112, 112, 112); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;!-- 先浮动，再创建 BFC --&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 使用 float + margin 实现实现原理：使用 margin 替代浮动元素占据的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; width: 180px; height: 200px; &#125; .left&#123; float: left; background-color: rgb(104, 104, 104); &#125; .right &#123; float: right; background-color: rgb(133, 133, 133); &#125; .main&#123; /* 修改此行代码即可 */ margin: 0px 190px; height: 200px; background-color: rgb(112, 112, 112); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3. flex 实现实现原理：父元素使用 flex ，子元素定义 flex: 1 或 flex: auto 会自动填充宽度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; width: 180px; height: 200px; &#125; .left&#123; background-color: rgb(104, 104, 104); &#125; .right &#123; background-color: rgb(133, 133, 133); &#125; .main&#123; flex: 1; height: 200px; background-color: rgb(112, 112, 112); &#125; .warp &#123; display: flex; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. 使用 absolute + margin 实现实现原理：同 float + margin 一样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; width: 180px; height: 200px; &#125; .left&#123; background-color: rgb(104, 104, 104); position: absolute; top: 0; left: 0; &#125; .right &#123; background-color: rgb(133, 133, 133); position: absolute; top: 0; right: 0; &#125; .main&#123; height: 200px; margin: 0px 200px; background-color: rgb(112, 112, 112); &#125; .warp &#123; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. 使用 Table 布局实现实现原理：父元素展示为 table，子元素展示为 table-cell 注意：父元素宽度设置为 100% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; width: 180px; height: 200px; display: table-cell; &#125; .left&#123; background-color: rgb(104, 104, 104); &#125; .right &#123; background-color: rgb(133, 133, 133); &#125; .main&#123; display: table-cell; background-color: rgb(112, 112, 112); &#125; .warp &#123; display: table; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. 使用 inner-block + calc 实现实现原理：当展示为 inner-block 时需要指定宽度，此时就使用 calc 计算宽度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; width: 180px; height: 200px; display: inline-block; &#125; .left&#123; background-color: rgb(104, 104, 104); &#125; .right &#123; background-color: rgb(133, 133, 133); &#125; .main&#123; background-color: rgb(112, 112, 112); width: calc( 100% - 400px ); height: 200px; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7. 使用 grid 布局实现原理：grid 可以使用 1fr 划分等分和自适应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; height: 200px; &#125; .left&#123; background-color: rgb(104, 104, 104); &#125; .right &#123; background-color: rgb(133, 133, 133); &#125; .main&#123; background-color: rgb(112, 112, 112); height: 200px; &#125; .warp &#123; display: grid; grid-template-columns: 200px 1fr 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8. 圣杯布局（难使）实现原理：使用负 margin 使浮动元素重新定位，结合 position 定位元素…. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; font-size: 30px; color: rgb(224, 224, 224); text-align: center; line-height: 185px; &#125; h1&#123; text-align: center; line-height: 80px; color: rgb(38, 52, 99); font-size: 28px; &#125; .left, .right&#123; height: 200px; width: 180px; &#125; .left&#123; background-color: rgb(122, 122, 122); float: left; position: relative; margin-left: -100%; left: -200px; &#125; .right &#123; background-color: rgb(133, 133, 133); position: relative; float: left; margin-left: -200px; right: -220px; &#125; .main&#123; background-color: rgb(112, 112, 112); height: 200px; width: 100%; float: left; &#125; .warp &#123; margin: 0px 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;三栏布局&lt;/h1&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结最后还有一个双飞翼布局实现，但是代码布局写起来不直观，且 css 搭配复杂，不推荐…… 需要知道 margin 为负值时的结果.. 总的来说，还是不难的…. 参考材料面试官：请实现三栏布局，尽可能多的方式 详解 CSS 七种三栏布局技巧 margin为负值产生的影响和常见布局应用 margin负值的作用","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.curtaintan.club/tags/css/"}]},{"title":"css之BFC","slug":"css之BFC","date":"2020-02-17T07:10:19.000Z","updated":"2020-02-17T13:30:03.739Z","comments":true,"path":"2020/02/17/css之BFC/","link":"","permalink":"http://blog.curtaintan.club/2020/02/17/css%E4%B9%8BBFC/","excerpt":"从 BFC 解决的问题看待 BFC…..","text":"从 BFC 解决的问题看待 BFC….. 1. BFC是什么？查阅了一些资料，觉得这个解释很合理： Block fomatting context = block-level box + Formatting Context BFC 定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 2. BFC的作用 解决 margin 重叠问题（父子重叠、兄弟重叠） 和浮动元素产生边界 解决浮动元素的父元素高度塌陷 总的来说，就是 BFC 布局规则的作用…. 3. BFC布局规则： 内部的 Box 会在垂直方向，一个接一个地放置。 Box垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。（这说明BFC中子元素不会超出他的包含块，而 position 为 absolute 的元素可以超出他的包含块边界） BFC的区域不会与 float box 重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素也参与计算 4. 哪些元素会生成BFC? 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 5. BFC 的使用场景对应布局规则5.1 清除 margin 重叠由布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 margin 重叠示例 123456789101112131415161718192021222324&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box1, .box2 &#123; font-size: 30px; text-align: center; color: #ccc; padding: 20px; height: 100px; width: 300px; border: 10px solid #ccc; background-color: aquamarine; &#125; .box1 &#123; margin: 50px; &#125; .box2 &#123; margin: 20px; &#125;&lt;/style&gt;&lt;div class=\"box1\"&gt;box1&lt;/div&gt;&lt;div class=\"box2\"&gt;box2&lt;/div&gt; 运行效果 形成 BFC 解决重叠 在 box2 外包一个 wrap 元素，并形成 BFC。 1234567891011121314151617181920212223242526272829&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box1, .box2 &#123; font-size: 30px; text-align: center; color: #ccc; padding: 20px; height: 100px; width: 300px; border: 10px solid #ccc; background-color: aquamarine; &#125; .box1 &#123; margin: 50px; &#125; .box2 &#123; margin: 20px; &#125; .warp &#123; overflow: hidden; &#125;&lt;/style&gt;&lt;div class=\"box1\"&gt;box1&lt;/div&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"box2\"&gt;box2&lt;/div&gt;&lt;/div&gt; 运行结果 5.2 和浮动元素产生边界由布局规则第四条： BFC的区域不会与float box重叠。 情况示例 1234567891011121314151617181920212223242526&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .warp &#123; background-color: red; &#125; .float&#123; float: left; width: 40px; height: 40px; background-color: #ccc; &#125;&lt;/style&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt; &lt;div class=\"text-box\"&gt; 我是一些文字，我有很多的文字------------------------------- 我是一些文字，我有很多的文字------------------------------- 我是一些文字，我有很多的文字------------------------------- 我是一些文字，我有很多的文字------------------------------- --------------------------------------------------------- ----------- &lt;/div&gt;&lt;/div&gt; 运行结果 形成 BFC 和浮动元素产生边界 让 text-box 形成 BFC，使他浮动元素产生边界。 123456789101112131415161718192021222324252627282930&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .warp &#123; background-color: red; &#125; .float&#123; float: left; width: 40px; height: 40px; background-color: #ccc; &#125; .text-box&#123; overflow: auto; background-color: paleturquoise; &#125;&lt;/style&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt; &lt;div class=\"text-box\"&gt; 我是一些文字，我有很多的文字------------------------------- 我是一些文字，我有很多的文字------------------------------- 我是一些文字，我有很多的文字------------------------------- 我是一些文字，我有很多的文字------------------------------- --------------------------------------------------------- ----------- &lt;/div&gt;&lt;/div&gt; 运行结果 5.3 解决浮动元素的父元素高度塌陷由布局规则第六条： 计算 BFC 的高度时，浮动元素也参与计算 高度塌陷的情况： 123456789101112131415161718&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .warp &#123; background-color: red; &#125; .float&#123; float: left; width: 40px; height: 40px; background-color: #ccc; &#125;&lt;/style&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt; 运行结果 父元素形成 BFC 解决高度塌陷 12345678910111213141516171819&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .warp &#123; background-color: red; overflow: auto; &#125; .float&#123; float: left; width: 40px; height: 40px; background-color: #ccc; &#125;&lt;/style&gt;&lt;div class=\"warp\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt; 运行结果 6. 参考材料CSS什么是BFC？ 史上最全面、最透彻的BFC原理剖析 MDN-块格式化上下文 实验代码父元素形成 BFC 解决高度塌陷123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .warp &#123; background-color: red; overflow: auto; &#125; .float&#123; float: left; width: 40px; height: 40px; background-color: #ccc; &#125; &lt;/style&gt; &lt;div class=\"warp\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.curtaintan.club/tags/css/"}]},{"title":"css之盒模型","slug":"css之盒模型","date":"2020-02-17T05:16:27.000Z","updated":"2020-02-17T12:10:23.765Z","comments":true,"path":"2020/02/17/css之盒模型/","link":"","permalink":"http://blog.curtaintan.club/2020/02/17/css%E4%B9%8B%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"盒子模型…","text":"盒子模型… 1. 简单盒模型我在查资料的时候，看到一篇文章很好的说明了两种模型的关系： 通常情况下，被更多人认知的盒模型就是简单盒模型，简单盒模型在早期IE时期有一种怪异模式下的解析方式，也就是现在的border-box，后来W3C制定的标准以后规定在标准解析模式下使用标准盒模型(content-box)。 你真的了解盒模型吗？rainey.space/2016/07/02/Ni_Zhen_De_Liao_Jie_He_Mo_Xing_Ma 文中有这样一个段子： IE：我觉得盒模型应该是这样的，blahblah。W3C：明显应该是这样的才对，blahblah。结果是 IE 在怪异模式下用了「不标准」的盒模型，标准模式下用了「标准」的盒模型。围观群众：听说 IE 的盒模型不标准。……多年过去……W3C：感觉还是 IE 的那个模型比较好。但我们已经回不去了……算了加个属性支持一下 IE 那种模式吧。box-sizing 这货就是用来擦屁股的，我从来没见过有人用 padding-box 的……作者：顾轶灵链接：https://www.zhihu.com/question/25509268/answer/30949718来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2. 测试代码 代码放在文末 运行结果： 3. box-sizing: content-box 4. box-sizing: border-box 5. 总结在浏览器中，box-sizing 默认是 content-box content-box（标准盒模型）width = 内容的宽度height = 内容的高度 border-box（怪异盒模型）width = border + padding + 内容的宽度height = border + padding + 内容的高度 6. 参考材料你真的了解盒模型吗？ 7. 测试代码12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .content-box, .border-box &#123; font-size: 30px; color: #ccc; display: flex; align-items: center; justify-content: center; padding: 20px; height: 200px; width: 300px; border: 10px solid #ccc; background-color: aquamarine; &#125; .content-box &#123; margin: 80px; &#125; .border-box &#123; margin: 30px; &#125; &lt;/style&gt; &lt;div class=\"content-box\"&gt;margin: 80px&lt;/div&gt; &lt;div class=\"border-box\"&gt;margin: 30px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.curtaintan.club/tags/css/"}]},{"title":"算法之排序","slug":"算法之排序","date":"2020-02-15T09:20:59.000Z","updated":"2020-02-17T04:34:31.763Z","comments":true,"path":"2020/02/15/算法之排序/","link":"","permalink":"http://blog.curtaintan.club/2020/02/15/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/","excerpt":"总结常用排序算法.","text":"总结常用排序算法. 前言学数据结构已经是大二上学期的事了， 写一下常用的排序算法。 1. 冒泡排序 1.1 编程思路使用两层循环， 外层循环：执行 i 次，每一次排好一个元素。 内层循环：每执行一次，就挑选出数组中第 i 个位置的元素，并将该元素放到 i 位置。 1.2 编程要点在内层循环，相邻元素依次比较，把最大或最小元素放到最后。 1.3 代码实现冒泡排序1234567891011121314151617181920212223242526let arr = [ 5, 3, 8, 0, 9, 6 ]/** * * @param &#123; array &#125; arr 数组 * @param &#123; boolean &#125; asc 是否升序 */function bobble( arr, asc = true )&#123; for( let i = 0; i &lt; arr.length; i ++ )&#123; for( let j = 0; j &lt; arr.length; j ++ )&#123; // 升序 if( asc )&#123; if( arr[j] &lt; arr[j + 1] )&#123; [ arr[j+1], arr[j] ] = [ arr[j], arr[j+1] ] &#125; // 降序 &#125; else &#123; if( arr[j+1] &lt; arr[j] )&#123; [ arr[j+1], arr[j] ] = [ arr[j], arr[j+1] ] &#125; &#125; &#125; console.log( `外层循环第$&#123; i &#125;次执行的结果：`,arr ) &#125; return arr&#125;console.log( bobble( arr, true ) ) 运行结果： 根据代码可知，代码有待优化。 1. 4 代码优化优化点： 可知，外层循环每执行一次，就有一个元素在尾部排好序，则在内部循环中，可以减少后面 i 次不必要的比较。 当外层循环执行到最后一次时，只有一个元素，则可以不必再比较，则外层循环可以减 1 冒泡排序优化12345678910111213141516171819function bobble( arr, asc = true )&#123; for( let i = 0; i &lt; arr.length - 1; i ++ )&#123; for( let j = 0; j &lt; arr.length - 1 - i; j ++ )&#123; // 升序 if( asc )&#123; if( arr[j] &lt; arr[j + 1] )&#123; [ arr[j+1], arr[j] ] = [ arr[j], arr[j+1] ] &#125; // 降序 &#125; else &#123; if( arr[j+1] &lt; arr[j] )&#123; [ arr[j+1], arr[j] ] = [ arr[j], arr[j+1] ] &#125; &#125; &#125; console.log( `外层循环第$&#123; i &#125;次执行的结果：`,arr ) &#125; return arr&#125; 运行结果： 2. 选择排序 2.1 编程思路从未排序的部分选择最大或最小的值，将其排在有序序列的前或后。 升序：选择未排序部分的最小值，与排序部分后第一个元素交换 降序：选择未排序部分的最大值，与排序部分后第一个元素交换 实现：使用两层循环 外层循环：执行 i - 1 次，将内层循环挑选出的元素放到已排序部分的尾部。 内层循环：挑选出未排序部分最小值或最大值的下标。 2.2 编程要点 将数组用外层循环分为两段 每次外层循环时，使用一个 flagIndex 标记来标记内层循环挑选出来的元素的下标 外层循环将挑选出来的元素放到排好序的末尾 2.3 代码实现选择排序123456789101112131415161718192021222324252627let arr = [ 5, 3, 8, 0, 9, 6 ]/** * * @param &#123; array &#125; arr 数组 * @param &#123; boolean &#125; asc 是否升序 */function selectSort( arr, asc = true )&#123; for( let i = 0; i &lt; arr.length - 1; i ++ )&#123; // 记住未排序部分的最小值或最大值的下标 let flagIndex = i for( let j = i; j &lt; arr.length; j ++ )&#123; if( asc )&#123; if( arr[flagIndex] &gt; arr[j] )&#123; flagIndex = j &#125; &#125; else &#123; if( arr[flagIndex] &lt; arr[j] )&#123; flagIndex = j &#125; &#125; &#125; [ arr[flagIndex], arr[i] ] = [ arr[i], arr[flagIndex] ] &#125; return arr&#125;console.log( selectSort( arr, false ) ) 3. 插入排序 3.1 编程思路将数组以外层循环次数为基准分成两段，数组前段：已经排好序；数组后端：未排序 将未排序部分的第一个元素插入到排好序的部分中。 实现思路：使用两层循环 外层循环：执行 i - 1 次，每一次将后面的一个元素排进前面部分。 内层循环：将未排序部分的第一个元素插入到排好序的部分中 3.2 编程要点内层循环：已排序部分的后一个元素向前单向冒泡 123456789101112131415let arr = [ 5, 3, 8, 0, 9, 6 ]function insetSort( arr )&#123; for( let i = 0; i &lt; arr.length - 1; i ++ )&#123; for( let j = i + 1; j &gt;= 0; j -- )&#123; // 单向冒泡 if( arr[j] &lt; arr[ j - 1 ] )&#123; [ arr[ j - 1 ], arr[j] ] = [ arr[j], arr[ j - 1 ] ] break &#125; &#125; &#125; return arr&#125;console.log( insetSort( arr ) ) 4. 快速排序 4.1 编程思路寻找一个中点，将原数组分为三部分 第一部分：元素的值都比中点的值小 第二部分：当前元素 第三部分：元素的值都比中点的值大 依次递归，当分出数组的长度小于等于 1 时，返回数组 最后把三部分合并到一起。 实现思路： 使用三个变量保存三部分的结果，最后合并到一起。 4.2 编程要点将原数组分成三部分保存下来，返回合并的值。 4.3 代码实现快速排序1234567891011121314151617let arr = [ 5, 3, 8, 0, 9, 6 ]function quick( arr )&#123; if( arr.length &lt;= 1 )&#123; return arr &#125; let pointIndex = Math.floor( arr.length / 2 ) let pointValue = arr.splice( pointIndex, 1 )[0] let lArr = [] let rArr = [] for( let i = 0; i &lt; arr.length; i ++ )&#123; arr[i] &gt; pointValue ? rArr.push( arr[i] ) : lArr.push( arr[i] ) &#125; return [ ...quick(lArr), pointValue, ...quick(rArr) ]&#125;console.log( quick( arr ) ) 5. 快速排序（原数组操作方式） 5.1 编程思路在原数组上操作，取一个中值，操作原素组，将原数组以该中值为基点分成两部分，记录下标，重复进行此操作，当开始的下标和结束的下标相等时结束递归，最后，整个数组就排序成功。 5.2 编程要点 将原数组以中值为基点分成三部分。 每次递归，传入正确的下标 获取中值下标函数的编写 获取中值下标函数 作用：将数组段以左起点为中点，将此段数组分成三段，返回中值的下标。 思路： 取出起点的值作为中点 使用变量 j 为起始值的下标 使用一个循环，循环将此段数组分为三段（满足条件–&gt;交换位置–&gt;j++） 返回中值下标 j 5.3 代码实现快速排序（操作原数组方式）12345678910111213141516171819202122232425262728293031let arr = [ 5, 3, 8, 0, 9, 6 ];/** * 函数的作用：获取中值下标 * 以该段数组尾部的值作为基准，将数组分为两半，返回基准值的下标 * @param &#123; Array &#125; arr 原素组 * @param &#123; number &#125; start 操作开始的地方 * @param &#123; number &#125; end 操作结束的地方 */function getCenterIndex( arr, start, end )&#123; let j = start let pValue = arr[end] for( let i = start; i &lt;= end; i ++ )&#123; if( arr[i] &lt;= pValue )&#123; [ arr[i], arr[j] ] = [ arr[j], arr[i] ] j ++ &#125; &#125; return j - 1&#125;function quickSort( arr, start = 0, end = arr.length -1 )&#123; if( end - start &lt; 1 ) return arr let centerIndex = getCenterIndex( arr, start, end ) // 将左右两边依次排序 quickSort( arr, start, centerIndex - 1 ) quickSort( arr, centerIndex + 1, end ) return arr&#125;console.log( quickSort( arr ) ) 6. 归并排序 6.1 编程思路 使用递归将数组递归拆分直至只有一个元素 将数组依次合并 6.2 编程要点使用两个函数： 分函数：将数组进行拆分，直到只有一个元素为止 合函数：使用队列的思想，将两个两个的数组合并成一个数组 6.3 代码实现归并排序1234567891011121314151617181920212223242526272829303132let arr = [ 5, 3, 8, 0, 9, 6 ];// 归并排序function mergeSort( arr )&#123; if( arr.length &lt; 2 )&#123; return arr &#125; let middle = Math.floor( arr.length / 2 ) let left = arr.slice( 0, middle ) let right = arr.slice( middle ) // 先分再和 return merge( mergeSort( left ), mergeSort( right ) )&#125;// 将分开的数组合并function merge( l, r )&#123; let res = [] // 依次用第一个元素对比 小的元素放到 while( l.length &amp;&amp; r.length )&#123; if( l[0] &lt;= r[0] )&#123; res.push( l.shift() ) &#125; else &#123; res.push( r.shift() ) &#125; &#125; // 将剩下的元素放到 res 中 while( l.length ) res.push( l.shift() ) while( r.length ) res.push( r.shift() ) return res&#125;console.log( mergeSort( arr ) ) 7. 未完待续……7.1 桶排序7.2 计数排序7.3 希尔排序8. 参考材料JavaScript 数据结构与算法之美 - 归并排序、快速排序、希尔排序、堆排序 手写算法并记住它：快速排序（最易理解版） 手写算法并记住它：快速排序（5行代码简单版） 手写算法并记住它：插入排序 手写算法并记住它：选择排序","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://blog.curtaintan.club/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"思路清晰--前端性能优化","slug":"思路清晰-前端性能优化","date":"2020-02-14T01:25:00.000Z","updated":"2020-02-14T02:18:57.932Z","comments":true,"path":"2020/02/14/思路清晰-前端性能优化/","link":"","permalink":"http://blog.curtaintan.club/2020/02/14/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"1. 原则 多使用内存、缓存或其他方法来存储 减少 cpu 计算，减少 http 网络请求 2. 从哪里入手 加载页面和静态资源 页面渲染 2.1 加载资源优化 静态资源的压缩和合并 静态资源缓存 使用 CDN 让资源加载更快 使用 SSR 后端渲染，数据直接输出到 HTML 中 2.2 渲染优化 CSS 放前面，JS 放后面 懒加载（图片懒加载、下拉加载更多） 减少 DOM 查询，对 DOM 查询做缓存 减少 DOM 操作，多个操作尽量合并在一起执行（例如：插入列表） 使用事件节流与防抖 尽早执行操作（ 如：DOMContentLoaded ） 3. 总结简略的概述了一下前端性能的优化。 4. 资源推荐框架打包优化 🚀 记一次前端性能优化 前端性能优化最佳实践","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://blog.curtaintan.club/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"mobx与mobx-react实现todoList","slug":"mobx与mobx-react实现todoList","date":"2020-02-11T09:09:51.000Z","updated":"2020-02-15T09:35:29.527Z","comments":true,"path":"2020/02/11/mobx与mobx-react实现todoList/","link":"","permalink":"http://blog.curtaintan.club/2020/02/11/mobx%E4%B8%8Emobx-react%E5%AE%9E%E7%8E%B0todoList/","excerpt":"使用 mobx 结合 react 搭建的小 demo….","text":"使用 mobx 结合 react 搭建的小 demo…. 先看效果图： 预览地址：TodoListgithub 地址：mobx-react — todoList 1. 前言本文主要介绍 mobx-react 与 mobx 的使用，最后完成 todolist。 此 demo 全部用 class 组件搭建完成，如需使用 hooks ，请参考mobx与react-hooks 2. 环境准备需要在mobx—简明学习的基础上。 安装 react一套： yarn add react react-dom prop-types 安装 babel-react相关插件 yarn add @babel/preset-react 安装 mobx-react yarn add mobx-react 配置 webpack.config.js 文件 配置完成，开始编写文件。 3. mobx-react 说明：看 mobx-react 官方文档 可知有如下 api： observer(componentClass) Observer —- Observer是一个React组件，它将观察者应用于组件中的匿名区域。 useLocalStore hook useAsObservableSource hook Server Side Rendering with useStaticRendering（服务端） PropTypes Provider and inject disposeOnUnmount(componentInstance, propertyKey | function | function[]) 可见，有两种 api，一种是针对 componentClass 的，一种是针对 hooks 的。 我们使用 componentClass，所以主要用到： observer(componentClass) 使类重新render PropTypes 判定proptype Provider and inject 提供 store 和 注入对应props 具体的使用，请阅读 官方文档 ， 官方文档写得蛮详细的。 4. 开始编写文件结构： 4.1 store.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; observable, action, computed, observe &#125; from \"mobx\"class Todo &#123; id = Math.random() @observable title = \"\" @observable finished = false constructor( title )&#123; this.title = title &#125; @action.bound toggle()&#123; this.finished = !this.finished &#125;&#125;class Store &#123; @observable todos = [] disposers = [] @action.bound createTodo( title )&#123; this.todos.unshift( new Todo( title ) ) &#125; @computed get left()&#123; return this.todos.filter( todo =&gt; &#123; return !todo.finished &#125;).length &#125; @action.bound removeTodo( todo )&#123; this.todos.remove( todo ) &#125; constructor()&#123; observe( this.todos, change =&gt; &#123; this.disposers.forEach( disposer =&gt; disposer() ) this.disposers = [] for( let todo of change.object )&#123; var disposer = observe( todo, change =&gt; &#123; console.log( change ) &#125;) this.disposers.push( disposer ) &#125; &#125;) &#125;&#125;const store = new Store()const ss = &#123; store&#125;export default ss 4.2 index.jsx1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from \"react\"import ReactDOM from \"react-dom\"import &#123; observer, Provider &#125; from \"mobx-react\"import &#123; trace &#125; from \"mobx\"import TodoHeader from \"./conponent/TodoHeader.jsx\"import TodoView from \"./conponent/TodoView.jsx\"import TodoFooter from \"./conponent/TodoFooter.jsx\"import ss from \"./store.js\"@observerclass TodoList extends Component &#123; render()&#123; trace() return ( &lt;div className=\"todo-list\" &gt; &lt;TodoHeader /&gt; &lt;ul&gt; &lt;TodoView /&gt; &lt;/ul&gt; &lt;TodoFooter /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( ( &lt;Provider &#123; ...ss &#125; &gt; &lt;TodoList /&gt; &lt;/Provider&gt;), document.querySelector(\"#root\") ) 4.3 TodoFooter.jsx12345678910111213141516171819202122import React, &#123; Component &#125; from \"react\"import &#123; observer, inject &#125; from \"mobx-react\"import &#123; trace &#125; from \"mobx\"@inject( allStore =&gt; &#123; return &#123; left: allStore.store.left &#125;&#125;)@observerclass TodoFooter extends Component &#123; render()&#123; trace() return ( &lt;footer&gt; &#123; this.props.left &#125; items unfinished... &lt;/footer&gt; ) &#125;&#125;export default TodoFooter 4.4 TodoHeader.jsx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from \"react\"import &#123; observer, inject &#125; from \"mobx-react\"@inject( \"store\" )@observerclass TodoHeader extends Component &#123; state = &#123; inputValue : \"\" &#125; handleSubmit = ( e ) =&gt; &#123; e.preventDefault() let store = this.props.store var inputValue = this.state.inputValue store.createTodo( inputValue ) this.setState(&#123; inputValue: \"\" &#125;) &#125; handleChange = ( e ) =&gt; &#123; e.persist() var inputValue = e.target.value this.setState(&#123; inputValue: inputValue &#125;) &#125; render()&#123; return ( &lt;header&gt; &lt;form onSubmit=&#123; this.handleSubmit &#125; &gt; &lt;input type=\"text\" onChange=&#123; e =&gt; this.handleChange( e )&#125; value=&#123; this.state.inputValue &#125; className=\"input\" placeholder=\" what deeds to be finished? \" /&gt; &lt;/form&gt; &lt;/header&gt; ) &#125;&#125;export default TodoHeader 4.5 TodoView.jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component, Fragment &#125; from \"react\"import PropTypes from \"prop-types\"import &#123; observer, inject &#125; from \"mobx-react\"@inject( \"store\" )@observerclass TodoView extends Component &#123; render()&#123; const store = this.props.store const &#123; todos &#125; = store return todos.map( todo =&gt; &#123; return ( &lt;li key=&#123; todo.id &#125; className=\"todo-item\"&gt; &lt;TodoItem todo=&#123; todo &#125; /&gt; &lt;span className=\"delete\" onClick=&#123; e =&gt; store.removeTodo( todo ) &#125; &gt;X&lt;/span&gt; &lt;/li&gt; ) &#125;) &#125;&#125;@observerclass TodoItem extends Component&#123; static propTypes = &#123; todo: PropTypes.shape(&#123; id: PropTypes.number.isRequired, title: PropTypes.string.isRequired, finished: PropTypes.bool.isRequired &#125;).isRequired &#125; handleClick = () =&gt; &#123; this.props.todo.toggle() &#125; render()&#123; const todo = this.props.todo return ( &lt;Fragment&gt; &lt;input type=\"checkbox\" className=\"toggle\" checked=&#123; todo.finished &#125; onChange=&#123; this.handleClick &#125; /&gt; &lt;span className=&#123;[\"title\", todo.finished &amp;&amp; \"finished\"].join(\" \")&#125; &gt; &#123; todo.title &#125; &lt;/span&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoView 4.6 html 文件内添加 css 样式123456789101112131415161718192021222324252627282930.input &#123; padding: 15px; border: 1px solid #ccc; font-size: 24px; width: 400px;&#125;.todo-item &#123; display: flex; align-items: center; height: 40px; border-bottom: 1px solid #ccc;&#125;.todo-item .toggle &#123; margin-right: 20px;&#125;.todo-item .title &#123; font-size: 24px; color: #000;&#125;.todo-item .title.finished &#123; text-decoration: line-through; color: #ccc;&#125;.todo-item .delete &#123; margin-left: 20px; cursor: pointer;&#125;footer&#123; font-size: 22px;&#125; 5. 性能优化提升性能三大法则： 细粒度拆分视图组件 使用专用组件处理列表 尽可能晚的结构可观察数据 上面三大法则，你在上面的代码中，能找到在哪里吗？？ 还有其他的优化点： 尽早的绑定函数（不要传匿名函数和箭头函数） 不要使用数组的索引作为 key 使用小组件 详情参考：优化 React 组件渲染 6. 总结当得到一些点拨过后，再去阅读官方文档，就会收获更多， 当然也要学会阅读官方文档，官方文档写得都蛮好的。 写下这篇文章，也算是总结了一下 mobx 相关的知识. 加油，写下这篇文章希望对你有帮助，与君共勉！！ 有时间，我会把 class 版本改成 hook 版本的。 7. 参考材料茵风泳月–mobx入门基础教程 mobx—-官网 mobx-react 文档 mobx-react 官方文档","categories":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/categories/mobx/"}],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/tags/mobx/"}]},{"title":"mobx--简明学习","slug":"mobx-简明学习","date":"2020-02-11T06:19:41.000Z","updated":"2020-02-12T02:07:02.181Z","comments":true,"path":"2020/02/11/mobx-简明学习/","link":"","permalink":"http://blog.curtaintan.club/2020/02/11/mobx-%E7%AE%80%E6%98%8E%E5%AD%A6%E4%B9%A0/","excerpt":"mobx 简明学习与实践….","text":"mobx 简明学习与实践…. 前置环境准备：请参考：es6—Decorator,并使用 yarn add mobx 安装 mobx 模块。 1. 前言学习前，建议仔细阅读一遍 MobX 介绍 了解 mobx 运行机制。 先看 mobx 官网的文档目录： 可以看到，整个库，需要我们学习的就只有三个主要的点： observable 相关 —– 创建观察数据 对 observables 作出响应 —– 数据改变时的响应操作 改变 observables 还有一个工具函数。 2. observable 相关 —- 创建被观察数据创建可观察数据的方式有两种： 使用 observable 函数构建 使用 @observable 装饰类构建 2.1 使用 observable 函数构建observable 函数构建可观察的数据123456const value = observable(\"value\")const list = observable([1, 2, 4])const map = observable.map(&#123; key: \"value\"&#125;)// 使用 observable.box()const cityName = observable.box(\"tan\") 2.1 使用 @observable 装饰类构建12345678910class Store &#123; @observable num = 22 @observable str = \"string\" @observable bool = false @observable obj = &#123; name: \"tan\", age: 12 &#125; @observable array = []&#125; 3. 对 observables 作出响应有 4 个 api 处理响应： computed 和 @computed 函数内依赖的观察项改变时，自动执行，类似 vue 中的 computed autorun( fn, { options } ): 函数内的依赖项改变时，自动执行 when( fn, fn ): 第一个函数内依赖项改变时执行第一个函数，第一个函数返回 true 时，执行第二个函数 reaction( fn, fn ): 第一个函数返回一个数组，数组中值的改变时，执行第二个函数 observer 和 @observer 修饰 react 类，用于更新视图 代码： 代码放在文章尾部 运行结果： 4. action –改变– observables我们可以直接通过 store 来修改属性，但是每一次属性的改变，响应操作都会执行，当我们需要一次性执多个属性的改变的时候，响应操作就会执行多次，但是我们只需要执行一次就够了，那怎么解决呢？？此时 action 就出场了。 action 主要有： action( fn ): fn — 创建一个 action 函数 @action - fn : 修饰类方法，使其变成 action 方法 @action.bound : 修饰类方法，绑定 this runInAction(name?, thunk)： 直接运行 action 操作，搭配 @action 可执行异步 案例： 代码放在文章底部 测试结果： 5. 总结工具函数就自行看官方文档了。 对比着 mobx 的运行流程图： 我们就可以很轻易的理解各个 api 之间的关系了。 6. 参考材料mobx—-官网 推荐大家去观看此教程，非常好的教程。茵风泳月–mobx入门基础教程 7. 文中使用代码：测试相应的代码测试副作用12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; observable, computed, autorun, when, reaction &#125; from \"mobx\"class Store &#123; @observable num = 22 @observable str = \"string\" @observable bool = false @observable obj = &#123; name: \"tan\", age: 12 &#125; @computed get mixed()&#123; return this.obj.age + \"-----\" + this.str &#125;&#125;var store = new Store()// 测试 computedvar foo = computed( function()&#123; return store.str + \"/\" + store.obj.age&#125;)console.log( foo.get() )console.log( store.mixed )foo.observe( function( change )&#123; console.log( \"computed 值改变：\" ) console.log( \"修改值：\", change )&#125;)// 测试 autorun autorun( () =&gt; &#123; console.log( \"autorun运行：\" ) console.log( store.str + \"/\" + store.obj.age )&#125;)// 测试 wenwhen( ()=&gt; store.bool , ()=&gt; console.log( \"变成 true 了...\" ) )// 测试 reactionreaction( () =&gt; [ store.str, store.obj.age ], arr =&gt; console.log( \"reaction 运行：\",arr ) )console.log( \"开始测试：------- wen ------\" )store.bool = trueconsole.log( \"开始测试：------- 其他三个 ------\" )store.obj.age = 13 测试 action测试 action 123456789101112131415161718192021222324252627282930313233343536import &#123; observable, action, reaction &#125; from \"mobx\"class Store &#123; @observable num = 22 @observable str = \"string\" @observable bool = false @observable obj = &#123; name: \"tan\", age: 12 &#125; @action bar()&#123; this.str = \"修改值了--\" this.num = 89 &#125;&#125;var store = new Store()reaction( () =&gt; [ store.str, store.obj.age ], arr =&gt; console.log( \"reaction 运行：\",arr ) )// 不用 action 改变值console.log( \"不用 action 改变值：\" )store.obj.age = 11store.str = \"你好---\"// 使用 @actionconsole.log( \"使用 action 修饰器改变多个值\" )store.bar()// 使用 action 执行console.log( \"使用 action 修饰器改变多个值\" )action( () =&gt; &#123; store.str = \"ppppppp\" store.obj.age = 45&#125;)()","categories":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/categories/mobx/"}],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/tags/mobx/"}]},{"title":"es6---Decorator","slug":"es6-Decorator","date":"2020-02-10T08:17:56.000Z","updated":"2020-02-17T13:38:36.534Z","comments":true,"path":"2020/02/10/es6-Decorator/","link":"","permalink":"http://blog.curtaintan.club/2020/02/10/es6-Decorator/","excerpt":"搭建可使用 Decorator 的环境，并学习 Decorator 。","text":"搭建可使用 Decorator 的环境，并学习 Decorator 。 1. 环境搭建 安装插件： webpack ： 1yarn add webpack webpack-cli babel ： 1yarn add @babel/cli @babel/core @babel/preset-env babel-loader babel 装饰器相关插件： 1yarn add @babel/plugin-proposal-decorators babel-plugin-transform-class-properties webpack.config.js 配置 配置代码放在文章末尾。 配置 package.json 123\"scripts\": &#123; \"dev\": \"webpack\" &#125;, 环境配置完毕，运行 yarn dev 就可以将文件编译好。 新建一个html文件，引入编译好的 js 文件，环境配置基本完成。 目录结构： 2. 开始书写代码编写 bundle.js 2.1 类的装饰：代码设计： 运行结果： 2.2 类方法的修饰代码设计： 运行结果： 2.2 类属性的修饰代码设计： 运行结果： 注： 可以在 js 文件头部编写 &quot;use strict&quot;来使用严格模式， 使用严格模式后，当修改不可修改的属性时，就会打断操作并报错。 3. 总结装饰器不能用修饰函数，因为函数存在变量提升。 4. 参考材料茵风泳月–mobx入门基础教程 阮一峰–es6 基础入门 5. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 定义类修饰器function log( target )&#123; const desc = Object.getOwnPropertyDescriptors( target.prototype ) for( const key of Object.keys( desc ) )&#123; if( key === \"constuctor\" )&#123; continue &#125; const func = desc[key].value if( typeof func === \"function\" )&#123; Object.defineProperty( target.prototype, key, &#123; value( ...arg )&#123; console.log( \"加之前\", key ) const ret = func.apply( this, arg ) console.log( \"相加----结果：\", ret ) console.log( \"加之后\", key ) return ret &#125; &#125;) &#125; &#125;&#125;// 属性修饰器function readonly( target, key, desc )&#123; desc.writable = false&#125;// 方法修饰器function validate( target, key, desc )&#123; const func = desc.value desc.value = function( ...arg )&#123; for( let num of arg )&#123; if( typeof num !== \"number\" )&#123; throw new Error(`\"$&#123; num &#125; \" 不是一个数字..`) &#125; &#125; console.log( \"函数里面的装饰器-----函数的操作---\" ) return func.apply( this, [ 4, 7 ] ) &#125;&#125;@logclass Numberic &#123; @readonly PI = 3.1315926 // 修饰方法 add( ...nums )&#123; return nums.reduce( ( p, n ) =&gt; ( p + n ), 0 ) &#125;&#125;// 测试console.log( new Numberic().add( 1, 2 ) )var ss = new Numberic()console.log( \"修改数据前：\", ss )ss.PI = 99console.log( \"修改数据后：\", ss ) 5.1 环境配置代码：1234567891011121314151617181920212223242526272829303132333435const path = require(\"path\")const config = &#123; mode: \"development\", // 入口文件 entry: path.resolve( __dirname, \"./src/mobx.js\" ), // 打包输出文件 output: &#123; path: path.resolve( __dirname, \"mobx\" ), filename: \"main.js\" &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"@babel/preset-env\" ], // 配置 babel 插件 plugins: [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], \"transform-class-properties\" ] &#125; &#125; &#125; ] &#125;, // 配置 map 文件 devtool: \"inline-source-map\"&#125;module.exports = config","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式（五）---装饰器模式","slug":"设计模式（五）-装饰器模式","date":"2020-02-10T07:46:53.000Z","updated":"2020-02-10T08:14:24.701Z","comments":true,"path":"2020/02/10/设计模式（五）-装饰器模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"手写一个装饰器模式。","text":"手写一个装饰器模式。 1. 介绍装饰器模式的目的： 为对象添加新功能 不改变其原有的结构和功能 2. 代码演示1234567891011121314151617181920212223class Circle &#123; draw() &#123; console.log(\"画一个圆形\"); &#125;&#125;class Decorator &#123; constructor(circle)&#123; this.circle = circle; &#125; draw() &#123; this.circle.draw(); this.setRedBorder(this.circle); &#125; setBorder(circle) &#123; console.log(\"设置边框\") &#125;&#125;// 测试代码let circle = new Circle();let dec = new Decorator(circle);dec.setRedBorder(); 3. 总结装饰器小情景：手机又照相的功能，我们可以在手机摄像头前装饰一个放大镜，手机在具有照相的基础还有放大的功能。 本质：在执行真正的操作前后，可以进行其他的操作 4. 参考材料装饰者模式 JS设计模式-装饰器模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（四）---发布订阅模式","slug":"设计模式（四）-发布订阅模式","date":"2020-02-09T06:56:37.000Z","updated":"2020-02-09T13:40:31.851Z","comments":true,"path":"2020/02/09/设计模式（四）-发布订阅模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"我看了很多关于发布订阅模式与观察者模式的文章，有点朋友认为观察者模式就是发布订阅模式，根据我看了这么多的文章的总结，他们确实是不一样的。 在vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来。 今天就写一个发布订阅。","text":"我看了很多关于发布订阅模式与观察者模式的文章，有点朋友认为观察者模式就是发布订阅模式，根据我看了这么多的文章的总结，他们确实是不一样的。 在vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来。 今天就写一个发布订阅。 1. 情景模拟：当我们在注册虎扑的时候，软件会让我们选择我们感兴趣的板块，例如：唱、跳、rap、篮球….. 当我们选择自己喜欢的版块时，我们就订阅了相关板块的消息。 当此板块内有热门消息时，虎扑就会给我们推送此消息，他不会把其他板块的消息推送给我们。 2. 分析：我们可以抽象出三个对象，一个发布者，一个调度中心，一个订阅者 发布者：我就是在不同板块发送热门消息的 调度中心：存下所有板块，与板块对应的订阅者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：接收消息并给相关板块所有的订阅者发送消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：移除订阅者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：添加订阅者 订阅者：自己的属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：订阅消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：取消订阅消息 画出 UML 类图就是文章前的图片。 3. 代码实现 真实代码放在文章末尾。 结果： 4. 总结什么是发布订阅模式： 发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。 维基百科zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85 说说我的理解： 发布订阅模式可以理解成三个对象，一个是发布者，一个是订阅者，一个是调度中心。 为什么需要一个调度中心？因为订阅者的订阅是有一定要求的，而不是接收所有发布的消息， 所以调度中心就是将消息分别发送给订阅者。订阅者不会接收到没有订阅的消息。 观察者模式： 观察者只有两个对象，一个观察者、一个被观察者，被观察者只要作出变化（不论什么变化），所有的观察者都会接受到消息。 5. 参考材料发布订阅模式，在工作中它的能量超乎你的想象 谈谈观察者模式和发布订阅模式 EventBus—思考观察者模式与发布订阅者模式 JavaScript中发布/订阅模式的理解 6. 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 发布者 传入调度中心实例class Publisher &#123; constructor( dispatch )&#123; this.dispatch = dispatch &#125; publish()&#123; let arg = Array.from( arguments ) let event = arg.shift() this.dispatch.emit( event, arg ) &#125;&#125;// 调度中心class Dispatcher &#123; constructor()&#123; this.eventObj = &#123;&#125; &#125; on( event, fn )&#123; if( !this.eventObj[event] )&#123; this.eventObj[event] = [] &#125; this.eventObj[event].push( fn ) &#125; emit( type, arg )&#123; let funs = this.eventObj[type] if( !funs || funs.length === 0 )&#123; return &#125; funs.forEach( item =&gt; &#123; item.apply( this, arg ) &#125;); &#125; remove( type, fn )&#123; let fns = this.eventObj[ type ] if( !fns ) return if( !fn )&#123; delete this.eventObj[type] &#125; else &#123; this.eventObj[ type ] = fns.filter( item =&gt; item !== fn ) &#125; &#125;&#125;// 订阅者类 传入 dispatch 和 自己的属性class Subscriber &#123; constructor( dispatch, name )&#123; this.dispatch = dispatch this.name = name &#125; fn = ( msg ) =&gt; &#123; console.log( `我是$&#123; this.name &#125;:` ,\"收到订阅的消息：\", msg ) &#125; subscrib( type, fn )&#123; this.dispatch.on( type, fn, this ) &#125; removeSubscrib( type, fn )&#123; this.dispatch.remove( type, fn ) &#125;&#125;// 测试let dispatch = new Dispatcher()let pub = new Publisher( dispatch )let sub1 = new Subscriber( dispatch, \"sub1\" )let sub2 = new Subscriber( dispatch, \"sub2\" )// 订阅消息sub1.subscrib( \"篮球\", sub1.fn )sub2.subscrib( \"篮球\", sub2.fn )sub2.subscrib( \"足球\", sub2.fn )// 发布消息pub.publish( \"篮球\", \"乔丹去世了---\" )pub.publish( \"足球\", \"国足能进世界杯吗？？\" )// 取消订阅sub1.removeSubscrib( \"篮球\", sub1.fn )pub.publish( \"篮球\", \"这里有一些NBA相关的信息\" ) 通用代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let event = &#123; list: &#123;&#125;, on(key, fn) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, emit() &#123; let key = [].shift.call(arguments), fns = this.list[key]; if (!fns || fns.length === 0) &#123; return false; &#125; fns.forEach(fn =&gt; &#123; fn.apply(this, arguments); &#125;); &#125;, remove(key, fn) &#123; // 这回我们加入了取消订阅的方法 let fns = this.list[key]; // 如果缓存列表中没有函数，返回false if (!fns) return false; // 如果没有传对应函数的话 // 就会将key值对应缓存列表中的函数都清空掉 if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; // 遍历缓存列表，看看传入的fn与哪个函数相同 // 如果相同就直接从缓存列表中删掉即可 fns.forEach((cb, i) =&gt; &#123; if (cb === fn) &#123; fns.splice(i, 1); &#125; &#125;); &#125; &#125;&#125;;function cat() &#123; console.log('一起喵喵喵');&#125;function dog() &#123; console.log('一起旺旺旺');&#125;event.on('pet', data =&gt; &#123; console.log('接收数据'); console.log(data);&#125;);event.on('pet', cat);event.on('pet', dog);// 取消dog方法的订阅event.remove('pet', dog);// 发布event.emit('pet', ['二哈', '波斯猫']);/* 接收数据 [ '二哈', '波斯猫' ] 一起喵喵喵*/ 摘自： 发布订阅模式，在工作中它的能量超乎你的想象","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（三）--代理模式","slug":"设计模式（三）-代理模式","date":"2020-02-08T13:08:41.000Z","updated":"2020-02-09T14:46:30.384Z","comments":true,"path":"2020/02/08/设计模式（三）-代理模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"写一个代理模式.","text":"写一个代理模式. 1. 情景情景: 小明追女生 A 非代理模式: 小明 =花=&gt; 女生A 代理模式: 小明 =花=&gt; 让女生A的好友B帮忙 =花=&gt; 女生A 2. 代理模式的特点 代理对象和本体对象具有一致的接口, 对使用者友好 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。 考拉海购前端团队juejin.im/post/59df4f74f265da430f311909 3. 代码设计 4. es6 代理模式 —- Proxy目的：在操作前可以进行其他的操作（对数据加工等）。 代码设计 运行结果： 案例参考： ES6中的代理模式—–Proxy 阮一峰– es6 入门 4. 总结代理模式，总的来说，是在操作前，可以进行其他的操作。 5. 参考材料BasicSkill–代理模式 JavaScript设计模式 js –代理模式 6. 代码图片懒加载123456789101112131415161718192021222324252627// 真实的对象class RealImg &#123; constructor()&#123; this.imgNode = document.createElement(\"img\") document.body.appendChild( this.imgNode ) &#125; setSrc( src )&#123; this.imgNode.src = src &#125;&#125;// 代理对象class ProxyImg &#123; constructor()&#123; this.realImg = new RealImg() &#125; setSrc( src )&#123; this.realImg.setSrc(\"http://seopic.699pic.com/photo/40007/8839.jpg_wh1200.jpg\") let img = new Image() img.src = src img.onload = () =&gt; &#123; this.realImg.setSrc( src ) &#125; &#125;&#125;let proxyImg = new ProxyImg()proxyImg.setSrc( \"http://seopic.699pic.com/photo/40006/7735.jpg_wh1200.jpg\" )","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（二）--观察者模式","slug":"设计模式（二）-观察者模式","date":"2020-02-08T08:21:01.000Z","updated":"2020-02-08T09:33:31.663Z","comments":true,"path":"2020/02/08/设计模式（二）-观察者模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"写一个观察者模式。","text":"写一个观察者模式。 介绍意图： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 关键代码： 在抽象类里有一个 ArrayList&lt;\\Observer&gt; 存放观察者们。 实现观察者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 观察者模式 * state 状态 * observers &#123; Observer &#125; 保存所有的观察者 */class Subject&#123; constructor()&#123; this.state = 0 this.observers = [] &#125; getState()&#123; return this.state &#125; setState( state )&#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers()&#123; this.observers.forEach( observer =&gt; &#123; observer.update() &#125;) &#125; // 添加观察者 attach( observer )&#123; this.observers.push( observer ) &#125;&#125;// 观察者class Observer &#123; constructor( name, subject )&#123; this.name = name this.subject = subject this.subject.attach( this ) &#125; update()&#123; console.log( `$&#123; this.name &#125; -- update, state: $&#123; this.subject.getState() &#125;` ) &#125;&#125;// 测试let s = new Subject()let o1 = new Observer( \"o1\", s )let o2 = new Observer( \"o2\", s )s.setState( 11 )s.setState( 12 )console.log( s ) 测试结果： 总结：观察者模式的要点主要是将观察者放在被观察者里面，当状态变化后，就依次通知观察者。 参考超全的设计模式简介（45种）—观察者模式 JavaScript 中常见设计模式整理 谈谈观察者模式和发布订阅模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（一）--单例模式","slug":"设计模式（一）-单例模式","date":"2020-02-08T06:00:08.000Z","updated":"2020-02-08T08:07:23.641Z","comments":true,"path":"2020/02/08/设计模式（一）-单例模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"写一个单例模式。","text":"写一个单例模式。 定义确保一个类只有一个实例，使每次获取的实例都是同一个。 代码实现123456789101112131415161718192021222324252627282930class Store &#123; constructor( name )&#123; this.name = name &#125; getName()&#123; return this.name &#125; setName( data )&#123; this.name = data &#125;&#125;// 获取单例的方法 --- 使用闭包获取单例Store.getInstance = ( function()&#123; let instance return function( name )&#123; if( !instance )&#123; instance = new Store( name ) &#125; return instance &#125; &#125;)()let store1 = Store.getInstance( \"你好\" )let store2 = Store.getInstance( \"你好----\" )console.log( store1 )console.log( store2 )console.log( store1 === store2 ) 运行结果 总结单例模式运用非常广泛，只要在代码中涉及到只存在一个实例，就可以使用单例模式， vuex 和 redux 就是使用单例模式构建。 写一个单例模式的要点： 使用一个特定函数来获取单例， 此函数使用闭包来确保但会单例是唯一的， 使用函数柯理化–接收传入参数 参考JavaScript设计模式 JavaScript设计模式es6（23种) JavaScript 中常见设计模式整理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"javascript之防抖与节流","slug":"javascript之节流与防抖","date":"2020-02-07T05:27:55.000Z","updated":"2020-02-17T13:38:59.724Z","comments":true,"path":"2020/02/07/javascript之节流与防抖/","link":"","permalink":"http://blog.curtaintan.club/2020/02/07/javascript%E4%B9%8B%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"写一个防抖与节流。","text":"写一个防抖与节流。 1. 防抖什么是防抖： 当一个事件触发后，在 n 秒后才执行相关函数，如果在 n 秒内再次触发事件，则在新事件 n 秒后才执行相关函数。 函数功能设计与实现原理： 用户可以根据需求自传定义执行函数、间隔时间、是否立即执行来传入对应的参数。 使用闭包函数，设置一个定时器作为标志放在闭包内，使用函数柯理化接收传入参数。 代码： 123456789101112131415161718192021/** * 防抖函数 * @param fn 回调函数 * @param time 间隔时间 type number * @param immediate 立刻执行 type boolean */function debounce( fn, time, immediate = false )&#123; let timeount return function()&#123; if( timeount )&#123; clearTimeout( timeount ) &#125; if( immediate &amp;&amp; !timeount )&#123; fn.apply( this, arguments ) &#125; timeount = setTimeout( () =&gt; &#123; // 此处运用函数柯理化 arguments 为调用函数时的参数 fn.apply( this, arguments ) // 此处放开注释-会让每一次执行完后，第一次都会立即执行一次 // timeount = null &#125;, time || 500 ) &#125;&#125; 测试： 自建html文件测试123456function go( e )&#123; console.log( e )&#125;document.addEventListener( \"mousemove\", debounce( go, 500, false ) )// 自传参数debounce( go, 500, false )( \"我是自己传进去的参数--\" ) 2. 节流什么是节流： 节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。 代码： 1234567891011121314151617181920212223/** * 节流函数 * @param fn 回调函数 * @param time 间隔时间 type number * @param immediate 立刻执行 type boolean */function throttle( fn, time, immediate = false )&#123; let timeount let isFrist = true return function()&#123; if( immediate &amp;&amp; isFrist )&#123; fn.apply( this, arguments ) isFrist = false &#125; if( !timeount )&#123; timeount = setTimeout( () =&gt; &#123; fn.apply( this, arguments ) timeount = null &#125;, time || 500 ) &#125; &#125;&#125; 测试： 自建html文件测试123456function go( e )&#123; console.log( e )&#125;document.addEventListener( \"mousemove\", throttle( go, 500, true ) )// 自传参数throttle( go, 500, false )( \"我是自己传进去的参数--\" ) 总结：防抖和节流在代码中被使用的频率还是蛮大的， 函数的编写有借鉴，也有自己的思考，感觉自己思考过后，才会对函数有更深的理解。 防抖可以运用在： window 的 resize、scroll mousedown、mousemove keyup、keydown 搜索自动弹出 搜索联想 防抖函数要点： 每一次触发事件，都要清除定时器，并重置 timeout 定时器。 节流函数要点： 每次执行完函数后，都要把标志置为null 参考wclimb–JavaScript之节流与防抖 函数防抖和节流 JavaScript专题之跟着 underscore 学节流 JavaScript专题之跟着underscore学防抖","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"javascript之继承","slug":"javascript之继承","date":"2020-02-06T06:07:35.000Z","updated":"2020-02-17T13:38:49.885Z","comments":true,"path":"2020/02/06/javascript之继承/","link":"","permalink":"http://blog.curtaintan.club/2020/02/06/javascript%E4%B9%8B%E7%BB%A7%E6%89%BF/","excerpt":"在 es6 之前，javaScript 不能使用 extends 来显式继承的，所以，继承需要程序员手动完成。 那么，让我们来看一看 js 中的各种继承方式吧。","text":"在 es6 之前，javaScript 不能使用 extends 来显式继承的，所以，继承需要程序员手动完成。 那么，让我们来看一看 js 中的各种继承方式吧。 前置知识原型链 我们需要了解原型和原型链，需要知道构造函数与原型对象之间的关系，需要知道原型对象是一个对象，它有个属性 constructor 就是构造函数 Object.creact() 方法 传入原型对象，返回原型对象和属性。 1. 原型链继承原理说明： 就是将已经 new 出来的对象实例的 prototype 变成父对象，从而，把父对象的属性和方法都继承到了当前对象的 prototype 上，当前对象的实例本身没有父对象的属性与方法，当调用这些方法时，他会自动到此对象的 prototype 上依次去找，直到找到 null 为止，这就称为原型链继承。 实现 123456789101112131415161718192021222324function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12 )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125;&#125;// 修改原型对象，并改回构造函数Student.prototype = new Person()Student.prototype.constuctor = Studentvar S = new Student( 12 )console.log( \"实例S：\", S )S.run()console.log( S instanceof Student ) 运行结果： 1.1 总结： 由上面的例子可见，当继承的对象需要传参时，极度不灵活，因为 prototype 是一个父类的实例。 故：此继承方法适合继承方法，而不适合继承属性。 2. 借用构造函数继承原理说明： 在构造函数中，改变父类构造函数的 this 并执行构造函数。 实现： 1234567891011121314151617181920212223function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 也可以使用 apply 改变 this Person.call( this, name, age )&#125;var S = new Student( 12, \"yu\", 12 )console.log( \"实例S：\", S )S.run()console.log( S instanceof Student ) 运行结果： 总结： 可以传参给父类构造函数了，但是此方法不能继承父类原型链（ prototype ）上的方法和参数。 3. 组合继承原理说明： 将上面两种方法结合起来，目的是继承到父类原型链上的方法。 实现： 1234567891011121314151617181920212223242526function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 Person.call( this, name, age )&#125;// 继承父类原型链Student.prototype = new Person()Student.prototype.constuctor = Studentvar S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 运行结果： 总结： 很好的继承了父类，并继承了原型链，但是多了一些属性在原型链上。下面我们将解决这个问题。 4. 组合继承变种——借用原型链继承原理说明： 将子类的原型链指向父类的原型链，达到继承父类原型链的目的： 实现： 修改组合继承的代码：1234567// 继承父类原型链Student.prototype = new Person()Student.prototype.constuctor = Student// 修改为：Student.prototype = Object.create( Person.prototype )Student.prototype.constuctor = Student 运行结果： 总结： 完美的继承了父类，干净利索。 5. ES6 类继承 extends实现说明：extends 关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中 constructor 表示构造函数，一个类中只能有一个构造函数，有多个会报出 SyntaxError 错误,如果没有显式指定构造方法，则会添加默认的 constructor 方法，使用 super 方法传参到父类构造函数。 实现： es6 extends 继承1234567891011121314151617181920212223242526class Person&#123; constructor( name=\"tan\", age=18 )&#123; this.name = name this.age = age &#125; run = function() &#123; console.log(`$&#123; this.name &#125; can run...`) &#125; getName = function (params) &#123; return this.name &#125;&#125;class Student extends Person&#123; constructor( id, name, age )&#123; super( name, age ) this.id = id &#125; study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125;&#125;var S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 运行结果： 总结： 简单、完美 疑问：在第四种继承方式中，为什么不能直接改成 Student.prototype = Person.prototype，而要使用 Object.create( Person.prototype ), 代码： 12345678910111213141516171819202122232425function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 Person.call( this, name, age )&#125;Student.prototype = Person.prototypeStudent.prototype.constuctor = Studentvar S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 结果是： 如果你知道原因，请在下方评论区给我留言。感谢！ 总结：尽管继承方式五花八门，但是继承的目的却是不变的： 将父类属性和方法复制到当前类 ( 在构造函数内改变父类构造函数的this并执行 ) 继承父类的原型链 （ 修改构造函数的 prototype 指向父类的 prototype ） 参考：看了都知道继承也就那么回事儿 JavaScript常用八种继承方案","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"javascript 之 new 的实现","slug":"javascript 之 new 的实现","date":"2020-02-06T02:30:46.000Z","updated":"2020-02-17T13:38:42.179Z","comments":true,"path":"2020/02/06/javascript 之 new 的实现/","link":"","permalink":"http://blog.curtaintan.club/2020/02/06/javascript%20%E4%B9%8B%20new%20%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"网上有很多讲原型、原型链、new 的执行与实现的文章，我也看了很多。 本文描述一下 new 的执行过程与手写实现一个 new 的实现。","text":"网上有很多讲原型、原型链、new 的执行与实现的文章，我也看了很多。 本文描述一下 new 的执行过程与手写实现一个 new 的实现。 1. new 的执行过程 我们以上图为例阐述 new 的执行过程。 创建一个中间对象 将该中间对象的原型指向构造函数的原型 将构造函数的 this 指向该中间对象并执行 返回该中间对象，即返回实例对象 2. 代码实现1234567891011121314function myNew()&#123; // 取出传入参数 let argArray = Array.from( arguments ) // 取出构造函数与需要传入构造函数的参数 let constructorFun = argArray.shift() // 创建中间函数 let obj = &#123;&#125; // 将该中间对象的原型指向构造函数的原型 obj.__proto__ = constructorFun.prototype // 绑定 this 并传入参数执行 constructorFun.apply( obj, argArray ) // 返回创建的对象 return obj&#125; 3. 运行测试12345678910111213141516function Animal( name, age )&#123; this.name = name this.age = age&#125;function myNew()&#123; let argArray = Array.from( arguments ) let constructorFun = argArray.shift() let obj = &#123;&#125; obj.__proto__ = constructorFun.prototype constructorFun.apply( obj, argArray ) return obj&#125;console.log( \"myNew：\",myNew( Animal, \"dog\", \"12\" ) )console.log( \"new：\", new Animal( \"cat\", \"11\" ) ) 测试结果： 总结写出 new 的执行过程与实现，基本算是考察对 prototype 原型链的理解。 参考：彻底捋清楚 new 的实现","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---写一个深拷贝","slug":"思路清晰-写一个深拷贝","date":"2020-01-31T09:38:59.000Z","updated":"2020-02-17T13:38:12.506Z","comments":true,"path":"2020/01/31/思路清晰-写一个深拷贝/","link":"","permalink":"http://blog.curtaintan.club/2020/01/31/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-%E5%86%99%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"写一个深拷贝，考虑数组、对象和循环引用。","text":"写一个深拷贝，考虑数组、对象和循环引用。 1.准备两个对象 无循环引用的对象 12345678910111213var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125; 有循环引用的对象1234567891011121314var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;target.target = target 2.使用 JSON.parse(JSON.stringify())2.1复制一个无循环引用的对象，代码如下：12345678910111213141516var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;var res = JSON.parse( JSON.stringify( target ) )console.log( \"target: \", target )console.log( \"res: \", res ) 得到的结果是： 总结：可见，JSON.stringify() 不能处理undefined和function。 2.2复制一个循环应用的对象1234567891011121314151617var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;target.target = targetvar res = JSON.parse( JSON.stringify( target ) )console.log( \"target: \", target )console.log( \"res: \", res ) 结果： 总结：可见，JSON.stringify() 不能处理处理循环引用的结构 3.手写一个深拷贝3.1浅拷贝1234567function clone( target )&#123; let cloneTarget = &#123;&#125; for( let key in target )&#123; cloneTarget[key] = target[key] &#125; return cloneTarget&#125; 上面是一个浅拷贝，没有考虑数组与对象。 3.2 考虑对象我们可以使用 typeof 来判断数据类型： typeof可以查看数据的类型有 7 种：typeof 12345 === numbertypeof “999” === stringtypeof {} === object null []typeof undefined === undefinedtypeof true === booleantypeof symbol(23) === symboltypeof console.log === function typeof小提示 使用递归处理引用对象的拷贝： 1234567891011function clone( target )&#123; if( typeof target === \"object\" )&#123; let cloneTarget = &#123;&#125; for( let key in target )&#123; cloneTarget[key] = clone( target[key] ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 结果： 总结 因为typeof会把数组识别成object，所以，代码还需要再度改进。 3.3 考虑数组1234567891011function clone( target )&#123; if( typeof target === \"object\" )&#123; let cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; for( let key in target )&#123; cloneTarget[key] = clone( target[key] ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 测试结果： 总结： 可见，数组也可以复制了，下面我们要解决循环引用。 3.4 考虑循环引用当学习过设计模式后，我们会发现，有很多情况存在循环引用的问题，所以，在深拷贝时，循环引用的问题是必须要解决的。 解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。 —引用自：如何写出一个惊艳面试官的深拷贝? es6中，有这样一种数据结构叫 Map，他能将对象作为键，这样，我们就能很好的保存对象，并判断对象是否被拷贝过了。 整体流程如下： 是对象，检查map中是否存在此对象 存在—-返回保存在map中的键 不存在—将值存入map，键的值使用当前cloneTarget（这里其实用什么都行） 继续递归拷贝，并传入此时的map 代码如下： 123456789101112131415function clone( target, map = new Map() )&#123; if( typeof target === \"object\" )&#123; var cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; if( map.get( target ) )&#123; return map.get( target ) &#125; map.set( target, cloneTarget ) for( let key in target )&#123; cloneTarget[key] = clone( target[key], map ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 测试结果： 可以看见，已经解决了循环引用的问题。 3.5 简单性能优化使用 WeakMap 数据结构，将复制对象属性的强引用变为弱引用。 WeakMap的作用，请参考 es6 WeakMap. 修改后的代码： 123456789101112131415function clone( target, map = new WeakMap() )&#123; if( typeof target === \"object\" )&#123; var cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; if( map.get( target ) )&#123; return map.get( target ) &#125; map.set( target, cloneTarget ) for( let key in target )&#123; cloneTarget[key] = clone( target[key], map ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 最后，我们就完成了一个简单的深拷贝，解决了对象、数组、循环引用的问题。 结语总结一下写出一个深拷贝的过程： 需要传入两个参数，一个是拷贝目标，一个是作为拷贝过属性的容器 WeakMap 判断拷贝目标是否一个对象 或是 数组 是 使用 WeakMap 判断是否已经拷贝，并递归拷贝每个属性 不是 直接返回此属性的值 js中还有很多其他的数据结构，比如 Set 和 Map，这里就不做继续的深入了， 如果你想继续深入深拷贝，你可以参考：如何写出一个惊艳面试官的深拷贝? 参考如何写出一个惊艳面试官的深拷贝? 阮一峰 es6","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.curtaintan.club/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---socket.io的总结","slug":"思路清晰-socket-io的总结","date":"2020-01-30T07:35:36.000Z","updated":"2020-01-31T06:46:04.954Z","comments":true,"path":"2020/01/30/思路清晰-socket-io的总结/","link":"","permalink":"http://blog.curtaintan.club/2020/01/30/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-socket-io%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"思路清晰的使用socket.io…..","text":"思路清晰的使用socket.io….. 引入：先看官网api： 可以看见，主要有这三个对象：server，namespace和socket 如果你掌握了这三个对象，那么你就已经基本学会socket.io的使用了。 在服务端，我们会写出这样的socket.io服务端代码：12345678910111213141516171819202122const Koa = require('koa') // 引入koaconst app = new Koa() // 创建一个koa实例// 引入http模块，并在Server函数中传入app的回调函数const http = require(\"http\").Server( app.callback() )// 引入socket.io 传入http，并配置socketconst IO = require(\"socket.io\")( http, &#123; pingTimeout: 1000 * 10, pingInterval: 1000 * 2.5&#125;)// 默认命名空间（\"/\"）总线IO监听连接事件 当前IO为默认命名空间IO.on( \"connection\", ( socket ) =&gt; &#123; // 当前socket连接收到event事件，触发callback函数 socket.on( \"event\", callBack ) // 向当前socket连接客户端触发event事件，返回数据sendData socket.emit( \"event\", sendData )&#125;)// 相当于如下代码：var mainSpace = IO.of(\"/\")mainSpace.on( \"connection\", ( socket ) =&gt; &#123; ....&#125; 看了上面的代码，不难发现socket.io暴露两个对象供我们使用，一个是当前命名空间总线IO，一个是当前连接的socket，他们的关系如图： 这里就不得不说一下命名空间了 关于命名空间（namespace）：默认命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192amespace &#123; name: '/', server: Server &#123; nsps: &#123; '/': [Circular] &#125;, parentNsps: Map &#123;&#125;, _path: '/socket.io', _serveClient: true, parser: &#123; protocol: 4, types: [Array], CONNECT: 0, DISCONNECT: 1, EVENT: 2, ACK: 3, ERROR: 4, BINARY_EVENT: 5, BINARY_ACK: 6, Encoder: [Function: Encoder], Decoder: [Function: Decoder] &#125;, encoder: Encoder &#123;&#125;, _adapter: [Function: Adapter], _origins: '*:*', sockets: [Circular], eio: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125;, httpServer: Server &#123; domain: null, _events: [Object], _eventsCount: 5, _maxListeners: undefined, _connections: 0, _handle: null, _usingSlaves: false, _slaves: [], _unref: false, allowHalfOpen: true, pauseOnConnect: false, httpAllowHalfOpen: false, timeout: 120000, keepAliveTimeout: 5000, _pendingResponseData: 0, maxHeadersCount: null, [Symbol(asyncId)]: -1 &#125;, engine: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125; &#125;, sockets: &#123;&#125;, connected: &#123;&#125;, fns: [], ids: 0, rooms: [], flags: &#123;&#125;, adapter: Adapter &#123; nsp: [Circular], rooms: &#123;&#125;, sids: &#123;&#125;, encoder: Encoder &#123;&#125; &#125; &#125; 命名空间与socket当前命名空间总线IO的总结通过上面的命名空间的定义的代码，我们可以知道，在总线IO上，拥有所有连接的socket的信息，拥有所有的rooms信息， 故： 可以向指定房间里发送消息 可以向连接到当前命名空间里的所有socket发送消息 等… 官网api截图： 可知，总的是对room和连接的sockets进行操作。 当前连接socket总结： 个人总结当理解了总线IO与当前连接的socket的关系后，就能思路清晰的写出优秀的的代码了。 写下这篇文章，希望对你有帮助，与君共勉！参考资料：socket.io官网 socket.io命名空间的详细解析 WebSocket协议-Socket.io 服务端API","categories":[{"name":"socket.io","slug":"socket-io","permalink":"http://blog.curtaintan.club/categories/socket-io/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://blog.curtaintan.club/tags/%E5%85%A5%E9%97%A8/"},{"name":"总结","slug":"总结","permalink":"http://blog.curtaintan.club/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"curtain 的 vscode","slug":"我的vscode","date":"2020-01-06T02:57:53.000Z","updated":"2020-02-20T12:27:52.007Z","comments":true,"path":"2020/01/06/我的vscode/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/%E6%88%91%E7%9A%84vscode/","excerpt":"记录自己常用的一些配置…","text":"记录自己常用的一些配置… 1. 打开setting.json配置文件 2. VSCode实现用Ctrl+滚轮实现代码的缩放配置文件如下： 在文件–&gt;首选项–&gt;设置–&gt;用户设置中添加如下代码： 1\"editor.mouseWheelZoom\": true 3. 关闭 vscode 空包折叠1\"explorer.compactFolders\": false 4. vscode 常用快捷键更多请参考：23个鲜为人知的VSCode快捷键（动图演示）","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.curtaintan.club/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vsCode","slug":"vsCode","permalink":"http://blog.curtaintan.club/tags/vsCode/"}]},{"title":"一个小demo弄懂vue的$nextTick","slug":"一个小demo弄懂vue的$nextTick","date":"2020-01-06T01:51:23.000Z","updated":"2020-01-31T01:31:37.853Z","comments":true,"path":"2020/01/06/一个小demo弄懂vue的$nextTick/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/%E4%B8%80%E4%B8%AA%E5%B0%8Fdemo%E5%BC%84%E6%87%82vue%E7%9A%84$nextTick/","excerpt":"一个小demo弄懂vue的$nextTick的作用","text":"一个小demo弄懂vue的$nextTick的作用 有这样一段代码： 代码截图： 123456789101112131415161718192021222324252627&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;span id=\"span\" v-if=\"showSpan\" &gt;span&lt;/span&gt; &lt;button @click=\"btn\" &gt;显示&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data: &#123; showSpan: false &#125;, methods: &#123; btn()&#123; this.showSpan = true console.log( document.querySelector(\"span\") ) setTimeout( () =&gt; &#123; console.log( \"200毫秒后\" ) console.log( document.querySelector(\"span\") ) &#125;, 200 ) this.$nextTick( () =&gt; &#123; console.log( \"$nextTick执行的结果\" ) console.log( document.querySelector(\"span\") ) &#125; ) &#125; &#125; &#125;)&lt;/script&gt; 执行结果： 分析第一个结果为null，因为没有找到dom元素，第二个出现的是$nextTick执行的结果，是确定dom重新渲染挂载完毕执行的回调函数第三个才是定时器的结果，是在最后执行的函数。 结论可知，vue中数据更新引起的dom更新是异步执行的。 小拓展v-if和v-show的区别当我们把上文的 v-if 改成 v-show 后，我们可以看到： 可以看出，v-if=false 时，元素不会渲染到页面，使用 v-show 元素一直在页面中，只是设置样式 display: none; 没有显示而已，","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.curtaintan.club/tags/vue/"}]},{"title":"正则之给字符串来一套增删改查服务","slug":"正则之给字符串来一套增删改查服务","date":"2020-01-03T13:47:46.000Z","updated":"2020-01-04T15:16:16.829Z","comments":true,"path":"2020/01/03/正则之给字符串来一套增删改查服务/","link":"","permalink":"http://blog.curtaintan.club/2020/01/03/%E6%AD%A3%E5%88%99%E4%B9%8B%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E4%B8%80%E5%A5%97%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%9C%8D%E5%8A%A1/","excerpt":"想学习正则的操作吗？？那就进来吧…","text":"想学习正则的操作吗？？那就进来吧… 导读嗨咯，亲爱的读者你好！既然你点进来了，那么想必你一定对正则感兴趣吧。 如果你对正则充满畏惧心理，不懂也不理解正则，没关系，往下看， 看完这篇文章，相信你一定会对正则充满兴趣，并且不再畏惧，消灭恐惧的最好办法，就是面对恐惧！！ 加油！！读完它，理解正则操作，然后爱上正则！ 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 @老姚JS正则表达式完整教程（略长） 老姚对正则的评价非常到位，我很赞同，希望你能记住，这篇文章就是在匹配的基础上做的相关的操作。 如果你没有正则的基础，请不要害怕，这篇文章会一步一步的带你了解正则相关的操作，每个操作的案例相对简单易理解，但是展示出了每个操作的作用。在阅读文章前，请仔细的阅读前置知识，了解相关api的作用。 如果你学习过正则，对正则有一定了解，那么这篇文章非常适合你，这篇文章可以加深你对正则用法的理解。 如果你是正则高手，文中有写的不对的和写得不妥当的，也请指出错误。 本文不涉及正则表达式的书写教学，但是并影响你对每个增删查改操作的理解。如果你想学习正则表达式的书写，在文章后面我有推荐学习正则的优秀文章。 相信你看过这篇文章后，会提高你对正则的理解与学习正则的兴趣。加油！ 前置知识既然是用正则对字符串的操作，那么，我们得需要了解相关的方法，对吧？？与正则相关的方法就6个（真的很少很容易理解！！）：如果你对下面六个方法非常熟悉了，你可以直接从前置知识的总结处开始看（￣︶￣）↗ 与正则相关的6个方法12345678// 字符串四个String#search // 查找匹配到字符串的位置，返回位置indexString#split // 以正则匹配到的字符串截断原字符串，返回数组String#match // 匹配字符串并返回一些信息String#replace // 对匹配到的字符串进行替换，返回修改后的字符串// 正则两个RegExp#test // 匹配字符串是否有符合正则的部分RegExp#exec // 匹配字符串，并返回相关信息 1.String#search语法：str.search(regexp) 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. search1234var regex = /\\d/var string = \"abc123\"console.log( string.search(regex) )// =&gt; 3 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 2.String#split语法：str.split(separator, limit) 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 split1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex, 2) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.String#match语法：str.match(regexp) 定义：查找出与正则相匹配的项。 返回值： 正则的匹配模式为全局匹配：返回匹配的数组或则null 正则的匹配模式不是为全局匹配：返回匹配到的项，groups：分组，index:找到结果的索引,input:原字符串 match1234567var str = \"aa22bb313cc444ff\"var reg = /\\d+/gvar reg1 = /(\\d+)([a-z]+)(\\d+)/console.log( str.match( reg ) )console.log( str.match( reg1 ) )// =&gt; [\"22\", \"313\", \"444\"]// =&gt; [\"22bb313\", \"22\", \"bb\", \"313\", index: 2, input: \"aa22bb313cc444\", groups: undefined] 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 4.String#replace语法：str.replace( regexp | substr, newSubStr | function ) 参数说明： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 用来创建新子字符串的函数，该子字符串用于替换与给定regexp或的匹配项substr。 参数function的参数说明： 第一个参数：整个正则或者字符串匹配到的字符串， 中间的参数：依次为正则中分组匹配到的字符串， 倒数第二个参数：找到结果的索引 倒数第一个参数：原字符串 str.replace( regexp, function )12345678var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; console.log( \"参数列表：\", str, s1, s2, index, sour ) console.log( arguments ) return s1 + \"---\" + s2&#125;)console.log( str ) 5.RegExp#test语法：reg.test( str ) 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false reg.test()1234var regex = /\\d/var string = \"abc123\"console.log( regex.test(string) )// =&gt; true 6.RegExp#exec语法：reg.exec( str ) 说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 reg.exec( str )12345var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gconsole.log( reg.exec( str ))console.log( reg.exec( str ))console.log( reg.exec( str )) 注意当使用全局模式时，exec函数会把这次匹配到的位置存放在当前正则reg的lastIndex里面，下次调用时，会从这次的最后位置开始查找。 总结通过上面简单的案例与说明，相信你已经可以看出我们要进行的增删改查操作应该用哪个方法了吧？我们来总结一下： 增：6个方法中，只有replace可以对匹配到的字符串进行操作，所以当我们需要在字符串中增加内容时，我们就可以使用replace方法。 删：6个方法中，split方法以匹配到的字符串为断点截断字符串返回数组，replace也可以对匹配到的字符串进行操作，所以删除可以使用split和replace方法。 查：6个方法中，除了split方法，都或多或少可以得到一些匹配到字符串的信息。 改：6个方法中，只有replace方法可以操作匹配到的字符串，所以修改只有用replace方法。 好了，下面详细的介绍下各种操作的详细情况。 1.增相信你一定遇到过往字符串里面加字符串的情况，你一般是怎么操作的呢？我们来分析下： 当向字符串中添加字符串时，有两种添加情况，一种：添加到匹配的字符串前，另一种是：添加到匹配的字符串后面。 是吧？？好，开始操作吧！ 添加到匹配字符串前：我们可以使用正则位置匹配表达式：(?=p)，正向肯定预查，其中p是一个子模式，即p前面的位置。 123var result = \"hello\".replace(/(?=ll)/g, '#')console.log(result)// =&gt; \"he#llo\" 也可以直接使用函数操作： 12345var result = \"hello\".replace(/(?=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"he#llo\" 添加到匹配字符串后：我们可以使用正则位置匹配表达式：(?&lt;=p)，反向肯定预查，就是p后面的位置。 12345var result = \"hello\".replace(/(?&lt;=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"hell#o\" 当然，你也可以直接使用replace的函数操作完成。 补充 在整个字符串前和后面添加， 12345var result = \"hello\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello#\" 在每个单词的前后面添加 12345var result = \"hello world\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello# #world#\" 2.删：经过我们前面的总结，删除可以使用String.split和String.replace完成。 String.splite可以知道，使用splite方法返回的是一个数组，操作后，我们可以使用join()函数，返回字符串 1234var str = \"aa22bb313cc444ff\"var reg = /\\d+/console.log( str.split( reg ).join(\"\") )// =&gt; \"aabbccff\" String.replace使用replace就非常简单了，我们可以把第二个参数传 &quot;&quot; ,也可以用函数操作，返回 &quot;&quot;即可。 12345var str = \"aa22bb313cc444ff\"var reg = /\\d+/g // 全局模式，不加全局模式，只会替换一次str = str.replace( reg, \"\" )console.log( str )// =&gt; \"aabbccff\" 3.查查找可以分为两类：一种是需要详细结果的，一种是不需要详细结果的。 不需要详细结果不需要详细结果就是返回 true 和 false 就可以了。这里可以使用test 验证电话号码123var reg = /^1[345789]\\d&#123;9&#125;$/var res = reg.test( \"13882628333\" )// =&gt; true 需要详细结果使用String.match()获取时间123var reg = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( \"2017-06-10\".match( reg ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var string = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( string.match( reg ))// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] match获取全部的颜色代码（正则使用g全局匹配模式）1234var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"console.log( str.match( reg ) )// =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 使用reg.exec()获取时间123var regex = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( reg.exec( \"2017-06-10\" ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var str = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( reg.exec( str ) )// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] exec获取全部的颜色代码（正则使用g全局匹配模式）12345678var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"var arr = []var tempwhile( temp = reg.exec( str ) )&#123; arr.push( temp[0] )&#125;console.log( arr ) 4.改经过前面的终结，我们知道只有replace可以进行修改操作： 1234567var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; return s1 + \"---\" + s2&#125;)console.log( str )// =&gt; \"aa22---bb313---cc444---ff\" 后记写下这篇文章，就是想让自己梳理下正则相关的api与用法，加强一下自己写正则的信心。 看了这篇文章，你是否对正则又有了新的理解呢？对自己写正则是否又增加了几分信心呢？ 总结本文主要讲述了正则的相关用法，考虑到正则新手，所以每个操作都只是做的很简单的案例，正则表达式大都很简单，但是，我相信，看了本文，你会更有信心去学习正则。 学习正则：如果你想学习正则表达式的书写，我这里将推荐一些好的文章给你： 老姚-JS正则表达式完整教程（略长） 非常推荐的一篇文章，我就是看这篇文章学习的正则，适合有一点正则基础的同学 考拉海前端团队—JS 的正则表达式 条理清晰–适合初学者学习正则的书写 文章在精不在多，这两篇文章对初学正则的同学非常友好，能引导你写出优秀的正则表达式，再结合这篇文章对正则表达式的运用，相信你会对正则的运用游刃有余。 参考资料：老姚-JS正则表达式完整教程（略长） MDN-String.prototype.match() MDN-String.prototype.replace() 共勉写下这篇文章，希望对你有帮助，与君共勉！","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"博客再次启程","slug":"博客再次启程","date":"2019-12-02T09:52:17.000Z","updated":"2020-02-07T15:56:26.796Z","comments":true,"path":"2019/12/02/博客再次启程/","link":"","permalink":"http://blog.curtaintan.club/2019/12/02/%E5%8D%9A%E5%AE%A2%E5%86%8D%E6%AC%A1%E5%90%AF%E7%A8%8B/","excerpt":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！","text":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！ 碎碎念经过一天的配置，博客搭建的差不多了， 整理好心情！！！ 重新出发！","categories":[{"name":"我的随笔","slug":"我的随笔","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.curtaintan.club/tags/%E7%94%9F%E6%B4%BB/"}],"author":{"avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png","url":"http://blog.curtaintan.club/"}},{"title":"drawing-board画板","slug":"drawing-board画板","date":"2019-08-14T08:04:55.000Z","updated":"2020-02-06T05:21:32.102Z","comments":true,"path":"2019/08/14/drawing-board画板/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/drawing-board%E7%94%BB%E6%9D%BF/","excerpt":"canvas写的画板","text":"canvas写的画板 快到碗里来-画板 预览：点击 前言： 之前学完canvas，一直想自己写一点东西，这两天终于完成了，开心！！ 完成功能： 绘画 画直线 截图 旋转 弹幕 鼠标触碰弹幕，弹幕悬停 撤销/前进 设置画笔信息 兼容移动端 功能截图： 前置说明如果你需要参考代码，你需要看下这里。因为功能复杂，标志的变量有接近10个之多，一下子可能很难看懂，所以我这里说明下我的开发流程，以及定义变量的顺序。 功能顺序： 画笔 → 定义画笔信息 → 橡皮檫 → 删除 → 撤销/前进 → 直线 → 截图 → 弹幕 定义变量的顺序，以及作用： 所有功能变量： 1234567891011121314151617181920212223242526272829303132333435363738var isDown = false // 标志鼠标是否按下 绘图三步和剪切三步走时，后面两个事件触发的标志var points = [] // 滑动时收集的点 绘画三步走时，为了时画的线光滑，记录点，减短画线的距离var beginPoint = null // 开始的点 绘画三步走时使用----这三个为一组，画线三人组，为了让画的线更为光滑var currentMenu = \"icon-pen\" // 初始按钮 底部按钮选中的按钮var currentColor = 0 // 初始颜色的index 颜色选择，默认第一个var paintingModal = \"pen\" // 画笔模式 line||pen||cut----按钮功能三人组，按钮选中标记，颜色选中，画画的模式，切换前面画笔和画直线的模式var lookModal = false // 鼠标模式 按钮第一个功能，此模式不能绘画，只能看var cuted = false // 标记裁剪时，是否已经裁剪 裁剪后，防止后续的操作再次触发裁剪操作 ----鼠标模式和剪切模式的定义var animationTimer = null // 弹幕动画的timer 动画的timervar barrageArray = [] // 保存弹幕的数组var globalPoint = &#123; x : 0, y : 0 &#125; // canvas上鼠标的点 ---弹幕时使用----弹幕三人组 globalPoint用来标记鼠标在canvas中的坐标，用于判断鼠标是否触碰到弹幕上// 实现撤销和重做的功能let canvasHistory = [] // canvas数据，在每次画线和橡皮檫使用后保存数据let step = 0 // 画笔抬起的步数，清空时，步数也清空----撤销/前进二人组，画笔抬起时，把画布信息用getImageData存入canvasHistory，用step完成前进和撤销的功能var penAttibutes = &#123; // 画笔数据， width : 2, lineCap : \"round\", lineJoin : \"round\", strokeStyle: \"#000\", fillStyle: \"#000\", globalCompositeOperation: \"source-over\", globalAlpha : 1&#125; 开发中遇到的难点与重点与解决方案： 保存历史记录使用api对比 我在写代码的时候有做过参考 这篇文章，文章里用是canvas.toDataUrl的方式做的数据保存，评论里说这个数据保存不理想，其实我一开始的时候想的就是用ctx.getImageDaata的方式来做的，我也用这个两个api做了一个对比： 代码： 结果： 可见，使用getImageData获取数据是时间是非常短的，并且获取到是画布像素数据，后续可以直接进行像素操作，从而不用再花时间再去获取画布信息，其次，getImageData获取到是数据是有数据结构的，这样在内存里面保存下来对内存更加友好，而使用toDataUrl方式保存下来的数据有21万行那么长的字符串，对内存并不友好。 后面我还做了他们绘制到画布上的时间对比，他们的时间都在1ms内，到时每次putImageData都要快一点点，但是快这一点时间的意义并不大。 toDataUrl也是有好处的，因为转置出来的是base64的字符串，所以他能够直接作为图片的src属性，让图片显示到页面。 画直线 如何画出一条直线？？当我做了撤销和前进的时候，我就把画板数据给存到canvasHistory里面了，这里刚好用到，鼠标移动是时候，先清空画布，再绘制保存到canvasHistory里最后那个数据，然后就是绘图三步走，就完成了。 注意：这里一定要绘图三步走，或者在绘制前一定要用beginPath()重开一条路径，如果不重开路径，绘制时，会把前面的直线一同绘制出来，因为你一直是一条路径，所以下次绘制时，上次的点也要绘制一遍。 图片旋转 旋转很类似css3，但是，canvas的基点固定在左上角处，所以在旋转的时候，需要先用translate移动画板，可以画一下图， 下面是我画的图： 问题： 当我画笔有rotate属性的时候，当前操作的putImageData不会成功，不知道为什么----- 如何画出一条光滑的曲线 用正常的画法画曲线是时候，画出的曲线不够光滑， 所以我就参考了这篇文章 canvas进阶——如何画出平滑的曲线? （其实我也想到了用二次贝塞尔曲线，在寻找更好的解决方案时，就找到这个方法了，这个方案更优），原理可以看原文。 鼠标触摸弹幕 因为canvas是无记忆性的，所以，你用isPointPath和isPointStroke时，是在当前绘画下才能检测。 在使用isPointPath时，他只与path路径有关，意思就是，你用fillRect直接绘制一个矩形图形是不能检测的， 只能检测rect()和pathTo等围起来的路径内。 所以，这里我做了一个外挂路径-用rect()把每个弹幕框起来——哈哈– 使用drawImage须知： drawImage有三种传参方式，三种方式出来的效果，在书写前可以先参考效果。 参考地址：CanvasRenderingContext2D.drawImage 兼容移动端 当在移动端时，会存在移动端延时300ms的问题，因为移动端有双击放大功能，故存在300ms时间。 我解决的方法是设置meta信息，禁止缩放，就可以防止300ms问题 结语：这个项目大概用了canvas的75%的api，还有像素操作和渐变等api还没用到。 不知道有没有人看呢， 如果你看到了这篇文章，希望对你有帮助。 慢慢来，好好学习，要加油哦！ 与君共勉！！ 参考材料： 手把手教你实现一个canvas智绘画板 参考了楼主项目的样式，但是所有样式都是我自己写的，嘻嘻，实现方式不一样哦。。 canvas进阶——如何画出平滑的曲线? 画一条光滑的曲线，不错哦。 canvas动画包教不包会 可以在这里把所有api的意义和作用和参数等都记下来—– Canvas API中文文档首页地图 canvas所有的api，当然你也可以去mdn看，其实都一样啦—","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://blog.curtaintan.club/tags/canvas/"}]},{"title":"正则小记（一）之api速学","slug":"正则小记（一）之api速学","date":"2019-08-14T08:04:55.000Z","updated":"2020-01-02T04:43:51.427Z","comments":true,"path":"2019/08/14/正则小记（一）之api速学/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8Bapi%E9%80%9F%E5%AD%A6/","excerpt":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章…","text":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章… 前言正则，用简短的一句话概括，正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则的方法和与正则有关的方法共有6个，字符串实例4个，正则实例2个： String#search String#split String#match String#replace RegExp#test RegExp#exec 1.search()定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1234var regex = /\\d/;var string = \"abc123\";console.log( string.search(regex) );// =&gt; 3 2.split定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 例子： 1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.match定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则： 匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( string.match(regex) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 4.replace语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. replace后面单独写一篇文章总结 案例： 12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";var date = [];string.replace(regex, function(match, year, month, day) &#123; date.push(year, month, day);&#125;);console.log(date);// =&gt; [\"2017\", \"06\", \"26\"] 5.test说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1234var regex = /\\d/;var string = \"abc123\";console.log( regex.test(string) );// =&gt; true 6.exec说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 这个方法很类似match方法。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( regex.exec(string) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 相关API注意要点-1 search和match的参数问题我们知道字符串实例的那4个方法参数都支持正则和字符串。 但search和match，会把字符串转换为正则的。 1234567891011121314151617181920212223var string = \"2017.06.27\";console.log( string.search(\".\") );// =&gt; 0//需要修改成下列形式之一console.log( string.search(\"\\\\.\") );console.log( string.search(/\\./) );// =&gt; 4// =&gt; 4console.log( string.match(\".\") );// =&gt; [\"2\", index: 0, input: \"2017.06.27\"]//需要修改成下列形式之一console.log( string.match(\"\\\\.\") );console.log( string.match(/\\./) );// =&gt; [\".\", index: 4, input: \"2017.06.27\"]// =&gt; [\".\", index: 4, input: \"2017.06.27\"]console.log( string.split(\".\") );// =&gt; [\"2017\", \"06\", \"27\"]console.log( string.replace(\".\", \"/\") );// =&gt; \"2017/06.27\" 2 match返回结果的格式问题match返回结果的格式，与正则对象是否有修饰符g有关。 1234567var string = \"2017.06.27\";var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; [\"2017\", \"06\", \"27\"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有g，返回的是所有匹配的内容。 3 exec比match更强大当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。 而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配： 123456789101112131415161718var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"]// =&gt; 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"] 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"] 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"] 10 4 修饰符g，对exex和test的影响上面提到了正则实例的lastIndex属性，表示尝试匹配时，从字符串的lastIndex位开始去匹配。 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。 而正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。下面让我们以test为例，看看你是否会迷糊： 1234567var regex = /a/g;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 1// =&gt; true 3// =&gt; false 0 注意上面代码中的第三次调用test，因为这一次尝试匹配，开始从下标lastIndex即3位置处开始查找，自然就找不到了。 如果没有g，自然都是从字符串第0个字符处开始尝试匹配： 1234567var regex = /a/;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 0// =&gt; true 0// =&gt; true 0 5 test整体匹配时需要使用^和$这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： 123456console.log( /123/.test(\"a123b\") );// =&gt; trueconsole.log( /^123$/.test(\"a123b\") );// =&gt; falseconsole.log( /^123$/.test(\"123\") );// =&gt; true 6 split相关注意事项split方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： 123var string = \"html,css,javascript\";console.log( string.split(/,/, 2) );// =&gt;[\"html\", \"css\"] 7 replace是很强大的 《JavaScript权威指南》认为exec是这6个API中最强大的，而我始终认为replace才是最强大的。 因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号例如，把”2,3,5”，变成”5=2+3”： 123var result = \"2,3,5\".replace(/(\\d+),(\\d+),(\\d+)/, \"$3=$1+$2\");console.log(result);// =&gt; \"5=2+3\" 又例如，把”2,3,5”，变成”222,333,555”: 123var result = \"2,3,5\".replace(/(\\d+)/g, \"$&amp;$&amp;$&amp;\");console.log(result);// =&gt; \"222,333,555\" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”: 123var result = \"2+3=5\".replace(/=/, \"$&amp;$`$&amp;$'$&amp;\");console.log(result);// =&gt; \"2+3=2+3=5=5\" 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： 123456\"1234 2345 3456\".replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function(match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; [\"1234\", \"1\", \"4\", 0, \"1234 2345 3456\"]// =&gt; [\"2345\", \"2\", \"5\", 5, \"1234 2345 3456\"]// =&gt; [\"3456\", \"3\", \"6\", 10, \"1234 2345 3456\"] 此时我们可以看到replace拿到的信息，并不比exec少。 8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多\\。 12345678var string = \"2017-06-27 2017.06.27 2017/06/27\";var regex = /\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/g;console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"]regex = new RegExp(\"\\\\d&#123;4&#125;(-|\\\\.|\\\\/)\\\\d&#123;2&#125;\\\\1\\\\d&#123;2&#125;\", \"g\");console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"] 9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline10 source属性正则实例对象属性，除了global、ingnoreCase、multiline、lastIndex属性之外，还有一个source属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： 1234var className = \"high\";var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\");console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串\"(^|\\\\s)high(\\\\s|$)\" 11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是$1,…,$9之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp[&quot;$&apos;&quot;]测试代码如下： 1234567891011121314151617181920212223var regex = /([abc])(\\d)/g;var string = \"a1b2c3d4e5\";string.match(regex);console.log( RegExp.input );console.log( RegExp[\"$_\"]);// =&gt; \"a1b2c3d4e5\"console.log( RegExp.lastMatch );console.log( RegExp[\"$&amp;\"] );// =&gt; \"c3\"console.log( RegExp.lastParen );console.log( RegExp[\"$+\"] );// =&gt; \"3\"console.log( RegExp.leftContext );console.log( RegExp[\"$`\"] );// =&gt; \"a1b2\"console.log( RegExp.rightContext );console.log( RegExp[\"$'\"] );// =&gt; \"d4e5\" 结语： 我搜查列出了相关的6个方法，并对6个方法进行了说明。 后面我会对replace再单独出一篇文章。 参考资料里的第一篇文章真的非常好，值得仔细研读。 如果你想粗略了解正则的方法，看我这篇文章是没错了，后面列出的相应方法的坑点和注意点。 后面，我会再慢慢补充匹配规则，我会单独列出一篇文章，因为匹配规则也有很多注意点呢。 哈哈哈，其实也是在下面的文章里面看的啦，文章真的写得好---嘻嘻 其实正则也没有那么难的啦----- 希望这篇文章对你有帮助，每天都要加油哦。 加油，与君共勉！！！参考资料： JS正则表达式完整教程（略长） 文章真的写的不错，认认真真，细嚼慢咽的看完这篇文章，保证你学会正则。 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。 MDN-RegExp MDN-String","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]}]}