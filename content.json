{"meta":{"title":"curTain","subtitle":"","description":"","author":"tanTantan","url":"http://blog.curtaintan.club","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-02T08:25:53.803Z","updated":"2019-12-02T08:25:53.803Z","comments":true,"path":"404.html","permalink":"http://blog.curtaintan.club/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2019-12-26T14:01:52.812Z","updated":"2019-12-26T14:01:52.812Z","comments":true,"path":"categories/index.html","permalink":"http://blog.curtaintan.club/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-31T05:59:09.746Z","updated":"2020-01-31T05:59:09.746Z","comments":true,"path":"friends/index.html","permalink":"http://blog.curtaintan.club/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-03T08:42:54.518Z","updated":"2019-12-03T08:42:54.518Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.curtaintan.club/mylist/index.html","excerpt":"","text":""},{"title":"我的收藏夹","date":"2020-01-31T06:03:52.343Z","updated":"2020-01-31T06:03:52.343Z","comments":true,"path":"favorite/index.html","permalink":"http://blog.curtaintan.club/favorite/index.html","excerpt":"","text":"图床又拍图床speed路过图床(稳定、推荐使用) 前端面试题 前端 100 问：能搞懂 80% 的请把简历给我 sequelize一点通 Sequelize 快速入门 Sequelize 系列教程之一对一模型关系 Sequelize 系列教程之一对多模型关系 Sequelize 系列教程之多对多模型关系 色彩搭配Paleetes 大家有什么好的东西，可以在下面给我留言...."},{"title":"我的作品","date":"2019-12-26T14:01:29.466Z","updated":"2019-12-26T14:01:29.466Z","comments":true,"path":"projects/index.html","permalink":"http://blog.curtaintan.club/projects/index.html","excerpt":"","text":"2019.11 nextGo使用nextjs搭配koa2搭建的仿写github的ssr项目，项目使用github接口，使用OAuth进行登录。 Features： 使用nextjs构建 使用hooks 使用redux管理状态 集成koa2 使用HOC定制props 接入github—OAuth 使用webpack-bundle-analyzer分析打包依赖 预览地址：nextGo源码地址：github打包分析：点击直达 2019.9 fabric-board 用fabric.js重写的面向对象的画板 使用了同学（胡翔）的ipad和配套的Apple Pencil，体验了记事本的功能，突发奇想，我就实现了一下，使用图层对象的形式来开发画板，体验还是不错的。 这个项目从开始构想，到大体完成只花了两天，后面在完善获取图层组，然后将图层组单独拿出来渲染到右侧的小canvas上的时候，出现了问题， 断断续续的写了下，还是没有解决。 Features： fabric.js canvas vue 图层式操作 预览地址：fabricGo源码地址：github 2019.8 canvasGo 使用canvas构建的画板项目，原生js操作。 Features： 原生js canvas 兼容手机端 拥有发送弹幕功能 截图功能 截图可旋转 撤销/前进 预览地址：canvasGo源码地址：github配套文章：快到碗里来 2019.6 electron-music 是学习electron的小demo吧，后面一定会推出electron的更完善的应用的。 Features： electron 原生js 桌面应用 本地数据缓存 源码地址：github 2019.5 网易云Go 使用flutter构建的模仿网易云音乐app，界面还原度很高， Features： flutter构建 播放视频与vedio 播放音乐 导航栏级联滑动 搜索提示 节流操作 provide状态管理 组件式开发 源码地址：github下载地址： 安卓下载：点我下载 扫码下载： ios：由于没有ios手机和mac，所以没有打包ios版本 2019.3 知程 使用原生小程序构建，工作室团队项目， Features： 微信小程序 城市级联 flex布局 源码地址：github 2018.10 chatGo 使用socket.io搭配express搭建而成的在线聊天系统，后面会使用框架搭建一个更全面，界面更友好的在线聊天系统， Features： socket.io构建而成 bootstrap栅格系统 源码地址：github预览地址：chatGo 2018.10 小小论坛 这是最初的作品，也是心心念念想要去完成的作品，最初是版本是留言板，后来一再一再的扩展，就变成了这样的一个论坛了。其实蛮喜欢这个作品的，最近也在重构中，也在试图添加更多功能… Features： vuejs、vuex、vue-router全家桶 quill富文本编辑器 路由守卫 token鉴权 源码地址：github预览地址：点击直达"},{"title":"所有标签","date":"2019-12-03T08:46:42.440Z","updated":"2019-12-03T08:46:42.440Z","comments":true,"path":"tags/index.html","permalink":"http://blog.curtaintan.club/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-26T14:01:07.399Z","updated":"2019-12-26T14:01:07.399Z","comments":true,"path":"about/index.html","permalink":"http://blog.curtaintan.club/about/index.html","excerpt":"","text":"云淡风轻、 关于我：目前就读于成都大学，大三 热爱的： coding 探索 前端 科技 电子产品 技术栈： js flutter nodejs mysql 愿望： 打造一个多端的app 和好朋友们一起吃好多好吃的 和好朋友们一起去海边看海 有自己热爱的东西，平静简单的生活.. 欢迎灌水"}],"posts":[{"title":"思路清晰---socket.io的总结","slug":"思路清晰-socket-io的总结","date":"2020-01-30T07:35:36.000Z","updated":"2020-01-31T05:50:00.868Z","comments":true,"path":"2020/01/30/思路清晰-socket-io的总结/","link":"","permalink":"http://blog.curtaintan.club/2020/01/30/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-socket-io%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"思路清晰的使用socket.io…..","text":"思路清晰的使用socket.io….. 引入：在服务端，我们会写出这样的socket.io服务端代码： 12345678910111213141516171819202122const Koa = require('koa') // 引入koaconst app = new Koa() // 创建一个koa实例// 引入http模块，并在Server函数中传入app的回调函数const http = require(\"http\").Server( app.callback() )// 引入socket.io 传入http，并配置socketconst IO = require(\"socket.io\")( http, &#123; pingTimeout: 1000 * 10, pingInterval: 1000 * 2.5&#125;)// 默认命名空间（\"/\"）总线IO监听连接事件 当前IO为默认命名空间IO.on( \"connection\", ( socket ) =&gt; &#123; // 当前socket连接收到event事件，触发callback函数 socket.on( \"event\", callBack ) // 向当前socket连接客户端触发event事件，返回数据sendData socket.emit( \"event\", sendData )&#125;)// 相当于如下代码：var mainSpace = IO.of(\"/\")mainSpace.on( \"connection\", ( socket ) =&gt; &#123; ....&#125; 看了上面的代码，不难发现socket.io暴露两个对象供我们使用，一个是当前命名空间总线IO，一个是当前连接的socket，如图： 这里就不得不说一下命名空间了 关于命名空间（namespace）：默认命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192amespace &#123; name: '/', server: Server &#123; nsps: &#123; '/': [Circular] &#125;, parentNsps: Map &#123;&#125;, _path: '/socket.io', _serveClient: true, parser: &#123; protocol: 4, types: [Array], CONNECT: 0, DISCONNECT: 1, EVENT: 2, ACK: 3, ERROR: 4, BINARY_EVENT: 5, BINARY_ACK: 6, Encoder: [Function: Encoder], Decoder: [Function: Decoder] &#125;, encoder: Encoder &#123;&#125;, _adapter: [Function: Adapter], _origins: '*:*', sockets: [Circular], eio: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125;, httpServer: Server &#123; domain: null, _events: [Object], _eventsCount: 5, _maxListeners: undefined, _connections: 0, _handle: null, _usingSlaves: false, _slaves: [], _unref: false, allowHalfOpen: true, pauseOnConnect: false, httpAllowHalfOpen: false, timeout: 120000, keepAliveTimeout: 5000, _pendingResponseData: 0, maxHeadersCount: null, [Symbol(asyncId)]: -1 &#125;, engine: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125; &#125;, sockets: &#123;&#125;, connected: &#123;&#125;, fns: [], ids: 0, rooms: [], flags: &#123;&#125;, adapter: Adapter &#123; nsp: [Circular], rooms: &#123;&#125;, sids: &#123;&#125;, encoder: Encoder &#123;&#125; &#125; &#125; 命名空间与socket当前命名空间总线IO的总结通过上面的命名空间的定义的代码，我们可以知道，在总线IO上，拥有所有连接的socket的信息，拥有所有的rooms信息， 故： 可以向指定房间里发送消息 可以向连接到当前命名空间里的所有socket发送消息 等… 官网api截图： 可知，总的是对room和连接的sockets进行操作。 当前连接socket总结： 个人总结当理解了总线IO与当前连接的socket的关系后，就能思路清晰的写出优秀的的代码了。 写下这篇文章，希望对你有帮助，与君共勉！参考资料：socket.io官网 socket.io命名空间的详细解析 WebSocket协议-Socket.io 服务端API","categories":[{"name":"socket.io","slug":"socket-io","permalink":"http://blog.curtaintan.club/categories/socket-io/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://blog.curtaintan.club/tags/%E5%85%A5%E9%97%A8/"},{"name":"总结","slug":"总结","permalink":"http://blog.curtaintan.club/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"vscode相关配置","slug":"vscode相关配置","date":"2020-01-06T02:57:53.000Z","updated":"2020-01-06T03:05:25.798Z","comments":true,"path":"2020/01/06/vscode相关配置/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/vscode%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"记录自己常用的一些配置…","text":"记录自己常用的一些配置… 打开setting.json配置文件 VSCode实现用Ctrl+滚轮实现代码的缩放配置文件如下： 在文件–&gt;首选项–&gt;设置–&gt;用户设置中添加如下代码： 1\"editor.mouseWheelZoom\": true","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.curtaintan.club/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vsCode","slug":"vsCode","permalink":"http://blog.curtaintan.club/tags/vsCode/"}]},{"title":"一个小demo弄懂vue的$nextTick","slug":"一个小demo弄懂vue的$nextTick","date":"2020-01-06T01:51:23.000Z","updated":"2020-01-31T01:31:37.853Z","comments":true,"path":"2020/01/06/一个小demo弄懂vue的$nextTick/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/%E4%B8%80%E4%B8%AA%E5%B0%8Fdemo%E5%BC%84%E6%87%82vue%E7%9A%84$nextTick/","excerpt":"一个小demo弄懂vue的$nextTick的作用","text":"一个小demo弄懂vue的$nextTick的作用 有这样一段代码： 代码截图： 123456789101112131415161718192021222324252627&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;span id=\"span\" v-if=\"showSpan\" &gt;span&lt;/span&gt; &lt;button @click=\"btn\" &gt;显示&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data: &#123; showSpan: false &#125;, methods: &#123; btn()&#123; this.showSpan = true console.log( document.querySelector(\"span\") ) setTimeout( () =&gt; &#123; console.log( \"200毫秒后\" ) console.log( document.querySelector(\"span\") ) &#125;, 200 ) this.$nextTick( () =&gt; &#123; console.log( \"$nextTick执行的结果\" ) console.log( document.querySelector(\"span\") ) &#125; ) &#125; &#125; &#125;)&lt;/script&gt; 执行结果： 分析第一个结果为null，因为没有找到dom元素，第二个出现的是$nextTick执行的结果，是确定dom重新渲染挂载完毕执行的回调函数第三个才是定时器的结果，是在最后执行的函数。 结论可知，vue中数据更新引起的dom更新是异步执行的。 小拓展v-if和v-show的区别当我们把上文的 v-if 改成 v-show 后，我们可以看到： 可以看出，v-if=false 时，元素不会渲染到页面，使用 v-show 元素一直在页面中，只是设置样式 display: none; 没有显示而已，","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.curtaintan.club/tags/vue/"}]},{"title":"正则之给字符串来一套增删改查服务","slug":"正则之给字符串来一套增删改查服务","date":"2020-01-03T13:47:46.000Z","updated":"2020-01-04T15:16:16.829Z","comments":true,"path":"2020/01/03/正则之给字符串来一套增删改查服务/","link":"","permalink":"http://blog.curtaintan.club/2020/01/03/%E6%AD%A3%E5%88%99%E4%B9%8B%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E4%B8%80%E5%A5%97%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%9C%8D%E5%8A%A1/","excerpt":"想学习正则的操作吗？？那就进来吧…","text":"想学习正则的操作吗？？那就进来吧… 导读嗨咯，亲爱的读者你好！既然你点进来了，那么想必你一定对正则感兴趣吧。 如果你对正则充满畏惧心理，不懂也不理解正则，没关系，往下看， 看完这篇文章，相信你一定会对正则充满兴趣，并且不再畏惧，消灭恐惧的最好办法，就是面对恐惧！！ 加油！！读完它，理解正则操作，然后爱上正则！ 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 @老姚JS正则表达式完整教程（略长） 老姚对正则的评价非常到位，我很赞同，希望你能记住，这篇文章就是在匹配的基础上做的相关的操作。 如果你没有正则的基础，请不要害怕，这篇文章会一步一步的带你了解正则相关的操作，每个操作的案例相对简单易理解，但是展示出了每个操作的作用。在阅读文章前，请仔细的阅读前置知识，了解相关api的作用。 如果你学习过正则，对正则有一定了解，那么这篇文章非常适合你，这篇文章可以加深你对正则用法的理解。 如果你是正则高手，文中有写的不对的和写得不妥当的，也请指出错误。 本文不涉及正则表达式的书写教学，但是并影响你对每个增删查改操作的理解。如果你想学习正则表达式的书写，在文章后面我有推荐学习正则的优秀文章。 相信你看过这篇文章后，会提高你对正则的理解与学习正则的兴趣。加油！ 前置知识既然是用正则对字符串的操作，那么，我们得需要了解相关的方法，对吧？？与正则相关的方法就6个（真的很少很容易理解！！）：如果你对下面六个方法非常熟悉了，你可以直接从前置知识的总结处开始看（￣︶￣）↗ 与正则相关的6个方法12345678// 字符串四个String#search // 查找匹配到字符串的位置，返回位置indexString#split // 以正则匹配到的字符串截断原字符串，返回数组String#match // 匹配字符串并返回一些信息String#replace // 对匹配到的字符串进行替换，返回修改后的字符串// 正则两个RegExp#test // 匹配字符串是否有符合正则的部分RegExp#exec // 匹配字符串，并返回相关信息 1.String#search语法：str.search(regexp) 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. search1234var regex = /\\d/var string = \"abc123\"console.log( string.search(regex) )// =&gt; 3 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 2.String#split语法：str.split(separator, limit) 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 split1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex, 2) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.String#match语法：str.match(regexp) 定义：查找出与正则相匹配的项。 返回值： 正则的匹配模式为全局匹配：返回匹配的数组或则null 正则的匹配模式不是为全局匹配：返回匹配到的项，groups：分组，index:找到结果的索引,input:原字符串 match1234567var str = \"aa22bb313cc444ff\"var reg = /\\d+/gvar reg1 = /(\\d+)([a-z]+)(\\d+)/console.log( str.match( reg ) )console.log( str.match( reg1 ) )// =&gt; [\"22\", \"313\", \"444\"]// =&gt; [\"22bb313\", \"22\", \"bb\", \"313\", index: 2, input: \"aa22bb313cc444\", groups: undefined] 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 4.String#replace语法：str.replace( regexp | substr, newSubStr | function ) 参数说明： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 用来创建新子字符串的函数，该子字符串用于替换与给定regexp或的匹配项substr。 参数function的参数说明： 第一个参数：整个正则或者字符串匹配到的字符串， 中间的参数：依次为正则中分组匹配到的字符串， 倒数第二个参数：找到结果的索引 倒数第一个参数：原字符串 str.replace( regexp, function )12345678var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; console.log( \"参数列表：\", str, s1, s2, index, sour ) console.log( arguments ) return s1 + \"---\" + s2&#125;)console.log( str ) 5.RegExp#test语法：reg.test( str ) 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false reg.test()1234var regex = /\\d/var string = \"abc123\"console.log( regex.test(string) )// =&gt; true 6.RegExp#exec语法：reg.exec( str ) 说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 reg.exec( str )12345var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gconsole.log( reg.exec( str ))console.log( reg.exec( str ))console.log( reg.exec( str )) 注意当使用全局模式时，exec函数会把这次匹配到的位置存放在当前正则reg的lastIndex里面，下次调用时，会从这次的最后位置开始查找。 总结通过上面简单的案例与说明，相信你已经可以看出我们要进行的增删改查操作应该用哪个方法了吧？我们来总结一下： 增：6个方法中，只有replace可以对匹配到的字符串进行操作，所以当我们需要在字符串中增加内容时，我们就可以使用replace方法。 删：6个方法中，split方法以匹配到的字符串为断点截断字符串返回数组，replace也可以对匹配到的字符串进行操作，所以删除可以使用split和replace方法。 查：6个方法中，除了split方法，都或多或少可以得到一些匹配到字符串的信息。 改：6个方法中，只有replace方法可以操作匹配到的字符串，所以修改只有用replace方法。 好了，下面详细的介绍下各种操作的详细情况。 1.增相信你一定遇到过往字符串里面加字符串的情况，你一般是怎么操作的呢？我们来分析下： 当向字符串中添加字符串时，有两种添加情况，一种：添加到匹配的字符串前，另一种是：添加到匹配的字符串后面。 是吧？？好，开始操作吧！ 添加到匹配字符串前：我们可以使用正则位置匹配表达式：(?=p)，正向肯定预查，其中p是一个子模式，即p前面的位置。 123var result = \"hello\".replace(/(?=ll)/g, '#')console.log(result)// =&gt; \"he#llo\" 也可以直接使用函数操作： 12345var result = \"hello\".replace(/(?=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"he#llo\" 添加到匹配字符串后：我们可以使用正则位置匹配表达式：(?&lt;=p)，反向肯定预查，就是p后面的位置。 12345var result = \"hello\".replace(/(?&lt;=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"hell#o\" 当然，你也可以直接使用replace的函数操作完成。 补充 在整个字符串前和后面添加， 12345var result = \"hello\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello#\" 在每个单词的前后面添加 12345var result = \"hello world\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello# #world#\" 2.删：经过我们前面的总结，删除可以使用String.split和String.replace完成。 String.splite可以知道，使用splite方法返回的是一个数组，操作后，我们可以使用join()函数，返回字符串 1234var str = \"aa22bb313cc444ff\"var reg = /\\d+/console.log( str.split( reg ).join(\"\") )// =&gt; \"aabbccff\" String.replace使用replace就非常简单了，我们可以把第二个参数传 &quot;&quot; ,也可以用函数操作，返回 &quot;&quot;即可。 12345var str = \"aa22bb313cc444ff\"var reg = /\\d+/g // 全局模式，不加全局模式，只会替换一次str = str.replace( reg, \"\" )console.log( str )// =&gt; \"aabbccff\" 3.查查找可以分为两类：一种是需要详细结果的，一种是不需要详细结果的。 不需要详细结果不需要详细结果就是返回 true 和 false 就可以了。这里可以使用test 验证电话号码123var reg = /^1[345789]\\d&#123;9&#125;$/var res = reg.test( \"13882628333\" )// =&gt; true 需要详细结果使用String.match()获取时间123var reg = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( \"2017-06-10\".match( reg ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var string = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( string.match( reg ))// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] match获取全部的颜色代码（正则使用g全局匹配模式）1234var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"console.log( str.match( reg ) )// =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 使用reg.exec()获取时间123var regex = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( reg.exec( \"2017-06-10\" ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var str = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( reg.exec( str ) )// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] exec获取全部的颜色代码（正则使用g全局匹配模式）12345678var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"var arr = []var tempwhile( temp = reg.exec( str ) )&#123; arr.push( temp[0] )&#125;console.log( arr ) 4.改经过前面的终结，我们知道只有replace可以进行修改操作： 1234567var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; return s1 + \"---\" + s2&#125;)console.log( str )// =&gt; \"aa22---bb313---cc444---ff\" 后记写下这篇文章，就是想让自己梳理下正则相关的api与用法，加强一下自己写正则的信心。 看了这篇文章，你是否对正则又有了新的理解呢？对自己写正则是否又增加了几分信心呢？ 总结本文主要讲述了正则的相关用法，考虑到正则新手，所以每个操作都只是做的很简单的案例，正则表达式大都很简单，但是，我相信，看了本文，你会更有信心去学习正则。 学习正则：如果你想学习正则表达式的书写，我这里将推荐一些好的文章给你： 老姚-JS正则表达式完整教程（略长） 非常推荐的一篇文章，我就是看这篇文章学习的正则，适合有一点正则基础的同学 考拉海前端团队—JS 的正则表达式 条理清晰–适合初学者学习正则的书写 文章在精不在多，这两篇文章对初学正则的同学非常友好，能引导你写出优秀的正则表达式，再结合这篇文章对正则表达式的运用，相信你会对正则的运用游刃有余。 参考资料：老姚-JS正则表达式完整教程（略长） MDN-String.prototype.match() MDN-String.prototype.replace() 共勉写下这篇文章，希望对你有帮助，与君共勉！","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"博客再次启程","slug":"博客再次启程","date":"2019-12-02T09:52:17.000Z","updated":"2020-01-06T01:52:59.673Z","comments":true,"path":"2019/12/02/博客再次启程/","link":"","permalink":"http://blog.curtaintan.club/2019/12/02/%E5%8D%9A%E5%AE%A2%E5%86%8D%E6%AC%A1%E5%90%AF%E7%A8%8B/","excerpt":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！","text":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！ 碎碎念经过一天的配置，博客搭建的差不多了， 整理好心情！！！ 重新出发！","categories":[{"name":"我的随笔","slug":"我的随笔","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.curtaintan.club/tags/%E7%94%9F%E6%B4%BB/"}],"author":{"avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png","url":"http://blog.curtaintan.club/"}},{"title":"drawing-board画板","slug":"drawing-board画板","date":"2019-08-14T08:04:55.000Z","updated":"2019-12-26T14:00:54.273Z","comments":true,"path":"2019/08/14/drawing-board画板/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/drawing-board%E7%94%BB%E6%9D%BF/","excerpt":"canvas写的画板","text":"canvas写的画板 快到碗里来-画板 预览：点击 前言： 之前学完canvas，一直想自己写一点东西，这两天终于完成了，开心！！ 完成功能： 绘画 画直线 截图 旋转 弹幕 鼠标触碰弹幕，弹幕悬停 撤销/前进 设置画笔信息 兼容移动端 功能截图： 前置说明如果你需要参考代码，你需要看下这里。因为功能复杂，标志的变量有接近10个之多，一下子可能很难看懂，所以我这里说明下我的开发流程，以及定义变量的顺序。 功能顺序： 画笔 → 定义画笔信息 → 橡皮檫 → 删除 → 撤销/前进 → 直线 → 截图 → 弹幕 定义变量的顺序，以及作用： 所有功能变量： 1234567891011121314151617181920212223242526272829303132333435363738var isDown = false // 标志鼠标是否按下 绘图三步和剪切三步走时，后面两个事件触发的标志var points = [] // 滑动时收集的点 绘画三步走时，为了时画的线光滑，记录点，减短画线的距离var beginPoint = null // 开始的点 绘画三步走时使用----这三个为一组，画线三人组，为了让画的线更为光滑var currentMenu = \"icon-pen\" // 初始按钮 底部按钮选中的按钮var currentColor = 0 // 初始颜色的index 颜色选择，默认第一个var paintingModal = \"pen\" // 画笔模式 line||pen||cut----按钮功能三人组，按钮选中标记，颜色选中，画画的模式，切换前面画笔和画直线的模式var lookModal = false // 鼠标模式 按钮第一个功能，此模式不能绘画，只能看var cuted = false // 标记裁剪时，是否已经裁剪 裁剪后，防止后续的操作再次触发裁剪操作 ----鼠标模式和剪切模式的定义var animationTimer = null // 弹幕动画的timer 动画的timervar barrageArray = [] // 保存弹幕的数组var globalPoint = &#123; x : 0, y : 0 &#125; // canvas上鼠标的点 ---弹幕时使用----弹幕三人组 globalPoint用来标记鼠标在canvas中的坐标，用于判断鼠标是否触碰到弹幕上// 实现撤销和重做的功能let canvasHistory = [] // canvas数据，在每次画线和橡皮檫使用后保存数据let step = 0 // 画笔抬起的步数，清空时，步数也清空----撤销/前进二人组，画笔抬起时，把画布信息用getImageData存入canvasHistory，用step完成前进和撤销的功能var penAttibutes = &#123; // 画笔数据， width : 2, lineCap : \"round\", lineJoin : \"round\", strokeStyle: \"#000\", fillStyle: \"#000\", globalCompositeOperation: \"source-over\", globalAlpha : 1&#125; 开发中遇到的难点与重点与解决方案： 保存历史记录使用api对比 我在写代码的时候有做过参考 这篇文章，文章里用是canvas.toDataUrl的方式做的数据保存，评论里说这个数据保存不理想，其实我一开始的时候想的就是用ctx.getImageDaata的方式来做的，我也用这个两个api做了一个对比： 代码： 结果： 可见，使用getImageData获取数据是时间是非常短的，并且获取到是画布像素数据，后续可以直接进行像素操作，从而不用再花时间再去获取画布信息，其次，getImageData获取到是数据是有数据结构的，这样在内存里面保存下来对内存更加友好，而使用toDataUrl方式保存下来的数据有21万行那么长的字符串，对内存并不友好。 后面我还做了他们绘制到画布上的时间对比，他们的时间都在1ms内，到时每次putImageData都要快一点点，但是快这一点时间的意义并不大。 toDataUrl也是有好处的，因为转置出来的是base64的字符串，所以他能够直接作为图片的src属性，让图片显示到页面。 画直线 如何画出一条直线？？当我做了撤销和前进的时候，我就把画板数据给存到canvasHistory里面了，这里刚好用到，鼠标移动是时候，先清空画布，再绘制保存到canvasHistory里最后那个数据，然后就是绘图三步走，就完成了。 注意：这里一定要绘图三步走，或者在绘制前一定要用beginPath()重开一条路径，如果不重开路径，绘制时，会把前面的直线一同绘制出来，因为你一直是一条路径，所以下次绘制时，上次的点也要绘制一遍。 图片旋转 旋转很类似css3，但是，canvas的基点固定在左上角处，所以在旋转的时候，需要先用translate移动画板，可以画一下图， 下面是我画的图： 问题： 当我画笔有rotate属性的时候，当前操作的putImageData不会成功，不知道为什么----- 如何画出一条光滑的曲线 用正常的画法画曲线是时候，画出的曲线不够光滑， 所以我就参考了这篇文章 canvas进阶——如何画出平滑的曲线? （其实我也想到了用二次贝塞尔曲线，在寻找更好的解决方案时，就找到这个方法了，这个方案更优），原理可以看原文。 鼠标触摸弹幕 因为canvas是无记忆性的，所以，你用isPointPath和isPointStroke时，是在当前绘画下才能检测。 在使用isPointPath时，他只与path路径有关，意思就是，你用fillRect直接绘制一个矩形图形是不能检测的， 只能检测rect()和pathTo等围起来的路径内。 所以，这里我做了一个外挂路径-用rect()把每个弹幕框起来——哈哈– 使用drawImage须知： drawImage有三种传参方式，三种方式出来的效果，在书写前可以先参考效果。 参考地址：CanvasRenderingContext2D.drawImage 兼容移动端 当在移动端时，会存在移动端延时300ms的问题，因为移动端有双击放大功能，故存在300ms时间。 我解决的方法是设置meta信息，禁止缩放，就可以防止300ms问题 结语：这个项目大概用了canvas的75%的api，还有像素操作和渐变等api还没用到。 不知道有没有人看呢， 如果你看到了这篇文章，希望对你有帮助。 慢慢来，好好学习，要加油哦！ 与君共勉！！ 参考材料： 手把手教你实现一个canvas智绘画板 参考了楼主项目的样式，但是所有样式都是我自己写的，嘻嘻，实现方式不一样哦。。 canvas进阶——如何画出平滑的曲线? 画一条光滑的曲线，不错哦。 canvas动画包教不包会 可以在这里把所有api的意义和作用和参数等都记下来—– Canvas API中文文档首页地图 canvas所有的api，当然你也可以去mdn看，其实都一样啦—","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://blog.curtaintan.club/tags/canvas/"},{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"正则小记（一）之api速学","slug":"正则小记（一）之api速学","date":"2019-08-14T08:04:55.000Z","updated":"2020-01-02T04:43:51.427Z","comments":true,"path":"2019/08/14/正则小记（一）之api速学/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8Bapi%E9%80%9F%E5%AD%A6/","excerpt":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章…","text":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章… 前言正则，用简短的一句话概括，正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则的方法和与正则有关的方法共有6个，字符串实例4个，正则实例2个： String#search String#split String#match String#replace RegExp#test RegExp#exec 1.search()定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1234var regex = /\\d/;var string = \"abc123\";console.log( string.search(regex) );// =&gt; 3 2.split定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 例子： 1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.match定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则： 匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( string.match(regex) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 4.replace语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. replace后面单独写一篇文章总结 案例： 12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";var date = [];string.replace(regex, function(match, year, month, day) &#123; date.push(year, month, day);&#125;);console.log(date);// =&gt; [\"2017\", \"06\", \"26\"] 5.test说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1234var regex = /\\d/;var string = \"abc123\";console.log( regex.test(string) );// =&gt; true 6.exec说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 这个方法很类似match方法。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( regex.exec(string) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 相关API注意要点-1 search和match的参数问题我们知道字符串实例的那4个方法参数都支持正则和字符串。 但search和match，会把字符串转换为正则的。 1234567891011121314151617181920212223var string = \"2017.06.27\";console.log( string.search(\".\") );// =&gt; 0//需要修改成下列形式之一console.log( string.search(\"\\\\.\") );console.log( string.search(/\\./) );// =&gt; 4// =&gt; 4console.log( string.match(\".\") );// =&gt; [\"2\", index: 0, input: \"2017.06.27\"]//需要修改成下列形式之一console.log( string.match(\"\\\\.\") );console.log( string.match(/\\./) );// =&gt; [\".\", index: 4, input: \"2017.06.27\"]// =&gt; [\".\", index: 4, input: \"2017.06.27\"]console.log( string.split(\".\") );// =&gt; [\"2017\", \"06\", \"27\"]console.log( string.replace(\".\", \"/\") );// =&gt; \"2017/06.27\" 2 match返回结果的格式问题match返回结果的格式，与正则对象是否有修饰符g有关。 1234567var string = \"2017.06.27\";var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; [\"2017\", \"06\", \"27\"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有g，返回的是所有匹配的内容。 3 exec比match更强大当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。 而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配： 123456789101112131415161718var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"]// =&gt; 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"] 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"] 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"] 10 4 修饰符g，对exex和test的影响上面提到了正则实例的lastIndex属性，表示尝试匹配时，从字符串的lastIndex位开始去匹配。 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。 而正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。下面让我们以test为例，看看你是否会迷糊： 1234567var regex = /a/g;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 1// =&gt; true 3// =&gt; false 0 注意上面代码中的第三次调用test，因为这一次尝试匹配，开始从下标lastIndex即3位置处开始查找，自然就找不到了。 如果没有g，自然都是从字符串第0个字符处开始尝试匹配： 1234567var regex = /a/;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 0// =&gt; true 0// =&gt; true 0 5 test整体匹配时需要使用^和$这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： 123456console.log( /123/.test(\"a123b\") );// =&gt; trueconsole.log( /^123$/.test(\"a123b\") );// =&gt; falseconsole.log( /^123$/.test(\"123\") );// =&gt; true 6 split相关注意事项split方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： 123var string = \"html,css,javascript\";console.log( string.split(/,/, 2) );// =&gt;[\"html\", \"css\"] 7 replace是很强大的 《JavaScript权威指南》认为exec是这6个API中最强大的，而我始终认为replace才是最强大的。 因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号例如，把”2,3,5”，变成”5=2+3”： 123var result = \"2,3,5\".replace(/(\\d+),(\\d+),(\\d+)/, \"$3=$1+$2\");console.log(result);// =&gt; \"5=2+3\" 又例如，把”2,3,5”，变成”222,333,555”: 123var result = \"2,3,5\".replace(/(\\d+)/g, \"$&amp;$&amp;$&amp;\");console.log(result);// =&gt; \"222,333,555\" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”: 123var result = \"2+3=5\".replace(/=/, \"$&amp;$`$&amp;$'$&amp;\");console.log(result);// =&gt; \"2+3=2+3=5=5\" 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： 123456\"1234 2345 3456\".replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function(match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; [\"1234\", \"1\", \"4\", 0, \"1234 2345 3456\"]// =&gt; [\"2345\", \"2\", \"5\", 5, \"1234 2345 3456\"]// =&gt; [\"3456\", \"3\", \"6\", 10, \"1234 2345 3456\"] 此时我们可以看到replace拿到的信息，并不比exec少。 8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多\\。 12345678var string = \"2017-06-27 2017.06.27 2017/06/27\";var regex = /\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/g;console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"]regex = new RegExp(\"\\\\d&#123;4&#125;(-|\\\\.|\\\\/)\\\\d&#123;2&#125;\\\\1\\\\d&#123;2&#125;\", \"g\");console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"] 9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline10 source属性正则实例对象属性，除了global、ingnoreCase、multiline、lastIndex属性之外，还有一个source属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： 1234var className = \"high\";var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\");console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串\"(^|\\\\s)high(\\\\s|$)\" 11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是$1,…,$9之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp[&quot;$&apos;&quot;]测试代码如下： 1234567891011121314151617181920212223var regex = /([abc])(\\d)/g;var string = \"a1b2c3d4e5\";string.match(regex);console.log( RegExp.input );console.log( RegExp[\"$_\"]);// =&gt; \"a1b2c3d4e5\"console.log( RegExp.lastMatch );console.log( RegExp[\"$&amp;\"] );// =&gt; \"c3\"console.log( RegExp.lastParen );console.log( RegExp[\"$+\"] );// =&gt; \"3\"console.log( RegExp.leftContext );console.log( RegExp[\"$`\"] );// =&gt; \"a1b2\"console.log( RegExp.rightContext );console.log( RegExp[\"$'\"] );// =&gt; \"d4e5\" 结语： 我搜查列出了相关的6个方法，并对6个方法进行了说明。 后面我会对replace再单独出一篇文章。 参考资料里的第一篇文章真的非常好，值得仔细研读。 如果你想粗略了解正则的方法，看我这篇文章是没错了，后面列出的相应方法的坑点和注意点。 后面，我会再慢慢补充匹配规则，我会单独列出一篇文章，因为匹配规则也有很多注意点呢。 哈哈哈，其实也是在下面的文章里面看的啦，文章真的写得好---嘻嘻 其实正则也没有那么难的啦----- 希望这篇文章对你有帮助，每天都要加油哦。 加油，与君共勉！！！参考资料： JS正则表达式完整教程（略长） 文章真的写的不错，认认真真，细嚼慢咽的看完这篇文章，保证你学会正则。 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。 MDN-RegExp MDN-String","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]}]}