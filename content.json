{"meta":{"title":"curTain","subtitle":"","description":"","author":"tanTantan","url":"http://blog.curtaintan.club","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-02T08:25:53.803Z","updated":"2019-12-02T08:25:53.803Z","comments":true,"path":"404.html","permalink":"http://blog.curtaintan.club/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-12-26T14:01:07.399Z","updated":"2019-12-26T14:01:07.399Z","comments":true,"path":"about/index.html","permalink":"http://blog.curtaintan.club/about/index.html","excerpt":"","text":"云淡风轻、 关于我：目前就读于成都大学，大三 热爱的： coding 探索 前端 科技 电子产品 技术栈： js flutter nodejs mysql 愿望： 打造一个多端的app 和好朋友们一起吃好多好吃的 和好朋友们一起去海边看海 有自己热爱的东西，平静简单的生活.. 欢迎灌水"},{"title":"所有分类","date":"2019-12-26T14:01:52.812Z","updated":"2019-12-26T14:01:52.812Z","comments":true,"path":"categories/index.html","permalink":"http://blog.curtaintan.club/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-03T08:42:54.518Z","updated":"2019-12-03T08:42:54.518Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.curtaintan.club/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-03T08:46:42.440Z","updated":"2019-12-03T08:46:42.440Z","comments":true,"path":"tags/index.html","permalink":"http://blog.curtaintan.club/tags/index.html","excerpt":"","text":""},{"title":"我的收藏夹","date":"2020-01-31T06:03:52.343Z","updated":"2020-01-31T06:03:52.343Z","comments":true,"path":"favorite/index.html","permalink":"http://blog.curtaintan.club/favorite/index.html","excerpt":"","text":"图床又拍图床speed路过图床(稳定、推荐使用) 前端面试题 前端 100 问：能搞懂 80% 的请把简历给我 sequelize一点通 Sequelize 快速入门 Sequelize 系列教程之一对一模型关系 Sequelize 系列教程之一对多模型关系 Sequelize 系列教程之多对多模型关系 色彩搭配Paleetes 大家有什么好的东西，可以在下面给我留言...."},{"title":"我的朋友们","date":"2020-02-06T02:23:42.801Z","updated":"2020-02-06T02:23:42.801Z","comments":true,"path":"friends/index.html","permalink":"http://blog.curtaintan.club/friends/index.html","excerpt":"","text":""},{"title":"我的作品","date":"2020-02-06T06:13:38.748Z","updated":"2020-02-06T06:13:38.748Z","comments":true,"path":"projects/index.html","permalink":"http://blog.curtaintan.club/projects/index.html","excerpt":"","text":"2020.1 little chat 一直都想重构之前的chatGo聊天项目，终于重构了！开心… Features： 使用create-react-app构建 hooks redux + redux-saga 状态管理 使用immutable.js 适配移动端 私聊 群聊 申请加群 支持发送图片和emoji 服务端： socket.io搭配koa2 使用单例模式管理状态 使用函数柯理接收参数 一开始用dva构建的项目，后来用create-react-app重构了项目： react版本：react版本预览dva简化版本：dva版本预览地址源码地址：github 2019.11 nextGo使用nextjs搭配koa2搭建的仿写github的ssr项目，项目使用github接口，使用OAuth进行登录。 Features： 使用nextjs构建 使用hooks 使用redux管理状态 集成koa2 使用HOC定制props 接入github—OAuth 使用webpack-bundle-analyzer分析打包依赖 预览地址：nextGo源码地址：github打包分析：点击直达 2019.9 fabric-board 用fabric.js重写的面向对象的画板 使用了同学（胡翔）的ipad和配套的Apple Pencil，体验了记事本的功能，突发奇想，我就实现了一下，使用图层对象的形式来开发画板，体验还是不错的。 这个项目从开始构想，到大体完成只花了两天，后面在完善获取图层组，然后将图层组单独拿出来渲染到右侧的小canvas上的时候，出现了问题， 断断续续的写了下，还是没有解决。 Features： fabric.js canvas vue 图层式操作 预览地址：fabricGo源码地址：github 2019.8 canvasGo 使用canvas构建的画板项目，原生js操作。 Features： 原生js canvas 兼容手机端 拥有发送弹幕功能 截图功能 截图可旋转 撤销/前进 预览地址：canvasGo源码地址：github配套文章：快到碗里来 2019.6 electron-music 是学习electron的小demo吧，后面一定会推出electron的更完善的应用的。 Features： electron 原生js 桌面应用 本地数据缓存 源码地址：github 2019.5 网易云Go 使用flutter构建的模仿网易云音乐app，界面还原度很高， Features： flutter构建 播放视频与vedio 播放音乐 导航栏级联滑动 搜索提示 节流操作 provide状态管理 组件式开发 源码地址：github下载地址： 安卓下载：点我下载 扫码下载： ios：由于没有ios手机和mac，所以没有打包ios版本 2019.3 知程 使用原生小程序构建，工作室团队项目， Features： 微信小程序 城市级联 flex布局 源码地址：github 2018.10 chatGo 使用socket.io搭配express搭建而成的在线聊天系统，后面会使用框架搭建一个更全面，界面更友好的在线聊天系统， Features： socket.io构建而成 bootstrap栅格系统 源码地址：github预览地址：chatGo 2018.10 小小论坛 这是最初的作品，也是心心念念想要去完成的作品，最初是版本是留言板，后来一再一再的扩展，就变成了这样的一个论坛了。其实蛮喜欢这个作品的，最近也在重构中，也在试图添加更多功能… Features： vuejs、vuex、vue-router全家桶 quill富文本编辑器 路由守卫 token鉴权 源码地址：github预览地址：点击直达"}],"posts":[{"title":"思路清晰--前端性能优化","slug":"思路清晰-前端性能优化","date":"2020-02-14T01:25:00.000Z","updated":"2020-02-14T02:18:57.932Z","comments":true,"path":"2020/02/14/思路清晰-前端性能优化/","link":"","permalink":"http://blog.curtaintan.club/2020/02/14/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"1. 原则 多使用内存、缓存或其他方法来存储 减少 cpu 计算，减少 http 网络请求 2. 从哪里入手 加载页面和静态资源 页面渲染 2.1 加载资源优化 静态资源的压缩和合并 静态资源缓存 使用 CDN 让资源加载更快 使用 SSR 后端渲染，数据直接输出到 HTML 中 2.2 渲染优化 CSS 放前面，JS 放后面 懒加载（图片懒加载、下拉加载更多） 减少 DOM 查询，对 DOM 查询做缓存 减少 DOM 操作，多个操作尽量合并在一起执行（例如：插入列表） 使用事件节流与防抖 尽早执行操作（ 如：DOMContentLoaded ） 3. 总结简略的概述了一下前端性能的优化。 4. 资源推荐框架打包优化 🚀 记一次前端性能优化 前端性能优化最佳实践","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://blog.curtaintan.club/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"[转载]webpack优化","slug":"[转载]-webpack优化","date":"2020-02-12T15:43:31.000Z","updated":"2020-02-12T15:44:32.236Z","comments":true,"path":"2020/02/12/[转载]-webpack优化/","link":"","permalink":"http://blog.curtaintan.club/2020/02/12/[%E8%BD%AC%E8%BD%BD]-webpack%E4%BC%98%E5%8C%96/","excerpt":"","text":"webpack各种优化上一章节我们已经掌握了webpack常见的所有配置 这一节我们来看看如何实现webpack中的优化，我们先来编写最基本的webpack配置，然后依次实现各种优化！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const path = require(\"path\");module.exports = mode =&gt; &#123; return &#123; mode: mode, entry: \"./src/main.js\", output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") &#125;, module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: \"file-loader\" &#125;, &#123; test: /\\.js$/, use: \"babel-loader\" // .babelrc已经配置支持react &#125;, &#123; test: /\\.css$/, use: [ mode !== \"development\" ? MiniCssExtractPlugin.loader : \"style-loader\", \"css-loader\" ] &#125; ] &#125;, plugins: [ new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;path.join(__dirname, \"src\")&#125;/**/*`, &#123; nodir: true &#125;) // 不匹配目录，只匹配文件 &#125;), mode !== \"development\" &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].css\" &#125;), new HtmlWebpackPlugin(&#123; template: \"./src/template.html\", filename: \"index.html\" &#125;) ].filter(Boolean) &#125;;&#125;; .babelrc配置文件 123456&#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ]&#125; 1.删除无用的Css样式先来看编写的代码 1234import './style.css'import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;div&gt;hello&lt;/div&gt;,document.getElementById('root')); 123456body&#123; background: red&#125;.class1&#123; background: red&#125; 这里的.class1显然是无用的，我们可以搜索src目录下的文件，删除无用的样式 1234567const glob = require('glob');const PurgecssPlugin = require('purgecss-webpack-plugin');// 需要配合mini-css-extract-plugin插件mode !== \"development\" &amp;&amp; new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;path.join(__dirname, \"src\")&#125;/**/*`, &#123; nodir: true &#125;) // 不匹配目录，只匹配文件&#125;), 2.图片压缩插件将打包后的图片进行优化 1npm install image-webpack-loader --save-dev 在file-loader之前使用压缩图片插件 12345678910111213141516171819202122loader: \"image-webpack-loader\",options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, // optipng.enabled: false will disable optipng optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: [0.90, 0.95], speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125;, // the webp option will enable WEBP webp: &#123; quality: 75 &#125;&#125; 可以发现图片大小是有了明显的变化 3.CDN加载文件我们希望通过cdn的方式引入资源 1234const AddAssetHtmlCdnPlugin = require('add-asset-html-cdn-webpack-plugin')new AddAssetHtmlCdnPlugin(true,&#123; 'jquery':'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'&#125;) 但是在代码中还希望引入jquery来获得提示 12import $ from 'jquery'console.log('$',$) 但是打包时依然会将jquery进行打包 123externals:&#123; 'jquery':'$'&#125; 在配置文件中标注jquery是外部的，这样打包时就不会将jquery进行打包了 4.Tree-shaking &amp;&amp; Scope-Hoisting4.1 Tree-shaking顾名思义就是将没用的内容摇晃掉,来看下面代码 main.js 12import &#123; minus &#125; from \"./calc\";console.log(minus(1,1)); calc.js 1234567import &#123;test&#125; from './test';export const sum = (a, b) =&gt; &#123; return a + b + 'sum';&#125;;export const minus = (a, b) =&gt; &#123; return a - b + 'minus';&#125;; test.js 1234export const test = ()=&gt;&#123; console.log('hello')&#125;console.log(test()); 观察上述代码其实我们主要使用minus方法,test.js代码是有副作用的! 默认mode:production时，会自动tree-shaking,但是打包后&#39;hello&#39;依然会被打印出来,这时候我们需要配置不使用副作用 在package.json中配置 1\"sideEffects\":false, 如果这样设置，默认就不会导入css文件啦，因为我们引入css也是通过import &#39;./style.css&#39; 这里重点就来了,tree-shaking主要针对es6模块,我们可以使用require语法导入css,但是这样用起来有点格格不入,所以我们可以配置css文件不是副作用 123\"sideEffects\":[ \"**/*.css\"] 在开发环境下默认tree-shaking不会生效,可以配置标识提示 123optimization:&#123; usedExports:true &#125; 4.2 Scope Hoisting作用域提升,可以减少代码体积，节约内存 12345678let a = 1;let b = 2;let c = 3;let d = a+b+cexport default d;// 引入dimport d from './d';console.log(d) 最终打包后的结果会变成 console.log(6) 代码量明显减少 减少多个函数后内存占用也将减少 5.DllPlugin &amp;&amp; DllReferencePlugin每次构建时第三方模块都需要重新构建，这个性能消耗比较大，我们可以先把第三方库打包成动态链接库，以后构建时只需要查找构建好的库就好了，这样可以大大节约构建时间 1234import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;h1&gt;hello&lt;/h1&gt;,document.getElementById('root')) 5.1 DllPlugin 这里我们可以先将react、react-dom单独进行打包 单独打包创建webpack.dll.js 1234567891011121314151617const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; entry:['react','react-dom'], mode:'production', output:&#123; filename:'react.dll.js', path:path.resolve(__dirname,'dll'), library:'react' &#125;, plugins:[ new DllPlugin(&#123; name:'react', path:path.resolve(__dirname,'dll/manifest.json') &#125;) ]&#125; 执行&quot;webpack --config webpack.dll.js命令，可以看到dll目录下创建了两个文件分别是manifest.json,react.dll.js 关系是这个酱紫的，到时候我们会通过manifest.json找到react.dll.js文件中的模块进行加载 5.2 DllReferencePlugin在我们的项目中可以引用刚才打包好的动态链接库 12345678910const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');// 构建时会引用动态链接库的内容new DllReferencePlugin(&#123; manifest:path.resolve(__dirname,'dll/manifest.json')&#125;),// 需要手动引入react.dll.jsnew AddAssetHtmlWebpackPlugin( &#123; filepath: path.resolve(__dirname,'dll/react.dll.js') &#125;) 使用DllPlugin可以大幅度提高构建速度 6.动态加载实现点击后动态加载文件 12345678let btn = document.createElement('button');btn.innerHTML = '点击加载视频';btn.addEventListener('click',()=&gt;&#123; import('./video').then(res=&gt;&#123; console.log(res.default); &#125;);&#125;);document.body.appendChild(btn); 给动态引入的文件增加名字 123456output:&#123; chunkFilename:'[name].min.js'&#125;import(/* webpackChunkName: \"video\" */ './video').then(res=&gt;&#123; console.log(res.default);&#125;) 这样打包后的结果最终的文件就是 video.min.js 7.打包文件分析工具安装webpack-bundle-analyzer插件 1npm install --save-dev webpack-bundle-analyzer 使用插件 12const &#123;BundleAnalyzerPlugin&#125; = require('webpack-bundle-analyzer');mode !== \"development\" &amp;&amp; new BundleAnalyzerPlugin() 默认就会展现当前应用的分析图表 8.SplitChunks我们在来看下SplitChunks这个配置，他可以在编译时抽离第三方模块、公共模块 将项目配置成多入口文件 1234entry:&#123; a:'./src/a.js', b:'./src/b.js'&#125; 我们让a,b两个模块同时引用jquery,别忘了去掉之前的externals配置 配置SplitChunks插件 默认配置在此，我一个个描述下含义 12345678910111213141516171819202122splitChunks: &#123; chunks: 'async', // 分割异步模块 minSize: 30000, // 分割的文件最小大小 maxSize: 0, minChunks: 1, // 引用次数 maxAsyncRequests: 5, // 最大异步请求数 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 抽离的命名分隔符 automaticNameMaxLength: 30, // 名字最大长度 name: true, cacheGroups: &#123; // 缓存组 vendors: &#123; // 先抽离第三方 test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, // 优先级 reuseExistingChunk: true &#125; &#125;&#125; 我们将async改为initial 我们在为每个文件动态导入lodash库,并且改成async 1import('lodash') 为每个入口引入c.js,并且改造配置文件 123456789101112131415splitChunks: &#123; chunks: 'all', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minSize:1, // 不是第三方模块，被引入两次也会被抽离 minChunks: 2, priority: -20, &#125; &#125;&#125; 这样再反过来看chunks的参数是不是就了然于胸啦！ 9.热更新模块热替换（HMR - Hot Module Replacement）是 webpack 提供的最有用的功能之一。它允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面 保留在完全重新加载页面时丢失的应用程序的状态 只更新改变的内容，以节省开发时间 调整样式更加快速，几乎等同于就在浏览器调试器中更改样式 启用热更新，默认样式可以支持热更新，如果不支持热更新则采用强制刷新 1234devServer:&#123; hot:true&#125;new webpack.NamedModulesPlugin(), 让js支持热更新 12345import sum from './sum';console.log(sum(1,2));if(module.hot)&#123; // 如果支持热更新 module.hot.accept(); // 当入口文件变化后重新执行当前入口文件&#125; 10.IgnorePlugin忽略 import和require语法 1new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) 11.费时分析可以计算每一步执行的运行速度 1234const SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin');const smw = new SpeedMeasureWebpackPlugin(); module.exports =smw.wrap(&#123;&#125;); 12.noParsemodule.noParse，对类似jq这类依赖库，内部不会引用其他库，我们在打包的时候就没有必要去解析，这样能够增加打包速率 1noParse:/jquery/ 13.resolve12345resolve: &#123; extensions: [\".js\",\".jsx\",\".json\",\".css\"], alias:&#123;&#125;, modules:['node_modules']&#125;, 14.include/exclude在使用loader时,可以指定哪些文件不通过loader,或者指定哪些文件通过loader 123456&#123; test: /\\.js$/, use: \"babel-loader\", // include:path.resolve(__dirname,'src'), exclude:/node_modules/&#125;, 15.happypack多线程打包，我们可以将不同的逻辑交给不同的线程来处理 1npm install --save-dev happypack 使用插件 1234567891011121314151617181920212223const HappyPack = require('happypack');rules:[ &#123; test: /\\.js$/, use: 'happypack/loader?id=jsx' &#125;, &#123; test: /\\.less$/, use: 'happypack/loader?id=styles' &#125;,]new HappyPack(&#123; id: 'jsx', threads: 4, loaders: [ 'babel-loader' ]&#125;),new HappyPack(&#123; id: 'styles', threads: 2, loaders: [ 'style-loader', 'css-loader', 'less-loader' ]&#125;)","categories":[{"name":"转载","slug":"转载","permalink":"http://blog.curtaintan.club/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"webpack","slug":"转载/webpack","permalink":"http://blog.curtaintan.club/categories/%E8%BD%AC%E8%BD%BD/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.curtaintan.club/tags/webpack/"}]},{"title":"[转载]从0搭建自己的webpack开发环境（二）","slug":"[转载]-从0搭建自己的webpack开发环境（二）","date":"2020-02-12T15:37:37.000Z","updated":"2020-02-12T15:52:07.386Z","comments":true,"path":"2020/02/12/[转载]-从0搭建自己的webpack开发环境（二）/","link":"","permalink":"http://blog.curtaintan.club/2020/02/12/[%E8%BD%AC%E8%BD%BD]-%E4%BB%8E0%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Webpack中必须掌握的配置loader主要用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块！通过使用不同的Loader，Webpack可以把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等。 我们来看看这些我们必须掌握的loader! 1.loader的编写1.1 loader的使用 test：匹配处理文件的扩展名的正则表达式 use：loader名称，就是你要使用模块的名称 include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 options:为loaders提供额外的设置选项 默认loader的顺序是从下到上、从右向左执行，当然执行顺序也可以手动定义的，接下来我们依次介绍常见的loader，来感受loader的魅力! 我们基于这个基础配置来继续编写: 123456789101112131415161718192021222324252627282930313233const path = require(\"path\");const dev = require(\"./webpack.dev\");const prod = require(\"./webpack.prod\");const merge = require(\"webpack-merge\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const base = &#123; entry:'./src/index.js', output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"../dist\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: &#123; removeAttributeQuotes: true &#125; &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: [path.resolve('xxxx/*'),'**/*'], &#125;), ]&#125;;module.exports = env =&gt; &#123; if (env.development) &#123; return merge(base, dev); &#125; else &#123; return merge(base, prod); &#125;&#125;; 2.处理CSS文件2.1 解析css样式我们在js文件中引入css样式！ 1import './index.css'; 再次执行打包时，会提示css无法解析 123ERROR in ./src/index.css 1:4Module parse failed: Unexpected token (1:4)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders 安装loader 1npm install style-loader css-loader --save-dev 12345678module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ]&#125; 2.2 抽离样式文件默认只在打包时进行样式抽离 123456789module.exports = env =&gt; &#123; let isDev = env.development; const base = &#123;/*source...*/&#125; if (isDev) &#123; return merge(base, dev); &#125; else &#123; return merge(base, prod); &#125;&#125;; 安装抽离插件 1npm install mini-css-extract-plugin --save-dev 配置抽离插件 1234567891011&#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\" ].filter(Boolean)&#125;!isDev &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].css\"&#125;) 最终文件配置贴一下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const path = require(\"path\");const dev = require(\"./webpack.dev\");const prod = require(\"./webpack.prod\");const merge = require(\"webpack-merge\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = env =&gt; &#123; let isDev = env.development; const base = &#123; entry: \"./src/index.js\", output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"../dist\") &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\" ].filter(Boolean) &#125; ] &#125;, plugins:[ !isDev &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].css\" &#125;), new HtmlWebpackPlugin(&#123; filename: \"index.html\", template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: &#123; removeAttributeQuotes: true &#125; &#125;), ].filter(Boolean) &#125;; if (isDev) &#123; return merge(base, dev); &#125; else &#123; return merge(base, prod); &#125;&#125;; 2.3 css预处理器不同的css预处理器要安装不同的loader来进行解析 sass: sass-loader node-sass less: less-loader less stylus: stylus-loader stylus 使用sass 123456789&#123; test:/\\.scss$/, use:[ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\", \"sass-loader\" ].filter(Boolean)&#125; 在css文件中可能会使用@import语法引用css文件,被引用的css文件中可能还会导入scss 1234567891011121314&#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', &#123; loader:\"css-loader\", options:&#123; importLoaders:1 // 引入的文件需要调用sass-loader来处理 &#125; &#125;, \"sass-loader\" ].filter(Boolean)&#125;, 2.4 处理样式前缀使用postcss-loader增加样式前缀 1npm install postcss-loader autoprefixer 在处理css前先增加前缀 123456789101112131415 &#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', &#123; loader:\"postcss-loader\", options:&#123; plugins:[require('autoprefixer')] &#125; &#125;, \"postcss-loader\", \"sass-loader\" ].filter(Boolean)&#125;, 或者也可以创建postcss的配置文件postcss.config.js 12345module.exports = &#123; plugins:[ require('autoprefixer') ]&#125; 可以配置浏览器的兼容性范围 .browserslistrc 1cover 99.5% 2.5 css压缩在生产环境下我们需要压缩css文件,配置minimizer选项,安装压缩插件 1npm i optimize-css-assets-webpack-plugin terser-webpack-plugin --save-dev 在webpack.prod.js文件中配置压缩 12345const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');const TerserJSPlugin = require('terser-webpack-plugin');optimization:&#123; minimizer:[new TerserJSPlugin(&#123;&#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)]&#125; 2.6 文件指纹 Hash整个项目的hash值 chunkhash 根据入口产生hash值 contentHash 根据每个文件的内容产生的hash值 我们可以合理的使用hash戳，进行文件的缓存 123!isDev &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].[contentHash].css\"&#125;) 3.处理文件类型3.1 处理引用的图片1234import logo from './webpack.png';let img = document.createElement('img');img.src = logo;document.body.appendChild(img); 使用file-loader,会将图片进行打包，并将打包后的路径返回 123456789&#123; test:/\\.jpe?g|png|gif/, use:&#123; loader:'file-loader', options:&#123; name:`img/[name].[ext]` &#125; &#125;&#125; 3.2 处理icon二进制文件也是使用file-loader来打包 123456&#123; test:/woff|ttf|eot|svg|otf/, use:&#123; loader:'file-loader' &#125;&#125; 3.3 转化成base64使用url-loader将满足条件的图片转化成base64,不满足条件的url-loader会自动调用file-loader来进行处理 12345678910&#123; test:/\\.jpe?g|png|gif/, use:&#123; loader:'url-loader', options:&#123; limit:100*1024, name:`img/[name].[ext]` &#125; &#125;&#125; 4.处理JS模块4.1 将es6代码编译成es5代码代码的转化工作要交给babel来处理 1npm install @babel/core @babel/preset-env babel-loader --save-dev @babel/core是babel中的核心模块，@babel/preset-env 的作用是es6转化es5插件的插件集合，babel-loader是webpack和loader的桥梁。 123const sum = (a, b) =&gt; &#123; return a + b;&#125;; 增加babel的配置文件 .babelrc 12345&#123; \"presets\": [ [\"@babel/preset-env\"] ]&#125; 配置loader 123module: &#123; rules: [&#123; test: /\\.js$/, use: \"babel-loader\" &#125;]&#125;, 现在打包已经可以成功的将es6语法转化成es5语法！ 4.2 解析装饰器1npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators --save-dev 1234\"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], [\"@babel/plugin-proposal-class-properties\",&#123;\"loose\":true&#125;]] legacy:true表示继续使用装饰器装饰器，loose为false时会采用Object.defineProperty定义属性 Plugin会运行在Preset之前 Plugin 会从第一个开始顺序执行，Preset则是相反的 4.3 polyfill根据.browserslistrc文件，转化使用到的浏览器api 123456\"presets\": [ [\"@babel/preset-env\",&#123; \"useBuiltIns\":\"usage\", // 按需加载 \"corejs\":2 // corejs 替代了以前的pollyfill &#125;]] 安装corejs 1npm install core-js@2 --save 使用transform-runtimeA plugin that enables the re-use of Babel’s injected helper code to save on codesize.可以帮我们节省代码 1npm install --save-dev @babel/plugin-transform-runtime @babel/runtime 在.babelrc中配置插件 123\"plugins\": [ \"@babel/plugin-transform-runtime\"] 4.4 添加eslint安装eslint 12npm install eslintnpx eslint --init # 初始化配置文件 12345&#123; test:&#x2F;\\.js&#x2F;, enforce:&#39;pre&#39;, use:&#39;eslint-loader&#39;&#125;, 配置eslint-loader可以实时校验js文件的正确性,pre表示在所有loader执行前执行 5.source-map eval 生成代码 每个模块都被eval执行,每一个打包后的模块后面都增加了包含sourceURL source-map 产生map文件 inline 不会生成独立的 .map文件,会以dataURL形式插入 cheap 忽略打包后的列信息，不使用loader中的sourcemap module 没有列信息，使用loader中的sourcemap(没有列信息) 1devtool:isDev?'cheap-module-eval-source-map':false 每个库中采用的sourcemap方式不一,可以根据自己的需要自行配置 6.resolve解析想实现使用require或是import的时候,可以自动尝试添加扩展名进行匹配 123resolve: &#123; extensions: [\".js\", \".jsx\", \".json\", \".css\", \".ts\", \".tsx\", \".vue\"]&#125;, 7.拷贝静态文件有些时候在打包时希望将一些静态资源文件进行拷贝,可以使用copy-webpack-plugin 安装插件 1npm i copy-webpack-plugin --save-dev 使用拷贝插件 1234const CopyWebpackPlugin = require('copy-webpack-plugin');new CopyWebpackPlugin([ &#123;from:path.resolve('./src/static'),to:path.resolve('./dist')&#125;,]) 8.配置TS环境8.1 使用ts-loader使用ts需要安装ts相关配置 1npm install typescript ts-loader --save-dev 生成ts的配置文件 1npx tsc --init 配置ts-loader 12345&#123; test:/\\.tsx?/, use: ['ts-loader'], exclude: /node_modules/&#125; 将入口文件更改成ts文件 12let a:string = 'hello';console.log(a); 执行npm run dev发现已经可以正常的解析ts文件啦！ 8.2 使用 preset-typescript不需要借助typescript 1npm install @babel/preset-typescript 1234567891011121314151617&#123; \"presets\": [ [\"@babel/preset-env\",&#123; \"useBuiltIns\":\"usage\", \"corejs\":2 &#125;], \"@babel/preset-react\", [\"@babel/preset-typescript\",&#123; \"allExtensions\": true &#125;] ], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], [\"@babel/plugin-proposal-class-properties\",&#123;\"loose\":true&#125;], \"@babel/plugin-transform-runtime\" ]&#125; 9.配置ts+react环境安装react相关模块 12npm i @babel/preset-react --save-dev # 解析jsx语法npm i react @types/react @types/react-dom react react-dom typescript 1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';const state = &#123;number:0&#125;;type State = Readonly&lt;typeof state&gt;;class Counter extends React.Component&lt;object,State&gt;&#123; state:State = state handleClick =()=&gt;&#123; this.setState(&#123;number:this.state.number+1&#125;) &#125; render()&#123; const &#123;number&#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt; &#123;number&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;,document.getElementById('root')); 10.配置ts+vue环境安装vue所需要的模块 12npm install vue-loader vue-template-compiler --save-devnpm install vue vue-property-decorator 配置ts-loader 12345678910&#123; test: /\\.tsx?/, use: &#123; loader:'ts-loader', options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;, &#125;, exclude: /node_modules/&#125; 使用vue-loader插件 12const VueLoaderPlugin = require('vue-loader/lib/plugin');new VueLoaderPlugin(); 配置解析.vue文件 1234&#123; test:/\\.vue$/, use:'vue-loader'&#125; 增加vue-shims.d.ts，可以识别.vue文件 1234declare module &#39;*.vue&#39; &#123; import Vue from &#39;vue&#39;; export default Vue;&#125; index.tsx文件 12345import Vue from 'vue';import App from './App.vue';let vm = new Vue(&#123; render:h=&gt;h(App)&#125;).$mount('#root') App.vue文件 123456789101112&lt;template&gt; &lt;div&gt; &lt;div v-for=\"(todo,index) in todos\" :key=\"index\"&gt;&#123;&#123;todo&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123;Component,Vue&#125; from 'vue-property-decorator';@Componentexport default class Todo extends Vue&#123; public todos = ['香蕉','苹果','橘子']&#125;&lt;/script&gt; 11.配置代理设置服务端接口 123456const express = require('express');const app = express();app.get('/api/list', (req, res) =&gt; &#123; res.send(['香蕉', '苹果', '橘子']);&#125;);app.listen(4000); 安装axios获取数据 1npm install axios --save-dev 配置接口请求 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;div v-for=\"(todo,index) in todos\" :key=\"index\"&gt; &#123;&#123;todo&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import axios from 'axios';import &#123;Component ,Vue&#125; from 'vue-property-decorator';@Componentexport default class Todo extends Vue&#123; public todos:string[] =[]; async mounted()&#123; let &#123; data &#125; = await axios.get('/api/list'); this.todos = data &#125;&#125;&lt;/script&gt; 配置服务器代理路由 12345proxy: &#123; '/api': &#123; target: 'http://localhost:4000', &#125;,&#125;","categories":[{"name":"转载","slug":"转载","permalink":"http://blog.curtaintan.club/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"webpack","slug":"转载/webpack","permalink":"http://blog.curtaintan.club/categories/%E8%BD%AC%E8%BD%BD/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.curtaintan.club/tags/webpack/"}]},{"title":"[转载]从0搭建自己的webpack开发环境（一）","slug":"[转载]从0搭建自己的webpack开发环境（一）","date":"2020-02-12T15:30:46.000Z","updated":"2020-02-12T15:55:05.396Z","comments":true,"path":"2020/02/12/[转载]从0搭建自己的webpack开发环境（一）/","link":"","permalink":"http://blog.curtaintan.club/2020/02/12/[%E8%BD%AC%E8%BD%BD]%E4%BB%8E0%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"从0搭建自己的webpack开发环境1.什么是Webpack？webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler),当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 使用Webpack作为前端构建工具： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 在webpack应用中有两个核心: 1) 模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块 2) 扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 2.初始化项目123├── src # 源码目录│ ├── a-module.js│ └── index.js 编写 a-module.js 1module.exports = 'hello'; 编写 index.js 12let a = require('./a-module');console.log(a); 这里我们使用CommonJS模块的方式引入，这种方式默认在浏览器上是无法运行的，我们希望通过 webpack 来进行打包！ 3.webpack快速上手3.1 安装12npm init -ynpm install webpack webpack-cli --save-dev webpack默认支持0配置,配置scripts脚本 123\"scripts\": &#123; \"build\": \"webpack\"&#125; 执行npm run build,默认会调用 node_modules/.bin下的webpack命令，内部会调用webpack-cli解析用户参数进行打包。默认会以 src/index.js 作为入口文件。 这里也可以使用npx webpack,npx 是 5.2版本之后npm提供的命令可以执行.bin下的可执行文件 我们可以发现已经产生了dist目录，此目录为最终打包出的结果。main.js可以在html中直接引用,这里还提示我们默认mode 为production 3.2 webpack.config.js我们打包时一般不会采用0配置，webpack在打包时默认会查找当前目录下的 webpack.config.js or webpackfile.js 文件。 通过配置文件进行打包 12345678const path = require('path');module.exports = &#123; entry:'./src/index.js', output:&#123; filename:'bundle.js', // 打包出的结果文件 path:path.resolve(__dirname,'dist') // 打包到dist目录下 &#125;&#125; 3.3 配置打包的mode我们需要在打包时提供mode属性来区分是开发环境还是生产环境,来实现配置文件的拆分 1234├── build│ ├── webpack.base.js│ ├── webpack.dev.js│ └── webpack.prod.js 我们可以通过指定不同的文件来进行打包 配置scripts脚本 1234\"scripts\": &#123; \"build\": \"webpack --config ./build/webpack.prod\", \"dev\": \"webpack --config ./build/webpack.dev\"&#125; 可以通过 config 参数指定,使用哪个配置文件来进行打包 通过env参数区分 1234\"scripts\": &#123; \"build\": \"webpack --env.production --config ./build/webpack.base\", \"dev\": \"webpack --env.development --config ./build/webpack.base\"&#125; 改造webpack.base文件默认导出函数，会将环境变量传入到函数的参数中 123module.exports = (env)=&gt;&#123; console.log(env); // &#123; development: true &#125;&#125; 合并配置文件 我们可以判断当前环境是否是开发环境来加载不同的配置,这里我们需要做配置合并安装webpack-merge: 1npm install webpack-merge --save-dev webpack.dev配置 123module.exports = &#123; mode:'development'&#125; webpack.prod配置 123module.exports = &#123; mode:'production'&#125; webpack.base配置 1234567891011121314151617181920const path = require('path');const merge = require('webpack-merge');// 开发环境const dev = require('./webpack.dev');// 生产环境const prod = require('./webpack.prod');const base = &#123; // 基础配置 entry:'./src/index.js', output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'../dist') &#125;&#125;module.exports = (env) =&gt;&#123; if(env.development)&#123; return merge(base,dev); &#125;else&#123; return merge(base,prod) &#125;&#125; 后续的开发中，我们会将公共的逻辑放到base中,开发和生产对的配置也分别进行存放！ 4.webpack-dev-server配置开发服务器，可以在实现在内存中打包,并且自动启动服务 1npm install webpack-dev-server --save-dev 1234\"scripts\": &#123; \"build\": \"webpack --env.production --config ./build/webpack.base\", \"dev\": \"webpack-dev-server --env.development --config ./build/webpack.base\"&#125; 通过执行npm run dev来启启动开发环境 默认会在当前根目录下启动服务 配置开发服务的配置 12345678910const path = require('path')module.exports = &#123; mode:'development', devServer:&#123; // 更改静态文件目录位置 contentBase:path.resolve(__dirname,'../dist'), compress:true, // 开启gzip port:3000, // 更改端口号 &#125;&#125; 5.打包Html插件5.1 单入口打包自动产生html，并引入打包后的文件 编辑webpack.base文件 123456789101112const HtmlWebpackPlugin = require('html-webpack-plugin');plugins:[ new HtmlWebpackPlugin(&#123; filename:'index.html', // 打包出来的文件名 template:path.resolve(__dirname,'../public/index.html'), hash:true, // 在引用资源的后面增加hash戳 minify:&#123; removeAttributeQuotes:true // 删除属性双引号 &#125; &#125;)] 5.2 多入口打包根据不同入口 生成多个js文件，引入到不同html中 123── src ├── entry-1.js └── entry-2.js 多入口需要配置多个entry 123456789entry:&#123; jquery:['jquery'], // 打包jquery entry1:path.resolve(__dirname,'../src/entry-1.js'), entry2:path.resolve(__dirname,'../src/entry-2.js')&#125;,output:&#123; filename:'[name].js', path:path.resolve(__dirname,'../dist')&#125;, 产生多个Html文件 1234567891011121314151617181920new HtmlWebpackPlugin(&#123; filename:'index.html', template:path.resolve(__dirname,'../public/template.html'), hash:true, minify:&#123; removeAttributeQuotes:true &#125;, chunks:['jquery','entry1'], // 引入的chunk 有jquery,entry&#125;),new HtmlWebpackPlugin(&#123; filename:'login.html', template:path.resolve(__dirname,'../public/template.html'), hash:true, minify:&#123; removeAttributeQuotes:true &#125;, inject:false, // inject 为false表示不注入js文件 chunksSortMode:'manual', // 手动配置代码块顺序 chunks:['entry2','jquery']&#125;) 以上的方式不是很优雅，每次都需要手动添加HtmlPlugin应该动态产生html文件，像这样: 12345678910111213141516171819202122let htmlPlugins = [ &#123; entry: \"entry1\", html: \"index.html\" &#125;, &#123; entry: \"entry2\", html: \"login.html\" &#125;].map( item =&gt; new HtmlWebpackPlugin(&#123; filename: item.html, template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: &#123; removeAttributeQuotes: true &#125;, chunks: [\"jquery\", item.entry] &#125;));plugins: [...htmlPlugins] 6.清空打包结果可以使用clean-webpack-plugin手动清除某个文件夹内容: 安装 1npm install --save-dev clean-webpack-plugin 12345const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');new CleanWebpackPlugin(&#123; // 清空匹配的路径 cleanOnceBeforeBuildPatterns: [path.resolve('xxxx/*'),'**/*'],&#125;) 这样就可以清空指定的目录了,我们可以看到webpack插件的基本用法就是 new Plugin并且放到plugins中","categories":[{"name":"转载","slug":"转载","permalink":"http://blog.curtaintan.club/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"webpack","slug":"转载/webpack","permalink":"http://blog.curtaintan.club/categories/%E8%BD%AC%E8%BD%BD/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.curtaintan.club/tags/webpack/"}]},{"title":"mobx与mobx-react实现todoList","slug":"mobx与mobx-react实现todoList","date":"2020-02-11T09:09:51.000Z","updated":"2020-02-12T03:25:45.926Z","comments":true,"path":"2020/02/11/mobx与mobx-react实现todoList/","link":"","permalink":"http://blog.curtaintan.club/2020/02/11/mobx%E4%B8%8Emobx-react%E5%AE%9E%E7%8E%B0todoList/","excerpt":"使用 mobx 结合 react 搭建的小 demo….","text":"使用 mobx 结合 react 搭建的小 demo…. 先看效果图： 预览地址：TodoListgithub 地址：mobx-react — todoList 1. 前言本文主要介绍 mobx-react 与 mobx 的使用，最后完成 todolist。 此 demo 全部用 class 组件搭建完成，如需使用 hooks ，请参考mobx与react-hooks 2. 环境准备需要在mobx—简明学习的基础上。 安装 react一套： yarn add react react-dom prop-types 安装 babel-react相关插件 yarn add @babel/preset-react 安装 mobx-react yarn add mobx-react 配置 webpack.config.js 文件 配置完成，开始编写文件。 3. mobx-react 说明：看 mobx-react 官方文档 可知有如下 api： observer(componentClass) Observer —- Observer是一个React组件，它将观察者应用于组件中的匿名区域。 useLocalStore hook useAsObservableSource hook Server Side Rendering with useStaticRendering（服务端） PropTypes Provider and inject disposeOnUnmount(componentInstance, propertyKey | function | function[]) 可见，有两种 api，一种是针对 componentClass 的，一种是针对 hooks 的。 我们使用 componentClass，所以主要用到： observer(componentClass) 使类重新render PropTypes 判定proptype Provider and inject 提供 store 和 注入对应props 具体的使用，请阅读 官方文档 ， 官方文档写得蛮详细的。 4. 开始编写文件结构： 4.1 store.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; observable, action, computed, observe &#125; from \"mobx\"class Todo &#123; id = Math.random() @observable title = \"\" @observable finished = false constructor( title )&#123; this.title = title &#125; @action.bound toggle()&#123; this.finished = !this.finished &#125;&#125;class Store &#123; @observable todos = [] disposers = [] @action.bound createTodo( title )&#123; this.todos.unshift( new Todo( title ) ) &#125; @computed get left()&#123; return this.todos.filter( todo =&gt; &#123; return !todo.finished &#125;).length &#125; @action.bound removeTodo( todo )&#123; this.todos.remove( todo ) &#125; constructor()&#123; observe( this.todos, change =&gt; &#123; this.disposers.forEach( disposer =&gt; disposer() ) this.disposers = [] for( let todo of change.object )&#123; var disposer = observe( todo, change =&gt; &#123; console.log( change ) &#125;) this.disposers.push( disposer ) &#125; &#125;) &#125;&#125;const store = new Store()const ss = &#123; store&#125;export default ss 4.2 index.jsx1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from \"react\"import ReactDOM from \"react-dom\"import &#123; observer, Provider &#125; from \"mobx-react\"import &#123; trace &#125; from \"mobx\"import TodoHeader from \"./conponent/TodoHeader.jsx\"import TodoView from \"./conponent/TodoView.jsx\"import TodoFooter from \"./conponent/TodoFooter.jsx\"import ss from \"./store.js\"@observerclass TodoList extends Component &#123; render()&#123; trace() return ( &lt;div className=\"todo-list\" &gt; &lt;TodoHeader /&gt; &lt;ul&gt; &lt;TodoView /&gt; &lt;/ul&gt; &lt;TodoFooter /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( ( &lt;Provider &#123; ...ss &#125; &gt; &lt;TodoList /&gt; &lt;/Provider&gt;), document.querySelector(\"#root\") ) 4.3 TodoFooter.jsx12345678910111213141516171819202122import React, &#123; Component &#125; from \"react\"import &#123; observer, inject &#125; from \"mobx-react\"import &#123; trace &#125; from \"mobx\"@inject( allStore =&gt; &#123; return &#123; left: allStore.store.left &#125;&#125;)@observerclass TodoFooter extends Component &#123; render()&#123; trace() return ( &lt;footer&gt; &#123; this.props.left &#125; items unfinished... &lt;/footer&gt; ) &#125;&#125;export default TodoFooter 4.4 TodoHeader.jsx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from \"react\"import &#123; observer, inject &#125; from \"mobx-react\"@inject( \"store\" )@observerclass TodoHeader extends Component &#123; state = &#123; inputValue : \"\" &#125; handleSubmit = ( e ) =&gt; &#123; e.preventDefault() let store = this.props.store var inputValue = this.state.inputValue store.createTodo( inputValue ) this.setState(&#123; inputValue: \"\" &#125;) &#125; handleChange = ( e ) =&gt; &#123; e.persist() var inputValue = e.target.value this.setState(&#123; inputValue: inputValue &#125;) &#125; render()&#123; return ( &lt;header&gt; &lt;form onSubmit=&#123; this.handleSubmit &#125; &gt; &lt;input type=\"text\" onChange=&#123; e =&gt; this.handleChange( e )&#125; value=&#123; this.state.inputValue &#125; className=\"input\" placeholder=\" what deeds to be finished? \" /&gt; &lt;/form&gt; &lt;/header&gt; ) &#125;&#125;export default TodoHeader 4.5 TodoView.jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component, Fragment &#125; from \"react\"import PropTypes from \"prop-types\"import &#123; observer, inject &#125; from \"mobx-react\"@inject( \"store\" )@observerclass TodoView extends Component &#123; render()&#123; const store = this.props.store const &#123; todos &#125; = store return todos.map( todo =&gt; &#123; return ( &lt;li key=&#123; todo.id &#125; className=\"todo-item\"&gt; &lt;TodoItem todo=&#123; todo &#125; /&gt; &lt;span className=\"delete\" onClick=&#123; e =&gt; store.removeTodo( todo ) &#125; &gt;X&lt;/span&gt; &lt;/li&gt; ) &#125;) &#125;&#125;@observerclass TodoItem extends Component&#123; static propTypes = &#123; todo: PropTypes.shape(&#123; id: PropTypes.number.isRequired, title: PropTypes.string.isRequired, finished: PropTypes.bool.isRequired &#125;).isRequired &#125; handleClick = () =&gt; &#123; this.props.todo.toggle() &#125; render()&#123; const todo = this.props.todo return ( &lt;Fragment&gt; &lt;input type=\"checkbox\" className=\"toggle\" checked=&#123; todo.finished &#125; onChange=&#123; this.handleClick &#125; /&gt; &lt;span className=&#123;[\"title\", todo.finished &amp;&amp; \"finished\"].join(\" \")&#125; &gt; &#123; todo.title &#125; &lt;/span&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoView 4.6 html 文件内添加 css 样式123456789101112131415161718192021222324252627282930.input &#123; padding: 15px; border: 1px solid #ccc; font-size: 24px; width: 400px;&#125;.todo-item &#123; display: flex; align-items: center; height: 40px; border-bottom: 1px solid #ccc;&#125;.todo-item .toggle &#123; margin-right: 20px;&#125;.todo-item .title &#123; font-size: 24px; color: #000;&#125;.todo-item .title.finished &#123; text-decoration: line-through; color: #ccc;&#125;.todo-item .delete &#123; margin-left: 20px; cursor: pointer;&#125;footer&#123; font-size: 22px;&#125; 5. 性能优化提升性能三大法则： 细粒度拆分视图组件 使用专用组件处理列表 尽可能晚的结构可观察数据 上面三大法则，你在上面的代码中，能找到在哪里吗？？ 还有其他的优化点： 尽早的绑定函数（不要传匿名函数和箭头函数） 不要使用数组的索引作为 key 使用小组件 详情参考：优化 React 组件渲染 6. 总结当得到一些点拨过后，再去阅读官方文档，就会收获更多， 当然也要学会阅读官方文档，官方文档写得都蛮好的。 写下这篇文章，也算是总结了一下 mobx 相关的知识. 加油，写下这篇文章希望对你有帮助，与君共勉！！ 有时间，我会把 class 版本改成 hook 版本的。 7. 参考材料茵风泳月–mobx入门基础教程 mobx—-官网 mobx-react 文档 mobx-react 官方文档","categories":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/categories/mobx/"}],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/tags/mobx/"}]},{"title":"mobx--简明学习","slug":"mobx-简明学习","date":"2020-02-11T06:19:41.000Z","updated":"2020-02-12T02:07:02.181Z","comments":true,"path":"2020/02/11/mobx-简明学习/","link":"","permalink":"http://blog.curtaintan.club/2020/02/11/mobx-%E7%AE%80%E6%98%8E%E5%AD%A6%E4%B9%A0/","excerpt":"mobx 简明学习与实践….","text":"mobx 简明学习与实践…. 前置环境准备：请参考：es6—Decorator,并使用 yarn add mobx 安装 mobx 模块。 1. 前言学习前，建议仔细阅读一遍 MobX 介绍 了解 mobx 运行机制。 先看 mobx 官网的文档目录： 可以看到，整个库，需要我们学习的就只有三个主要的点： observable 相关 —– 创建观察数据 对 observables 作出响应 —– 数据改变时的响应操作 改变 observables 还有一个工具函数。 2. observable 相关 —- 创建被观察数据创建可观察数据的方式有两种： 使用 observable 函数构建 使用 @observable 装饰类构建 2.1 使用 observable 函数构建observable 函数构建可观察的数据123456const value = observable(\"value\")const list = observable([1, 2, 4])const map = observable.map(&#123; key: \"value\"&#125;)// 使用 observable.box()const cityName = observable.box(\"tan\") 2.1 使用 @observable 装饰类构建12345678910class Store &#123; @observable num = 22 @observable str = \"string\" @observable bool = false @observable obj = &#123; name: \"tan\", age: 12 &#125; @observable array = []&#125; 3. 对 observables 作出响应有 4 个 api 处理响应： computed 和 @computed 函数内依赖的观察项改变时，自动执行，类似 vue 中的 computed autorun( fn, { options } ): 函数内的依赖项改变时，自动执行 when( fn, fn ): 第一个函数内依赖项改变时执行第一个函数，第一个函数返回 true 时，执行第二个函数 reaction( fn, fn ): 第一个函数返回一个数组，数组中值的改变时，执行第二个函数 observer 和 @observer 修饰 react 类，用于更新视图 代码： 代码放在文章尾部 运行结果： 4. action –改变– observables我们可以直接通过 store 来修改属性，但是每一次属性的改变，响应操作都会执行，当我们需要一次性执多个属性的改变的时候，响应操作就会执行多次，但是我们只需要执行一次就够了，那怎么解决呢？？此时 action 就出场了。 action 主要有： action( fn ): fn — 创建一个 action 函数 @action - fn : 修饰类方法，使其变成 action 方法 @action.bound : 修饰类方法，绑定 this runInAction(name?, thunk)： 直接运行 action 操作，搭配 @action 可执行异步 案例： 代码放在文章底部 测试结果： 5. 总结工具函数就自行看官方文档了。 对比着 mobx 的运行流程图： 我们就可以很轻易的理解各个 api 之间的关系了。 6. 参考材料mobx—-官网 推荐大家去观看此教程，非常好的教程。茵风泳月–mobx入门基础教程 7. 文中使用代码：测试相应的代码测试副作用12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; observable, computed, autorun, when, reaction &#125; from \"mobx\"class Store &#123; @observable num = 22 @observable str = \"string\" @observable bool = false @observable obj = &#123; name: \"tan\", age: 12 &#125; @computed get mixed()&#123; return this.obj.age + \"-----\" + this.str &#125;&#125;var store = new Store()// 测试 computedvar foo = computed( function()&#123; return store.str + \"/\" + store.obj.age&#125;)console.log( foo.get() )console.log( store.mixed )foo.observe( function( change )&#123; console.log( \"computed 值改变：\" ) console.log( \"修改值：\", change )&#125;)// 测试 autorun autorun( () =&gt; &#123; console.log( \"autorun运行：\" ) console.log( store.str + \"/\" + store.obj.age )&#125;)// 测试 wenwhen( ()=&gt; store.bool , ()=&gt; console.log( \"变成 true 了...\" ) )// 测试 reactionreaction( () =&gt; [ store.str, store.obj.age ], arr =&gt; console.log( \"reaction 运行：\",arr ) )console.log( \"开始测试：------- wen ------\" )store.bool = trueconsole.log( \"开始测试：------- 其他三个 ------\" )store.obj.age = 13 测试 action测试 action 123456789101112131415161718192021222324252627282930313233343536import &#123; observable, action, reaction &#125; from \"mobx\"class Store &#123; @observable num = 22 @observable str = \"string\" @observable bool = false @observable obj = &#123; name: \"tan\", age: 12 &#125; @action bar()&#123; this.str = \"修改值了--\" this.num = 89 &#125;&#125;var store = new Store()reaction( () =&gt; [ store.str, store.obj.age ], arr =&gt; console.log( \"reaction 运行：\",arr ) )// 不用 action 改变值console.log( \"不用 action 改变值：\" )store.obj.age = 11store.str = \"你好---\"// 使用 @actionconsole.log( \"使用 action 修饰器改变多个值\" )store.bar()// 使用 action 执行console.log( \"使用 action 修饰器改变多个值\" )action( () =&gt; &#123; store.str = \"ppppppp\" store.obj.age = 45&#125;)()","categories":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/categories/mobx/"}],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://blog.curtaintan.club/tags/mobx/"}]},{"title":"es6---Decorator","slug":"es6-Decorator","date":"2020-02-10T08:17:56.000Z","updated":"2020-02-11T06:34:41.508Z","comments":true,"path":"2020/02/10/es6-Decorator/","link":"","permalink":"http://blog.curtaintan.club/2020/02/10/es6-Decorator/","excerpt":"搭建可使用 Decorator 的环境，并学习 Decorator 。","text":"搭建可使用 Decorator 的环境，并学习 Decorator 。 1. 环境搭建 安装插件： webpack ： 1yarn add webpack webpack-cli babel ： 1yarn add @babel/cli @babel/core @babel/preset-env babel-loader babel 装饰器相关插件： 1yarn add @babel/plugin-proposal-decorators babel-plugin-transform-class-properties webpack.config.js 配置 配置代码放在文章末尾。 配置 package.json 123\"scripts\": &#123; \"dev\": \"webpack\" &#125;, 环境配置完毕，运行 yarn dev 就可以将文件编译好。 新建一个html文件，引入编译好的 js 文件，环境配置基本完成。 目录结构： 2. 开始书写代码编写 bundle.js 2.1 类的装饰：代码设计： 运行结果： 2.2 类方法的修饰代码设计： 运行结果： 2.2 类属性的修饰代码设计： 运行结果： 注： 可以在 js 文件头部编写 &quot;use strict&quot;来使用严格模式， 使用严格模式后，当修改不可修改的属性时，就会打断操作并报错。 3. 总结装饰器不能用修饰函数，因为函数存在变量提升。 4. 参考材料茵风泳月–mobx入门基础教程 阮一峰–es6 基础入门 5. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 定义类修饰器function log( target )&#123; const desc = Object.getOwnPropertyDescriptors( target.prototype ) for( const key of Object.keys( desc ) )&#123; if( key === \"constuctor\" )&#123; continue &#125; const func = desc[key].value if( typeof func === \"function\" )&#123; Object.defineProperty( target.prototype, key, &#123; value( ...arg )&#123; console.log( \"加之前\", key ) const ret = func.apply( this, arg ) console.log( \"相加----结果：\", ret ) console.log( \"加之后\", key ) return ret &#125; &#125;) &#125; &#125;&#125;// 属性修饰器function readonly( target, key, desc )&#123; desc.writable = false&#125;// 方法修饰器function validate( target, key, desc )&#123; const func = desc.value desc.value = function( ...arg )&#123; for( let num of arg )&#123; if( typeof num !== \"number\" )&#123; throw new Error(`\"$&#123; num &#125; \" 不是一个数字..`) &#125; &#125; console.log( \"函数里面的装饰器-----函数的操作---\" ) return func.apply( this, [ 4, 7 ] ) &#125;&#125;@logclass Numberic &#123; @readonly PI = 3.1315926 // 修饰方法 add( ...nums )&#123; return nums.reduce( ( p, n ) =&gt; ( p + n ), 0 ) &#125;&#125;// 测试console.log( new Numberic().add( 1, 2 ) )var ss = new Numberic()console.log( \"修改数据前：\", ss )ss.PI = 99console.log( \"修改数据后：\", ss ) 5.1 环境配置代码：1234567891011121314151617181920212223242526272829303132333435const path = require(\"path\")const config = &#123; mode: \"development\", // 入口文件 entry: path.resolve( __dirname, \"./src/mobx.js\" ), // 打包输出文件 output: &#123; path: path.resolve( __dirname, \"mobx\" ), filename: \"main.js\" &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"@babel/preset-env\" ], // 配置 babel 插件 plugins: [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], \"transform-class-properties\" ] &#125; &#125; &#125; ] &#125;, // 配置 map 文件 devtool: \"inline-source-map\"&#125;module.exports = config","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式（五）---装饰器模式","slug":"设计模式（五）-装饰器模式","date":"2020-02-10T07:46:53.000Z","updated":"2020-02-10T08:14:24.701Z","comments":true,"path":"2020/02/10/设计模式（五）-装饰器模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"手写一个装饰器模式。","text":"手写一个装饰器模式。 1. 介绍装饰器模式的目的： 为对象添加新功能 不改变其原有的结构和功能 2. 代码演示1234567891011121314151617181920212223class Circle &#123; draw() &#123; console.log(\"画一个圆形\"); &#125;&#125;class Decorator &#123; constructor(circle)&#123; this.circle = circle; &#125; draw() &#123; this.circle.draw(); this.setRedBorder(this.circle); &#125; setBorder(circle) &#123; console.log(\"设置边框\") &#125;&#125;// 测试代码let circle = new Circle();let dec = new Decorator(circle);dec.setRedBorder(); 3. 总结装饰器小情景：手机又照相的功能，我们可以在手机摄像头前装饰一个放大镜，手机在具有照相的基础还有放大的功能。 本质：在执行真正的操作前后，可以进行其他的操作 4. 参考材料装饰者模式 JS设计模式-装饰器模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（四）---发布订阅模式","slug":"设计模式（四）-发布订阅模式","date":"2020-02-09T06:56:37.000Z","updated":"2020-02-09T13:40:31.851Z","comments":true,"path":"2020/02/09/设计模式（四）-发布订阅模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"我看了很多关于发布订阅模式与观察者模式的文章，有点朋友认为观察者模式就是发布订阅模式，根据我看了这么多的文章的总结，他们确实是不一样的。 在vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来。 今天就写一个发布订阅。","text":"我看了很多关于发布订阅模式与观察者模式的文章，有点朋友认为观察者模式就是发布订阅模式，根据我看了这么多的文章的总结，他们确实是不一样的。 在vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来。 今天就写一个发布订阅。 1. 情景模拟：当我们在注册虎扑的时候，软件会让我们选择我们感兴趣的板块，例如：唱、跳、rap、篮球….. 当我们选择自己喜欢的版块时，我们就订阅了相关板块的消息。 当此板块内有热门消息时，虎扑就会给我们推送此消息，他不会把其他板块的消息推送给我们。 2. 分析：我们可以抽象出三个对象，一个发布者，一个调度中心，一个订阅者 发布者：我就是在不同板块发送热门消息的 调度中心：存下所有板块，与板块对应的订阅者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：接收消息并给相关板块所有的订阅者发送消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：移除订阅者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：添加订阅者 订阅者：自己的属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：订阅消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个函数：取消订阅消息 画出 UML 类图就是文章前的图片。 3. 代码实现 真实代码放在文章末尾。 结果： 4. 总结什么是发布订阅模式： 发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。 维基百科zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85 说说我的理解： 发布订阅模式可以理解成三个对象，一个是发布者，一个是订阅者，一个是调度中心。 为什么需要一个调度中心？因为订阅者的订阅是有一定要求的，而不是接收所有发布的消息， 所以调度中心就是将消息分别发送给订阅者。订阅者不会接收到没有订阅的消息。 观察者模式： 观察者只有两个对象，一个观察者、一个被观察者，被观察者只要作出变化（不论什么变化），所有的观察者都会接受到消息。 5. 参考材料发布订阅模式，在工作中它的能量超乎你的想象 谈谈观察者模式和发布订阅模式 EventBus—思考观察者模式与发布订阅者模式 JavaScript中发布/订阅模式的理解 6. 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 发布者 传入调度中心实例class Publisher &#123; constructor( dispatch )&#123; this.dispatch = dispatch &#125; publish()&#123; let arg = Array.from( arguments ) let event = arg.shift() this.dispatch.emit( event, arg ) &#125;&#125;// 调度中心class Dispatcher &#123; constructor()&#123; this.eventObj = &#123;&#125; &#125; on( event, fn )&#123; if( !this.eventObj[event] )&#123; this.eventObj[event] = [] &#125; this.eventObj[event].push( fn ) &#125; emit( type, arg )&#123; let funs = this.eventObj[type] if( !funs || funs.length === 0 )&#123; return &#125; funs.forEach( item =&gt; &#123; item.apply( this, arg ) &#125;); &#125; remove( type, fn )&#123; let fns = this.eventObj[ type ] if( !fns ) return if( !fn )&#123; delete this.eventObj[type] &#125; else &#123; this.eventObj[ type ] = fns.filter( item =&gt; item !== fn ) &#125; &#125;&#125;// 订阅者类 传入 dispatch 和 自己的属性class Subscriber &#123; constructor( dispatch, name )&#123; this.dispatch = dispatch this.name = name &#125; fn = ( msg ) =&gt; &#123; console.log( `我是$&#123; this.name &#125;:` ,\"收到订阅的消息：\", msg ) &#125; subscrib( type, fn )&#123; this.dispatch.on( type, fn, this ) &#125; removeSubscrib( type, fn )&#123; this.dispatch.remove( type, fn ) &#125;&#125;// 测试let dispatch = new Dispatcher()let pub = new Publisher( dispatch )let sub1 = new Subscriber( dispatch, \"sub1\" )let sub2 = new Subscriber( dispatch, \"sub2\" )// 订阅消息sub1.subscrib( \"篮球\", sub1.fn )sub2.subscrib( \"篮球\", sub2.fn )sub2.subscrib( \"足球\", sub2.fn )// 发布消息pub.publish( \"篮球\", \"乔丹去世了---\" )pub.publish( \"足球\", \"国足能进世界杯吗？？\" )// 取消订阅sub1.removeSubscrib( \"篮球\", sub1.fn )pub.publish( \"篮球\", \"这里有一些NBA相关的信息\" ) 通用代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let event = &#123; list: &#123;&#125;, on(key, fn) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, emit() &#123; let key = [].shift.call(arguments), fns = this.list[key]; if (!fns || fns.length === 0) &#123; return false; &#125; fns.forEach(fn =&gt; &#123; fn.apply(this, arguments); &#125;); &#125;, remove(key, fn) &#123; // 这回我们加入了取消订阅的方法 let fns = this.list[key]; // 如果缓存列表中没有函数，返回false if (!fns) return false; // 如果没有传对应函数的话 // 就会将key值对应缓存列表中的函数都清空掉 if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; // 遍历缓存列表，看看传入的fn与哪个函数相同 // 如果相同就直接从缓存列表中删掉即可 fns.forEach((cb, i) =&gt; &#123; if (cb === fn) &#123; fns.splice(i, 1); &#125; &#125;); &#125; &#125;&#125;;function cat() &#123; console.log('一起喵喵喵');&#125;function dog() &#123; console.log('一起旺旺旺');&#125;event.on('pet', data =&gt; &#123; console.log('接收数据'); console.log(data);&#125;);event.on('pet', cat);event.on('pet', dog);// 取消dog方法的订阅event.remove('pet', dog);// 发布event.emit('pet', ['二哈', '波斯猫']);/* 接收数据 [ '二哈', '波斯猫' ] 一起喵喵喵*/ 摘自： 发布订阅模式，在工作中它的能量超乎你的想象","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（三）--代理模式","slug":"设计模式（三）-代理模式","date":"2020-02-08T13:08:41.000Z","updated":"2020-02-09T14:46:30.384Z","comments":true,"path":"2020/02/08/设计模式（三）-代理模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"写一个代理模式.","text":"写一个代理模式. 1. 情景情景: 小明追女生 A 非代理模式: 小明 =花=&gt; 女生A 代理模式: 小明 =花=&gt; 让女生A的好友B帮忙 =花=&gt; 女生A 2. 代理模式的特点 代理对象和本体对象具有一致的接口, 对使用者友好 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。 考拉海购前端团队juejin.im/post/59df4f74f265da430f311909 3. 代码设计 4. es6 代理模式 —- Proxy目的：在操作前可以进行其他的操作（对数据加工等）。 代码设计 运行结果： 案例参考： ES6中的代理模式—–Proxy 阮一峰– es6 入门 4. 总结代理模式，总的来说，是在操作前，可以进行其他的操作。 5. 参考材料BasicSkill–代理模式 JavaScript设计模式 js –代理模式 6. 代码图片懒加载123456789101112131415161718192021222324252627// 真实的对象class RealImg &#123; constructor()&#123; this.imgNode = document.createElement(\"img\") document.body.appendChild( this.imgNode ) &#125; setSrc( src )&#123; this.imgNode.src = src &#125;&#125;// 代理对象class ProxyImg &#123; constructor()&#123; this.realImg = new RealImg() &#125; setSrc( src )&#123; this.realImg.setSrc(\"http://seopic.699pic.com/photo/40007/8839.jpg_wh1200.jpg\") let img = new Image() img.src = src img.onload = () =&gt; &#123; this.realImg.setSrc( src ) &#125; &#125;&#125;let proxyImg = new ProxyImg()proxyImg.setSrc( \"http://seopic.699pic.com/photo/40006/7735.jpg_wh1200.jpg\" )","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（二）--观察者模式","slug":"设计模式（二）-观察者模式","date":"2020-02-08T08:21:01.000Z","updated":"2020-02-08T09:33:31.663Z","comments":true,"path":"2020/02/08/设计模式（二）-观察者模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"写一个观察者模式。","text":"写一个观察者模式。 介绍意图： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 关键代码： 在抽象类里有一个 ArrayList&lt;\\Observer&gt; 存放观察者们。 实现观察者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 观察者模式 * state 状态 * observers &#123; Observer &#125; 保存所有的观察者 */class Subject&#123; constructor()&#123; this.state = 0 this.observers = [] &#125; getState()&#123; return this.state &#125; setState( state )&#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers()&#123; this.observers.forEach( observer =&gt; &#123; observer.update() &#125;) &#125; // 添加观察者 attach( observer )&#123; this.observers.push( observer ) &#125;&#125;// 观察者class Observer &#123; constructor( name, subject )&#123; this.name = name this.subject = subject this.subject.attach( this ) &#125; update()&#123; console.log( `$&#123; this.name &#125; -- update, state: $&#123; this.subject.getState() &#125;` ) &#125;&#125;// 测试let s = new Subject()let o1 = new Observer( \"o1\", s )let o2 = new Observer( \"o2\", s )s.setState( 11 )s.setState( 12 )console.log( s ) 测试结果： 总结：观察者模式的要点主要是将观察者放在被观察者里面，当状态变化后，就依次通知观察者。 参考超全的设计模式简介（45种）—观察者模式 JavaScript 中常见设计模式整理 谈谈观察者模式和发布订阅模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式（一）--单例模式","slug":"设计模式（一）-单例模式","date":"2020-02-08T06:00:08.000Z","updated":"2020-02-08T08:07:23.641Z","comments":true,"path":"2020/02/08/设计模式（一）-单例模式/","link":"","permalink":"http://blog.curtaintan.club/2020/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"写一个单例模式。","text":"写一个单例模式。 定义确保一个类只有一个实例，使每次获取的实例都是同一个。 代码实现123456789101112131415161718192021222324252627282930class Store &#123; constructor( name )&#123; this.name = name &#125; getName()&#123; return this.name &#125; setName( data )&#123; this.name = data &#125;&#125;// 获取单例的方法 --- 使用闭包获取单例Store.getInstance = ( function()&#123; let instance return function( name )&#123; if( !instance )&#123; instance = new Store( name ) &#125; return instance &#125; &#125;)()let store1 = Store.getInstance( \"你好\" )let store2 = Store.getInstance( \"你好----\" )console.log( store1 )console.log( store2 )console.log( store1 === store2 ) 运行结果 总结单例模式运用非常广泛，只要在代码中涉及到只存在一个实例，就可以使用单例模式， vuex 和 redux 就是使用单例模式构建。 写一个单例模式的要点： 使用一个特定函数来获取单例， 此函数使用闭包来确保但会单例是唯一的， 使用函数柯理化–接收传入参数 参考JavaScript设计模式 JavaScript设计模式es6（23种) JavaScript 中常见设计模式整理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.curtaintan.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"javascript之防抖与节流","slug":"javascript之节流与防抖","date":"2020-02-07T05:27:55.000Z","updated":"2020-02-08T05:59:26.654Z","comments":true,"path":"2020/02/07/javascript之节流与防抖/","link":"","permalink":"http://blog.curtaintan.club/2020/02/07/javascript%E4%B9%8B%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"写一个防抖与节流。","text":"写一个防抖与节流。 1. 防抖什么是防抖： 当一个事件触发后，在 n 秒后才执行相关函数，如果在 n 秒内再次触发事件，则在新事件 n 秒后才执行相关函数。 函数功能设计与实现原理： 用户可以根据需求自传定义执行函数、间隔时间、是否立即执行来传入对应的参数。 使用闭包函数，设置一个定时器作为标志放在闭包内，使用函数柯理化接收传入参数。 代码： 123456789101112131415161718192021/** * 防抖函数 * @param fn 回调函数 * @param time 间隔时间 type number * @param immediate 立刻执行 type boolean */function debounce( fn, time, immediate = false )&#123; let timeount return function()&#123; if( timeount )&#123; clearTimeout( timeount ) &#125; if( immediate &amp;&amp; !timeount )&#123; fn.apply( this, arguments ) &#125; timeount = setTimeout( () =&gt; &#123; // 此处运用函数柯理化 arguments 为调用函数时的参数 fn.apply( this, arguments ) // 此处放开注释-会让每一次执行完后，第一次都会立即执行一次 // timeount = null &#125;, time || 500 ) &#125;&#125; 测试： 自建html文件测试123456function go( e )&#123; console.log( e )&#125;document.addEventListener( \"mousemove\", debounce( go, 500, false ) )// 自传参数debounce( go, 500, false )( \"我是自己传进去的参数--\" ) 2. 节流什么是节流： 节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。 代码： 1234567891011121314151617181920212223/** * 节流函数 * @param fn 回调函数 * @param time 间隔时间 type number * @param immediate 立刻执行 type boolean */function throttle( fn, time, immediate = false )&#123; let timeount let isFrist = true return function()&#123; if( immediate &amp;&amp; isFrist )&#123; fn.apply( this, arguments ) isFrist = false &#125; if( !timeount )&#123; timeount = setTimeout( () =&gt; &#123; fn.apply( this, arguments ) timeount = null &#125;, time || 500 ) &#125; &#125;&#125; 测试： 自建html文件测试123456function go( e )&#123; console.log( e )&#125;document.addEventListener( \"mousemove\", throttle( go, 500, true ) )// 自传参数throttle( go, 500, false )( \"我是自己传进去的参数--\" ) 总结：防抖和节流在代码中被使用的频率还是蛮大的， 函数的编写有借鉴，也有自己的思考，感觉自己思考过后，才会对函数有更深的理解。 防抖可以运用在： window 的 resize、scroll mousedown、mousemove keyup、keydown 搜索自动弹出 搜索联想 防抖函数要点： 每一次触发事件，都要清除定时器，并重置 timeout 定时器。 节流函数要点： 每次执行完函数后，都要把标志置为null 参考wclimb–JavaScript之节流与防抖 函数防抖和节流 JavaScript专题之跟着 underscore 学节流 JavaScript专题之跟着underscore学防抖","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"javascript之继承","slug":"javascript之继承","date":"2020-02-06T06:07:35.000Z","updated":"2020-02-08T06:01:06.340Z","comments":true,"path":"2020/02/06/javascript之继承/","link":"","permalink":"http://blog.curtaintan.club/2020/02/06/javascript%E4%B9%8B%E7%BB%A7%E6%89%BF/","excerpt":"在 es6 之前，javaScript 不能使用 extends 来显式继承的，所以，继承需要程序员手动完成。 那么，让我们来看一看 js 中的各种继承方式吧。","text":"在 es6 之前，javaScript 不能使用 extends 来显式继承的，所以，继承需要程序员手动完成。 那么，让我们来看一看 js 中的各种继承方式吧。 前置知识原型链 我们需要了解原型和原型链，需要知道构造函数与原型对象之间的关系，需要知道原型对象是一个对象，它有个属性 constructor 就是构造函数 Object.creact() 方法 传入原型对象，返回原型对象和属性。 1. 原型链继承原理说明： 就是将已经 new 出来的对象实例的 prototype 变成父对象，从而，把父对象的属性和方法都继承到了当前对象的 prototype 上，当前对象的实例本身没有父对象的属性与方法，当调用这些方法时，他会自动到此对象的 prototype 上依次去找，直到找到 null 为止，这就称为原型链继承。 实现 123456789101112131415161718192021222324function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12 )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125;&#125;// 修改原型对象，并改回构造函数Student.prototype = new Person()Student.prototype.constuctor = Studentvar S = new Student( 12 )console.log( \"实例S：\", S )S.run()console.log( S instanceof Student ) 运行结果： 1.1 总结： 由上面的例子可见，当继承的对象需要传参时，极度不灵活，因为 prototype 是一个父类的实例。 故：此继承方法适合继承方法，而不适合继承属性。 2. 借用构造函数继承原理说明： 在构造函数中，改变父类构造函数的 this 并执行构造函数。 实现： 1234567891011121314151617181920212223function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 也可以使用 apply 改变 this Person.call( this, name, age )&#125;var S = new Student( 12, \"yu\", 12 )console.log( \"实例S：\", S )S.run()console.log( S instanceof Student ) 运行结果： 总结： 可以传参给父类构造函数了，但是此方法不能继承父类原型链（ prototype ）上的方法和参数。 3. 组合继承原理说明： 将上面两种方法结合起来，目的是继承到父类原型链上的方法。 实现： 1234567891011121314151617181920212223242526function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 Person.call( this, name, age )&#125;// 继承父类原型链Student.prototype = new Person()Student.prototype.constuctor = Studentvar S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 运行结果： 总结： 很好的继承了父类，并继承了原型链，但是多了一些属性在原型链上。下面我们将解决这个问题。 4. 组合继承变种——借用原型链继承原理说明： 将子类的原型链指向父类的原型链，达到继承父类原型链的目的： 实现： 修改组合继承的代码：1234567// 继承父类原型链Student.prototype = new Person()Student.prototype.constuctor = Student// 修改为：Student.prototype = Object.create( Person.prototype )Student.prototype.constuctor = Student 运行结果： 总结： 完美的继承了父类，干净利索。 5. ES6 类继承 extends实现说明：extends 关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中 constructor 表示构造函数，一个类中只能有一个构造函数，有多个会报出 SyntaxError 错误,如果没有显式指定构造方法，则会添加默认的 constructor 方法，使用 super 方法传参到父类构造函数。 实现： es6 extends 继承1234567891011121314151617181920212223242526class Person&#123; constructor( name=\"tan\", age=18 )&#123; this.name = name this.age = age &#125; run = function() &#123; console.log(`$&#123; this.name &#125; can run...`) &#125; getName = function (params) &#123; return this.name &#125;&#125;class Student extends Person&#123; constructor( id, name, age )&#123; super( name, age ) this.id = id &#125; study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125;&#125;var S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 运行结果： 总结： 简单、完美 疑问：在第四种继承方式中，为什么不能直接改成 Student.prototype = Person.prototype，而要使用 Object.create( Person.prototype ), 代码： 12345678910111213141516171819202122232425function Person( name=\"tan\", age=18 )&#123; this.name = name this.age = age this.run = function()&#123; console.log(`$&#123; this.name &#125; can run...`) &#125;&#125;Person.prototype.getName = function()&#123; return this.name&#125;function Student( id = 12, name, age )&#123; this.id = id this.study = function()&#123; console.log( `$&#123;name&#125; can study...` ) &#125; // 改变父类构造函数并传参执行 Person.call( this, name, age )&#125;Student.prototype = Person.prototypeStudent.prototype.constuctor = Studentvar S = new Student( 12, \"yu\", 17 )console.log( \"实例S：\", S )console.log( \"getName:\", S.getName() )console.log( S instanceof Student ) 结果是： 如果你知道原因，请在下方评论区给我留言。感谢！ 总结：尽管继承方式五花八门，但是继承的目的却是不变的： 将父类属性和方法复制到当前类 ( 在构造函数内改变父类构造函数的this并执行 ) 继承父类的原型链 （ 修改构造函数的 prototype 指向父类的 prototype ） 参考：看了都知道继承也就那么回事儿 JavaScript常用八种继承方案","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"javascript 之 new 的实现","slug":"javascript 之 new 的实现","date":"2020-02-06T02:30:46.000Z","updated":"2020-02-08T06:00:56.389Z","comments":true,"path":"2020/02/06/javascript 之 new 的实现/","link":"","permalink":"http://blog.curtaintan.club/2020/02/06/javascript%20%E4%B9%8B%20new%20%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"网上有很多讲原型、原型链、new 的执行与实现的文章，我也看了很多。 本文描述一下 new 的执行过程与手写实现一个 new 的实现。","text":"网上有很多讲原型、原型链、new 的执行与实现的文章，我也看了很多。 本文描述一下 new 的执行过程与手写实现一个 new 的实现。 1. new 的执行过程 我们以上图为例阐述 new 的执行过程。 创建一个中间对象 将该中间对象的原型指向构造函数的原型 将构造函数的 this 指向该中间对象并执行 返回该中间对象，即返回实例对象 2. 代码实现1234567891011121314function myNew()&#123; // 取出传入参数 let argArray = Array.from( arguments ) // 取出构造函数与需要传入构造函数的参数 let constructorFun = argArray.shift() // 创建中间函数 let obj = &#123;&#125; // 将该中间对象的原型指向构造函数的原型 obj.__proto__ = constructorFun.prototype // 绑定 this 并传入参数执行 constructorFun.apply( obj, argArray ) // 返回创建的对象 return obj&#125; 3. 运行测试12345678910111213141516function Animal( name, age )&#123; this.name = name this.age = age&#125;function myNew()&#123; let argArray = Array.from( arguments ) let constructorFun = argArray.shift() let obj = &#123;&#125; obj.__proto__ = constructorFun.prototype constructorFun.apply( obj, argArray ) return obj&#125;console.log( \"myNew：\",myNew( Animal, \"dog\", \"12\" ) )console.log( \"new：\", new Animal( \"cat\", \"11\" ) ) 测试结果： 总结写出 new 的执行过程与实现，基本算是考察对 prototype 原型链的理解。 参考：彻底捋清楚 new 的实现","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---写一个深拷贝","slug":"思路清晰-写一个深拷贝","date":"2020-01-31T09:38:59.000Z","updated":"2020-02-06T15:05:37.998Z","comments":true,"path":"2020/01/31/思路清晰-写一个深拷贝/","link":"","permalink":"http://blog.curtaintan.club/2020/01/31/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-%E5%86%99%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"写一个深拷贝，考虑数组、对象和循环引用。","text":"写一个深拷贝，考虑数组、对象和循环引用。 1.准备两个对象 无循环引用的对象 12345678910111213var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125; 有循环引用的对象1234567891011121314var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;target.target = target 2.使用 JSON.parse(JSON.stringify())2.1复制一个无循环引用的对象，代码如下：12345678910111213141516var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;var res = JSON.parse( JSON.stringify( target ) )console.log( \"target: \", target )console.log( \"res: \", res ) 得到的结果是： 总结：可见，JSON.stringify() 不能处理undefined和function。 2.2复制一个循环应用的对象1234567891011121314151617var target = &#123; field1: \"string\", field2: 33, field3: undefined, field4: null, field5: &#123; child: \"child\" &#125;, field6: [ 1, 2, 3, 4 ], field7: function()&#123; console.log( this.field1 ) &#125;&#125;target.target = targetvar res = JSON.parse( JSON.stringify( target ) )console.log( \"target: \", target )console.log( \"res: \", res ) 结果： 总结：可见，JSON.stringify() 不能处理处理循环引用的结构 3.手写一个深拷贝3.1浅拷贝1234567function clone( target )&#123; let cloneTarget = &#123;&#125; for( let key in target )&#123; cloneTarget[key] = target[key] &#125; return cloneTarget&#125; 上面是一个浅拷贝，没有考虑数组与对象。 3.2 考虑对象我们可以使用 typeof 来判断数据类型： typeof可以查看数据的类型有 7 种：typeof 12345 === numbertypeof “999” === stringtypeof {} === object null []typeof undefined === undefinedtypeof true === booleantypeof symbol(23) === symboltypeof console.log === function typeof小提示 使用递归处理引用对象的拷贝： 1234567891011function clone( target )&#123; if( typeof target === \"object\" )&#123; let cloneTarget = &#123;&#125; for( let key in target )&#123; cloneTarget[key] = clone( target[key] ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 结果： 总结 因为typeof会把数组识别成object，所以，代码还需要再度改进。 3.3 考虑数组1234567891011function clone( target )&#123; if( typeof target === \"object\" )&#123; let cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; for( let key in target )&#123; cloneTarget[key] = clone( target[key] ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 测试结果： 总结： 可见，数组也可以复制了，下面我们要解决循环引用。 3.4 考虑循环引用当学习过设计模式后，我们会发现，有很多情况存在循环引用的问题，所以，在深拷贝时，循环引用的问题是必须要解决的。 解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。 —引用自：如何写出一个惊艳面试官的深拷贝? es6中，有这样一种数据结构叫 Map，他能将对象作为键，这样，我们就能很好的保存对象，并判断对象是否被拷贝过了。 整体流程如下： 是对象，检查map中是否存在此对象 存在—-返回保存在map中的键 不存在—将值存入map，键的值使用当前cloneTarget（这里其实用什么都行） 继续递归拷贝，并传入此时的map 代码如下： 123456789101112131415function clone( target, map = new Map() )&#123; if( typeof target === \"object\" )&#123; var cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; if( map.get( target ) )&#123; return map.get( target ) &#125; map.set( target, cloneTarget ) for( let key in target )&#123; cloneTarget[key] = clone( target[key], map ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 测试结果： 可以看见，已经解决了循环引用的问题。 3.5 简单性能优化使用 WeakMap 数据结构，将复制对象属性的强引用变为弱引用。 WeakMap的作用，请参考 es6 WeakMap. 修改后的代码： 123456789101112131415function clone( target, map = new WeakMap() )&#123; if( typeof target === \"object\" )&#123; var cloneTarget = Array.isArray( target ) ? [] : &#123;&#125; if( map.get( target ) )&#123; return map.get( target ) &#125; map.set( target, cloneTarget ) for( let key in target )&#123; cloneTarget[key] = clone( target[key], map ) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 最后，我们就完成了一个简单的深拷贝，解决了对象、数组、循环引用的问题。 结语总结一下写出一个深拷贝的过程： 需要传入两个参数，一个是拷贝目标，一个是作为拷贝过属性的容器 WeakMap 判断拷贝目标是否一个对象 或是 数组 是 使用 WeakMap 判断是否已经拷贝，并递归拷贝每个属性 不是 直接返回此属性的值 js中还有很多其他的数据结构，比如 Set 和 Map，这里就不做继续的深入了， 如果你想继续深入深拷贝，你可以参考：如何写出一个惊艳面试官的深拷贝? 参考如何写出一个惊艳面试官的深拷贝? 阮一峰 es6","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.curtaintan.club/categories/javascript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"思路清晰---socket.io的总结","slug":"思路清晰-socket-io的总结","date":"2020-01-30T07:35:36.000Z","updated":"2020-01-31T06:46:04.954Z","comments":true,"path":"2020/01/30/思路清晰-socket-io的总结/","link":"","permalink":"http://blog.curtaintan.club/2020/01/30/%E6%80%9D%E8%B7%AF%E6%B8%85%E6%99%B0-socket-io%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"思路清晰的使用socket.io…..","text":"思路清晰的使用socket.io….. 引入：先看官网api： 可以看见，主要有这三个对象：server，namespace和socket 如果你掌握了这三个对象，那么你就已经基本学会socket.io的使用了。 在服务端，我们会写出这样的socket.io服务端代码：12345678910111213141516171819202122const Koa = require('koa') // 引入koaconst app = new Koa() // 创建一个koa实例// 引入http模块，并在Server函数中传入app的回调函数const http = require(\"http\").Server( app.callback() )// 引入socket.io 传入http，并配置socketconst IO = require(\"socket.io\")( http, &#123; pingTimeout: 1000 * 10, pingInterval: 1000 * 2.5&#125;)// 默认命名空间（\"/\"）总线IO监听连接事件 当前IO为默认命名空间IO.on( \"connection\", ( socket ) =&gt; &#123; // 当前socket连接收到event事件，触发callback函数 socket.on( \"event\", callBack ) // 向当前socket连接客户端触发event事件，返回数据sendData socket.emit( \"event\", sendData )&#125;)// 相当于如下代码：var mainSpace = IO.of(\"/\")mainSpace.on( \"connection\", ( socket ) =&gt; &#123; ....&#125; 看了上面的代码，不难发现socket.io暴露两个对象供我们使用，一个是当前命名空间总线IO，一个是当前连接的socket，他们的关系如图： 这里就不得不说一下命名空间了 关于命名空间（namespace）：默认命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192amespace &#123; name: '/', server: Server &#123; nsps: &#123; '/': [Circular] &#125;, parentNsps: Map &#123;&#125;, _path: '/socket.io', _serveClient: true, parser: &#123; protocol: 4, types: [Array], CONNECT: 0, DISCONNECT: 1, EVENT: 2, ACK: 3, ERROR: 4, BINARY_EVENT: 5, BINARY_ACK: 6, Encoder: [Function: Encoder], Decoder: [Function: Decoder] &#125;, encoder: Encoder &#123;&#125;, _adapter: [Function: Adapter], _origins: '*:*', sockets: [Circular], eio: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125;, httpServer: Server &#123; domain: null, _events: [Object], _eventsCount: 5, _maxListeners: undefined, _connections: 0, _handle: null, _usingSlaves: false, _slaves: [], _unref: false, allowHalfOpen: true, pauseOnConnect: false, httpAllowHalfOpen: false, timeout: 120000, keepAliveTimeout: 5000, _pendingResponseData: 0, maxHeadersCount: null, [Symbol(asyncId)]: -1 &#125;, engine: Server &#123; clients: &#123;&#125;, clientsCount: 0, wsEngine: 'ws', pingTimeout: 5000, pingInterval: 25000, upgradeTimeout: 10000, maxHttpBufferSize: 100000000, transports: [Array], allowUpgrades: true, allowRequest: [Function: bound ], cookie: 'io', cookiePath: '/', cookieHttpOnly: true, perMessageDeflate: [Object], httpCompression: [Object], initialPacket: [Array], ws: [Object], _events: [Object], _eventsCount: 1 &#125; &#125;, sockets: &#123;&#125;, connected: &#123;&#125;, fns: [], ids: 0, rooms: [], flags: &#123;&#125;, adapter: Adapter &#123; nsp: [Circular], rooms: &#123;&#125;, sids: &#123;&#125;, encoder: Encoder &#123;&#125; &#125; &#125; 命名空间与socket当前命名空间总线IO的总结通过上面的命名空间的定义的代码，我们可以知道，在总线IO上，拥有所有连接的socket的信息，拥有所有的rooms信息， 故： 可以向指定房间里发送消息 可以向连接到当前命名空间里的所有socket发送消息 等… 官网api截图： 可知，总的是对room和连接的sockets进行操作。 当前连接socket总结： 个人总结当理解了总线IO与当前连接的socket的关系后，就能思路清晰的写出优秀的的代码了。 写下这篇文章，希望对你有帮助，与君共勉！参考资料：socket.io官网 socket.io命名空间的详细解析 WebSocket协议-Socket.io 服务端API","categories":[{"name":"socket.io","slug":"socket-io","permalink":"http://blog.curtaintan.club/categories/socket-io/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://blog.curtaintan.club/tags/%E5%85%A5%E9%97%A8/"},{"name":"总结","slug":"总结","permalink":"http://blog.curtaintan.club/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"vscode相关配置","slug":"vscode相关配置","date":"2020-01-06T02:57:53.000Z","updated":"2020-01-06T03:05:25.798Z","comments":true,"path":"2020/01/06/vscode相关配置/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/vscode%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"记录自己常用的一些配置…","text":"记录自己常用的一些配置… 打开setting.json配置文件 VSCode实现用Ctrl+滚轮实现代码的缩放配置文件如下： 在文件–&gt;首选项–&gt;设置–&gt;用户设置中添加如下代码： 1\"editor.mouseWheelZoom\": true","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.curtaintan.club/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vsCode","slug":"vsCode","permalink":"http://blog.curtaintan.club/tags/vsCode/"}]},{"title":"一个小demo弄懂vue的$nextTick","slug":"一个小demo弄懂vue的$nextTick","date":"2020-01-06T01:51:23.000Z","updated":"2020-01-31T01:31:37.853Z","comments":true,"path":"2020/01/06/一个小demo弄懂vue的$nextTick/","link":"","permalink":"http://blog.curtaintan.club/2020/01/06/%E4%B8%80%E4%B8%AA%E5%B0%8Fdemo%E5%BC%84%E6%87%82vue%E7%9A%84$nextTick/","excerpt":"一个小demo弄懂vue的$nextTick的作用","text":"一个小demo弄懂vue的$nextTick的作用 有这样一段代码： 代码截图： 123456789101112131415161718192021222324252627&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;span id=\"span\" v-if=\"showSpan\" &gt;span&lt;/span&gt; &lt;button @click=\"btn\" &gt;显示&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data: &#123; showSpan: false &#125;, methods: &#123; btn()&#123; this.showSpan = true console.log( document.querySelector(\"span\") ) setTimeout( () =&gt; &#123; console.log( \"200毫秒后\" ) console.log( document.querySelector(\"span\") ) &#125;, 200 ) this.$nextTick( () =&gt; &#123; console.log( \"$nextTick执行的结果\" ) console.log( document.querySelector(\"span\") ) &#125; ) &#125; &#125; &#125;)&lt;/script&gt; 执行结果： 分析第一个结果为null，因为没有找到dom元素，第二个出现的是$nextTick执行的结果，是确定dom重新渲染挂载完毕执行的回调函数第三个才是定时器的结果，是在最后执行的函数。 结论可知，vue中数据更新引起的dom更新是异步执行的。 小拓展v-if和v-show的区别当我们把上文的 v-if 改成 v-show 后，我们可以看到： 可以看出，v-if=false 时，元素不会渲染到页面，使用 v-show 元素一直在页面中，只是设置样式 display: none; 没有显示而已，","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.curtaintan.club/tags/vue/"}]},{"title":"正则之给字符串来一套增删改查服务","slug":"正则之给字符串来一套增删改查服务","date":"2020-01-03T13:47:46.000Z","updated":"2020-01-04T15:16:16.829Z","comments":true,"path":"2020/01/03/正则之给字符串来一套增删改查服务/","link":"","permalink":"http://blog.curtaintan.club/2020/01/03/%E6%AD%A3%E5%88%99%E4%B9%8B%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E4%B8%80%E5%A5%97%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%9C%8D%E5%8A%A1/","excerpt":"想学习正则的操作吗？？那就进来吧…","text":"想学习正则的操作吗？？那就进来吧… 导读嗨咯，亲爱的读者你好！既然你点进来了，那么想必你一定对正则感兴趣吧。 如果你对正则充满畏惧心理，不懂也不理解正则，没关系，往下看， 看完这篇文章，相信你一定会对正则充满兴趣，并且不再畏惧，消灭恐惧的最好办法，就是面对恐惧！！ 加油！！读完它，理解正则操作，然后爱上正则！ 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 @老姚JS正则表达式完整教程（略长） 老姚对正则的评价非常到位，我很赞同，希望你能记住，这篇文章就是在匹配的基础上做的相关的操作。 如果你没有正则的基础，请不要害怕，这篇文章会一步一步的带你了解正则相关的操作，每个操作的案例相对简单易理解，但是展示出了每个操作的作用。在阅读文章前，请仔细的阅读前置知识，了解相关api的作用。 如果你学习过正则，对正则有一定了解，那么这篇文章非常适合你，这篇文章可以加深你对正则用法的理解。 如果你是正则高手，文中有写的不对的和写得不妥当的，也请指出错误。 本文不涉及正则表达式的书写教学，但是并影响你对每个增删查改操作的理解。如果你想学习正则表达式的书写，在文章后面我有推荐学习正则的优秀文章。 相信你看过这篇文章后，会提高你对正则的理解与学习正则的兴趣。加油！ 前置知识既然是用正则对字符串的操作，那么，我们得需要了解相关的方法，对吧？？与正则相关的方法就6个（真的很少很容易理解！！）：如果你对下面六个方法非常熟悉了，你可以直接从前置知识的总结处开始看（￣︶￣）↗ 与正则相关的6个方法12345678// 字符串四个String#search // 查找匹配到字符串的位置，返回位置indexString#split // 以正则匹配到的字符串截断原字符串，返回数组String#match // 匹配字符串并返回一些信息String#replace // 对匹配到的字符串进行替换，返回修改后的字符串// 正则两个RegExp#test // 匹配字符串是否有符合正则的部分RegExp#exec // 匹配字符串，并返回相关信息 1.String#search语法：str.search(regexp) 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. search1234var regex = /\\d/var string = \"abc123\"console.log( string.search(regex) )// =&gt; 3 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 2.String#split语法：str.split(separator, limit) 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 split1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex, 2) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.String#match语法：str.match(regexp) 定义：查找出与正则相匹配的项。 返回值： 正则的匹配模式为全局匹配：返回匹配的数组或则null 正则的匹配模式不是为全局匹配：返回匹配到的项，groups：分组，index:找到结果的索引,input:原字符串 match1234567var str = \"aa22bb313cc444ff\"var reg = /\\d+/gvar reg1 = /(\\d+)([a-z]+)(\\d+)/console.log( str.match( reg ) )console.log( str.match( reg1 ) )// =&gt; [\"22\", \"313\", \"444\"]// =&gt; [\"22bb313\", \"22\", \"bb\", \"313\", index: 2, input: \"aa22bb313cc444\", groups: undefined] 注意： 当传入的参数是字符串时，会把字符串转成正则表达式。 4.String#replace语法：str.replace( regexp | substr, newSubStr | function ) 参数说明： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 用来创建新子字符串的函数，该子字符串用于替换与给定regexp或的匹配项substr。 参数function的参数说明： 第一个参数：整个正则或者字符串匹配到的字符串， 中间的参数：依次为正则中分组匹配到的字符串， 倒数第二个参数：找到结果的索引 倒数第一个参数：原字符串 str.replace( regexp, function )12345678var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; console.log( \"参数列表：\", str, s1, s2, index, sour ) console.log( arguments ) return s1 + \"---\" + s2&#125;)console.log( str ) 5.RegExp#test语法：reg.test( str ) 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false reg.test()1234var regex = /\\d/var string = \"abc123\"console.log( regex.test(string) )// =&gt; true 6.RegExp#exec语法：reg.exec( str ) 说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 reg.exec( str )12345var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gconsole.log( reg.exec( str ))console.log( reg.exec( str ))console.log( reg.exec( str )) 注意当使用全局模式时，exec函数会把这次匹配到的位置存放在当前正则reg的lastIndex里面，下次调用时，会从这次的最后位置开始查找。 总结通过上面简单的案例与说明，相信你已经可以看出我们要进行的增删改查操作应该用哪个方法了吧？我们来总结一下： 增：6个方法中，只有replace可以对匹配到的字符串进行操作，所以当我们需要在字符串中增加内容时，我们就可以使用replace方法。 删：6个方法中，split方法以匹配到的字符串为断点截断字符串返回数组，replace也可以对匹配到的字符串进行操作，所以删除可以使用split和replace方法。 查：6个方法中，除了split方法，都或多或少可以得到一些匹配到字符串的信息。 改：6个方法中，只有replace方法可以操作匹配到的字符串，所以修改只有用replace方法。 好了，下面详细的介绍下各种操作的详细情况。 1.增相信你一定遇到过往字符串里面加字符串的情况，你一般是怎么操作的呢？我们来分析下： 当向字符串中添加字符串时，有两种添加情况，一种：添加到匹配的字符串前，另一种是：添加到匹配的字符串后面。 是吧？？好，开始操作吧！ 添加到匹配字符串前：我们可以使用正则位置匹配表达式：(?=p)，正向肯定预查，其中p是一个子模式，即p前面的位置。 123var result = \"hello\".replace(/(?=ll)/g, '#')console.log(result)// =&gt; \"he#llo\" 也可以直接使用函数操作： 12345var result = \"hello\".replace(/(?=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"he#llo\" 添加到匹配字符串后：我们可以使用正则位置匹配表达式：(?&lt;=p)，反向肯定预查，就是p后面的位置。 12345var result = \"hello\".replace(/(?&lt;=ll)/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"hell#o\" 当然，你也可以直接使用replace的函数操作完成。 补充 在整个字符串前和后面添加， 12345var result = \"hello\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello#\" 在每个单词的前后面添加 12345var result = \"hello world\".replace(/^|$/g, function( str )&#123; return \"#\" + str&#125;)console.log(result)// =&gt; \"#hello# #world#\" 2.删：经过我们前面的总结，删除可以使用String.split和String.replace完成。 String.splite可以知道，使用splite方法返回的是一个数组，操作后，我们可以使用join()函数，返回字符串 1234var str = \"aa22bb313cc444ff\"var reg = /\\d+/console.log( str.split( reg ).join(\"\") )// =&gt; \"aabbccff\" String.replace使用replace就非常简单了，我们可以把第二个参数传 &quot;&quot; ,也可以用函数操作，返回 &quot;&quot;即可。 12345var str = \"aa22bb313cc444ff\"var reg = /\\d+/g // 全局模式，不加全局模式，只会替换一次str = str.replace( reg, \"\" )console.log( str )// =&gt; \"aabbccff\" 3.查查找可以分为两类：一种是需要详细结果的，一种是不需要详细结果的。 不需要详细结果不需要详细结果就是返回 true 和 false 就可以了。这里可以使用test 验证电话号码123var reg = /^1[345789]\\d&#123;9&#125;$/var res = reg.test( \"13882628333\" )// =&gt; true 需要详细结果使用String.match()获取时间123var reg = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( \"2017-06-10\".match( reg ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var string = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( string.match( reg ))// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] match获取全部的颜色代码（正则使用g全局匹配模式）1234var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"console.log( str.match( reg ) )// =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 使用reg.exec()获取时间123var regex = /^([0-9]&#123;4&#125;)-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log( reg.exec( \"2017-06-10\" ) )// =&gt; [\"2017-06-10\", \"2017\", \"06\", \"10\", index: 0, input: \"2017-06-10\", groups: undefined] 获取类名1234var reg = /class=\\\"(.*)?\"/var str = '&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;'console.log( reg.exec( str ) )// =&gt; [\"class=\"main box\"\", \"main box\", index: 20, input: \"&lt;div id=\"container\" class=\"main box\"&gt;&lt;/div&gt;\", groups: undefined] exec获取全部的颜色代码（正则使用g全局匹配模式）12345678var reg = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/gvar str = \"#ffbbad #Fc01DF #FFF #ffE\"var arr = []var tempwhile( temp = reg.exec( str ) )&#123; arr.push( temp[0] )&#125;console.log( arr ) 4.改经过前面的终结，我们知道只有replace可以进行修改操作： 1234567var str = \"aa22bb313cc444ff\"var reg = /(\\d+)(\\w&#123;1&#125;)/gstr = str.replace( reg, function( str, s1, s2, index, sour )&#123; return s1 + \"---\" + s2&#125;)console.log( str )// =&gt; \"aa22---bb313---cc444---ff\" 后记写下这篇文章，就是想让自己梳理下正则相关的api与用法，加强一下自己写正则的信心。 看了这篇文章，你是否对正则又有了新的理解呢？对自己写正则是否又增加了几分信心呢？ 总结本文主要讲述了正则的相关用法，考虑到正则新手，所以每个操作都只是做的很简单的案例，正则表达式大都很简单，但是，我相信，看了本文，你会更有信心去学习正则。 学习正则：如果你想学习正则表达式的书写，我这里将推荐一些好的文章给你： 老姚-JS正则表达式完整教程（略长） 非常推荐的一篇文章，我就是看这篇文章学习的正则，适合有一点正则基础的同学 考拉海前端团队—JS 的正则表达式 条理清晰–适合初学者学习正则的书写 文章在精不在多，这两篇文章对初学正则的同学非常友好，能引导你写出优秀的正则表达式，再结合这篇文章对正则表达式的运用，相信你会对正则的运用游刃有余。 参考资料：老姚-JS正则表达式完整教程（略长） MDN-String.prototype.match() MDN-String.prototype.replace() 共勉写下这篇文章，希望对你有帮助，与君共勉！","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"博客再次启程","slug":"博客再次启程","date":"2019-12-02T09:52:17.000Z","updated":"2020-02-07T15:56:26.796Z","comments":true,"path":"2019/12/02/博客再次启程/","link":"","permalink":"http://blog.curtaintan.club/2019/12/02/%E5%8D%9A%E5%AE%A2%E5%86%8D%E6%AC%A1%E5%90%AF%E7%A8%8B/","excerpt":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！","text":"换了博客的主题，页面美观多了，心情也舒畅多了。更加有动力写博客了，整理好心情，重新出发！！ 碎碎念经过一天的配置，博客搭建的差不多了， 整理好心情！！！ 重新出发！","categories":[{"name":"我的随笔","slug":"我的随笔","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.curtaintan.club/tags/%E7%94%9F%E6%B4%BB/"}],"author":{"avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png","url":"http://blog.curtaintan.club/"}},{"title":"drawing-board画板","slug":"drawing-board画板","date":"2019-08-14T08:04:55.000Z","updated":"2020-02-06T05:21:32.102Z","comments":true,"path":"2019/08/14/drawing-board画板/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/drawing-board%E7%94%BB%E6%9D%BF/","excerpt":"canvas写的画板","text":"canvas写的画板 快到碗里来-画板 预览：点击 前言： 之前学完canvas，一直想自己写一点东西，这两天终于完成了，开心！！ 完成功能： 绘画 画直线 截图 旋转 弹幕 鼠标触碰弹幕，弹幕悬停 撤销/前进 设置画笔信息 兼容移动端 功能截图： 前置说明如果你需要参考代码，你需要看下这里。因为功能复杂，标志的变量有接近10个之多，一下子可能很难看懂，所以我这里说明下我的开发流程，以及定义变量的顺序。 功能顺序： 画笔 → 定义画笔信息 → 橡皮檫 → 删除 → 撤销/前进 → 直线 → 截图 → 弹幕 定义变量的顺序，以及作用： 所有功能变量： 1234567891011121314151617181920212223242526272829303132333435363738var isDown = false // 标志鼠标是否按下 绘图三步和剪切三步走时，后面两个事件触发的标志var points = [] // 滑动时收集的点 绘画三步走时，为了时画的线光滑，记录点，减短画线的距离var beginPoint = null // 开始的点 绘画三步走时使用----这三个为一组，画线三人组，为了让画的线更为光滑var currentMenu = \"icon-pen\" // 初始按钮 底部按钮选中的按钮var currentColor = 0 // 初始颜色的index 颜色选择，默认第一个var paintingModal = \"pen\" // 画笔模式 line||pen||cut----按钮功能三人组，按钮选中标记，颜色选中，画画的模式，切换前面画笔和画直线的模式var lookModal = false // 鼠标模式 按钮第一个功能，此模式不能绘画，只能看var cuted = false // 标记裁剪时，是否已经裁剪 裁剪后，防止后续的操作再次触发裁剪操作 ----鼠标模式和剪切模式的定义var animationTimer = null // 弹幕动画的timer 动画的timervar barrageArray = [] // 保存弹幕的数组var globalPoint = &#123; x : 0, y : 0 &#125; // canvas上鼠标的点 ---弹幕时使用----弹幕三人组 globalPoint用来标记鼠标在canvas中的坐标，用于判断鼠标是否触碰到弹幕上// 实现撤销和重做的功能let canvasHistory = [] // canvas数据，在每次画线和橡皮檫使用后保存数据let step = 0 // 画笔抬起的步数，清空时，步数也清空----撤销/前进二人组，画笔抬起时，把画布信息用getImageData存入canvasHistory，用step完成前进和撤销的功能var penAttibutes = &#123; // 画笔数据， width : 2, lineCap : \"round\", lineJoin : \"round\", strokeStyle: \"#000\", fillStyle: \"#000\", globalCompositeOperation: \"source-over\", globalAlpha : 1&#125; 开发中遇到的难点与重点与解决方案： 保存历史记录使用api对比 我在写代码的时候有做过参考 这篇文章，文章里用是canvas.toDataUrl的方式做的数据保存，评论里说这个数据保存不理想，其实我一开始的时候想的就是用ctx.getImageDaata的方式来做的，我也用这个两个api做了一个对比： 代码： 结果： 可见，使用getImageData获取数据是时间是非常短的，并且获取到是画布像素数据，后续可以直接进行像素操作，从而不用再花时间再去获取画布信息，其次，getImageData获取到是数据是有数据结构的，这样在内存里面保存下来对内存更加友好，而使用toDataUrl方式保存下来的数据有21万行那么长的字符串，对内存并不友好。 后面我还做了他们绘制到画布上的时间对比，他们的时间都在1ms内，到时每次putImageData都要快一点点，但是快这一点时间的意义并不大。 toDataUrl也是有好处的，因为转置出来的是base64的字符串，所以他能够直接作为图片的src属性，让图片显示到页面。 画直线 如何画出一条直线？？当我做了撤销和前进的时候，我就把画板数据给存到canvasHistory里面了，这里刚好用到，鼠标移动是时候，先清空画布，再绘制保存到canvasHistory里最后那个数据，然后就是绘图三步走，就完成了。 注意：这里一定要绘图三步走，或者在绘制前一定要用beginPath()重开一条路径，如果不重开路径，绘制时，会把前面的直线一同绘制出来，因为你一直是一条路径，所以下次绘制时，上次的点也要绘制一遍。 图片旋转 旋转很类似css3，但是，canvas的基点固定在左上角处，所以在旋转的时候，需要先用translate移动画板，可以画一下图， 下面是我画的图： 问题： 当我画笔有rotate属性的时候，当前操作的putImageData不会成功，不知道为什么----- 如何画出一条光滑的曲线 用正常的画法画曲线是时候，画出的曲线不够光滑， 所以我就参考了这篇文章 canvas进阶——如何画出平滑的曲线? （其实我也想到了用二次贝塞尔曲线，在寻找更好的解决方案时，就找到这个方法了，这个方案更优），原理可以看原文。 鼠标触摸弹幕 因为canvas是无记忆性的，所以，你用isPointPath和isPointStroke时，是在当前绘画下才能检测。 在使用isPointPath时，他只与path路径有关，意思就是，你用fillRect直接绘制一个矩形图形是不能检测的， 只能检测rect()和pathTo等围起来的路径内。 所以，这里我做了一个外挂路径-用rect()把每个弹幕框起来——哈哈– 使用drawImage须知： drawImage有三种传参方式，三种方式出来的效果，在书写前可以先参考效果。 参考地址：CanvasRenderingContext2D.drawImage 兼容移动端 当在移动端时，会存在移动端延时300ms的问题，因为移动端有双击放大功能，故存在300ms时间。 我解决的方法是设置meta信息，禁止缩放，就可以防止300ms问题 结语：这个项目大概用了canvas的75%的api，还有像素操作和渐变等api还没用到。 不知道有没有人看呢， 如果你看到了这篇文章，希望对你有帮助。 慢慢来，好好学习，要加油哦！ 与君共勉！！ 参考材料： 手把手教你实现一个canvas智绘画板 参考了楼主项目的样式，但是所有样式都是我自己写的，嘻嘻，实现方式不一样哦。。 canvas进阶——如何画出平滑的曲线? 画一条光滑的曲线，不错哦。 canvas动画包教不包会 可以在这里把所有api的意义和作用和参数等都记下来—– Canvas API中文文档首页地图 canvas所有的api，当然你也可以去mdn看，其实都一样啦—","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://blog.curtaintan.club/categories/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://blog.curtaintan.club/tags/canvas/"}]},{"title":"正则小记（一）之api速学","slug":"正则小记（一）之api速学","date":"2019-08-14T08:04:55.000Z","updated":"2020-01-02T04:43:51.427Z","comments":true,"path":"2019/08/14/正则小记（一）之api速学/","link":"","permalink":"http://blog.curtaintan.club/2019/08/14/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8Bapi%E9%80%9F%E5%AD%A6/","excerpt":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章…","text":"作为一个前端，正则是必须要会的技能之一，所以，让我们开始学习正则吧。 这是正则学习的第一篇文章… 前言正则，用简短的一句话概括，正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则的方法和与正则有关的方法共有6个，字符串实例4个，正则实例2个： String#search String#split String#match String#replace RegExp#test RegExp#exec 1.search()定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1234var regex = /\\d/;var string = \"abc123\";console.log( string.search(regex) );// =&gt; 3 2.split定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 例子： 1234567var regex = /\\D/console.log( \"2017/06/26\".split(regex) )console.log( \"2017.06.26\".split(regex) )console.log( \"2017-06-26\".split(regex) )// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"] 3.match定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则： 匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( string.match(regex) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 4.replace语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. replace后面单独写一篇文章总结 案例： 12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";var date = [];string.replace(regex, function(match, year, month, day) &#123; date.push(year, month, day);&#125;);console.log(date);// =&gt; [\"2017\", \"06\", \"26\"] 5.test说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1234var regex = /\\d/;var string = \"abc123\";console.log( regex.test(string) );// =&gt; true 6.exec说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 这个方法很类似match方法。 案例： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( regex.exec(string) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 相关API注意要点-1 search和match的参数问题我们知道字符串实例的那4个方法参数都支持正则和字符串。 但search和match，会把字符串转换为正则的。 1234567891011121314151617181920212223var string = \"2017.06.27\";console.log( string.search(\".\") );// =&gt; 0//需要修改成下列形式之一console.log( string.search(\"\\\\.\") );console.log( string.search(/\\./) );// =&gt; 4// =&gt; 4console.log( string.match(\".\") );// =&gt; [\"2\", index: 0, input: \"2017.06.27\"]//需要修改成下列形式之一console.log( string.match(\"\\\\.\") );console.log( string.match(/\\./) );// =&gt; [\".\", index: 4, input: \"2017.06.27\"]// =&gt; [\".\", index: 4, input: \"2017.06.27\"]console.log( string.split(\".\") );// =&gt; [\"2017\", \"06\", \"27\"]console.log( string.replace(\".\", \"/\") );// =&gt; \"2017/06.27\" 2 match返回结果的格式问题match返回结果的格式，与正则对象是否有修饰符g有关。 1234567var string = \"2017.06.27\";var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; [\"2017\", \"06\", \"27\"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有g，返回的是所有匹配的内容。 3 exec比match更强大当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。 而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配： 123456789101112131415161718var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"]// =&gt; 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"] 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"] 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"] 10 4 修饰符g，对exex和test的影响上面提到了正则实例的lastIndex属性，表示尝试匹配时，从字符串的lastIndex位开始去匹配。 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。 而正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。下面让我们以test为例，看看你是否会迷糊： 1234567var regex = /a/g;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 1// =&gt; true 3// =&gt; false 0 注意上面代码中的第三次调用test，因为这一次尝试匹配，开始从下标lastIndex即3位置处开始查找，自然就找不到了。 如果没有g，自然都是从字符串第0个字符处开始尝试匹配： 1234567var regex = /a/;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 0// =&gt; true 0// =&gt; true 0 5 test整体匹配时需要使用^和$这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： 123456console.log( /123/.test(\"a123b\") );// =&gt; trueconsole.log( /^123$/.test(\"a123b\") );// =&gt; falseconsole.log( /^123$/.test(\"123\") );// =&gt; true 6 split相关注意事项split方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： 123var string = \"html,css,javascript\";console.log( string.split(/,/, 2) );// =&gt;[\"html\", \"css\"] 7 replace是很强大的 《JavaScript权威指南》认为exec是这6个API中最强大的，而我始终认为replace才是最强大的。 因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号例如，把”2,3,5”，变成”5=2+3”： 123var result = \"2,3,5\".replace(/(\\d+),(\\d+),(\\d+)/, \"$3=$1+$2\");console.log(result);// =&gt; \"5=2+3\" 又例如，把”2,3,5”，变成”222,333,555”: 123var result = \"2,3,5\".replace(/(\\d+)/g, \"$&amp;$&amp;$&amp;\");console.log(result);// =&gt; \"222,333,555\" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”: 123var result = \"2+3=5\".replace(/=/, \"$&amp;$`$&amp;$'$&amp;\");console.log(result);// =&gt; \"2+3=2+3=5=5\" 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： 123456\"1234 2345 3456\".replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function(match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; [\"1234\", \"1\", \"4\", 0, \"1234 2345 3456\"]// =&gt; [\"2345\", \"2\", \"5\", 5, \"1234 2345 3456\"]// =&gt; [\"3456\", \"3\", \"6\", 10, \"1234 2345 3456\"] 此时我们可以看到replace拿到的信息，并不比exec少。 8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多\\。 12345678var string = \"2017-06-27 2017.06.27 2017/06/27\";var regex = /\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/g;console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"]regex = new RegExp(\"\\\\d&#123;4&#125;(-|\\\\.|\\\\/)\\\\d&#123;2&#125;\\\\1\\\\d&#123;2&#125;\", \"g\");console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"] 9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline10 source属性正则实例对象属性，除了global、ingnoreCase、multiline、lastIndex属性之外，还有一个source属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： 1234var className = \"high\";var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\");console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串\"(^|\\\\s)high(\\\\s|$)\" 11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是$1,…,$9之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp[&quot;$&apos;&quot;]测试代码如下： 1234567891011121314151617181920212223var regex = /([abc])(\\d)/g;var string = \"a1b2c3d4e5\";string.match(regex);console.log( RegExp.input );console.log( RegExp[\"$_\"]);// =&gt; \"a1b2c3d4e5\"console.log( RegExp.lastMatch );console.log( RegExp[\"$&amp;\"] );// =&gt; \"c3\"console.log( RegExp.lastParen );console.log( RegExp[\"$+\"] );// =&gt; \"3\"console.log( RegExp.leftContext );console.log( RegExp[\"$`\"] );// =&gt; \"a1b2\"console.log( RegExp.rightContext );console.log( RegExp[\"$'\"] );// =&gt; \"d4e5\" 结语： 我搜查列出了相关的6个方法，并对6个方法进行了说明。 后面我会对replace再单独出一篇文章。 参考资料里的第一篇文章真的非常好，值得仔细研读。 如果你想粗略了解正则的方法，看我这篇文章是没错了，后面列出的相应方法的坑点和注意点。 后面，我会再慢慢补充匹配规则，我会单独列出一篇文章，因为匹配规则也有很多注意点呢。 哈哈哈，其实也是在下面的文章里面看的啦，文章真的写得好---嘻嘻 其实正则也没有那么难的啦----- 希望这篇文章对你有帮助，每天都要加油哦。 加油，与君共勉！！！参考资料： JS正则表达式完整教程（略长） 文章真的写的不错，认认真真，细嚼慢咽的看完这篇文章，保证你学会正则。 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。 MDN-RegExp MDN-String","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.curtaintan.club/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"}]}]}