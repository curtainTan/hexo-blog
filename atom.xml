<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>curTain</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.curtaintan.club/"/>
  <updated>2020-10-20T08:30:11.636Z</updated>
  <id>http://blog.curtaintan.club/</id>
  
  <author>
    <name>tanTantan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10.20-每日一题--重排链表</title>
    <link href="http://blog.curtaintan.club/2020/10/20/10-20-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/20/10-20-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-20T08:22:32.000Z</published>
    <updated>2020-10-20T08:30:11.636Z</updated>
    
    <content type="html"><![CDATA[<ol start="143"><li>重排链表</li></ol><a id="more"></a><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></h2><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><blockquote><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p></blockquote><p>示例 2:</p><blockquote><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p></blockquote><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>遍历链表，将节点存入数组，再依次前后取出元素即可</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reorderList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">while</span>( head )&#123;</span><br><span class="line">        arr.push( head )</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> ListNode()</span><br><span class="line">    <span class="keyword">let</span> node = newNode</span><br><span class="line">    <span class="keyword">while</span>( arr.length )&#123;</span><br><span class="line">        <span class="keyword">let</span> item = arr.shift()</span><br><span class="line">        item.next = <span class="literal">null</span></span><br><span class="line">        node.next = item</span><br><span class="line">        node = node.next</span><br><span class="line">        item = arr.pop()</span><br><span class="line">        <span class="keyword">if</span>( item )&#123;</span><br><span class="line">            item.next = <span class="literal">null</span></span><br><span class="line">            node.next = item</span><br><span class="line">            node = node.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;143&quot;&gt;
&lt;li&gt;重排链表&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="链表" scheme="http://blog.curtaintan.club/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>10.19-每日一题--比较含退格的字符串</title>
    <link href="http://blog.curtaintan.club/2020/10/19/10-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/19/10-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-19T08:57:05.000Z</published>
    <updated>2020-10-19T11:18:30.271Z</updated>
    
    <content type="html"><![CDATA[<ol start="844"><li>比较含退格的字符串</li></ol><a id="more"></a><h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a>844. 比较含退格的字符串</h2><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><p>示例 1：</p><blockquote><p>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。</p></blockquote><p>示例 2：</p><blockquote><p>输入：S = “ab##”, T = “c#d#”<br>输出：true<br>解释：S 和 T 都会变成 “”。</p></blockquote><p>示例 3：</p><blockquote><p>输入：S = “a##c”, T = “#a#c”<br>输出：true<br>解释：S 和 T 都会变成 “c”。</p></blockquote><p>示例 4：</p><blockquote><p>输入：S = “a#c”, T = “b”<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用正则匹配，替换元素</p><p><strong>注意</strong></p><p>使用模式匹配符 <code>g</code> 时，正则会记录当前匹配的位置到 <code>lastIndex</code> 上，下次匹配时，会从 <code>lastIndex</code> 处开始匹配</p><p><strong>测试</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/.?#/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"ab##"</span>.replace( reg, <span class="string">""</span> )</span><br><span class="line"><span class="built_in">console</span>.log( str ) <span class="comment">// a         第一次匹配 b#   第二次匹配 #</span></span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backspaceCompare = <span class="function"><span class="keyword">function</span>(<span class="params">S, T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/.?#/</span></span><br><span class="line">    <span class="keyword">while</span>( reg.test( S ) )&#123;</span><br><span class="line">        S = S.replace( <span class="regexp">/.?#/</span>, <span class="string">""</span> )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( reg.test( T ) )&#123;</span><br><span class="line">        T = T.replace( <span class="regexp">/.?#/</span>, <span class="string">""</span> )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S === T</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;844&quot;&gt;
&lt;li&gt;比较含退格的字符串&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="正则" scheme="http://blog.curtaintan.club/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉查找树</title>
    <link href="http://blog.curtaintan.club/2020/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://blog.curtaintan.club/2020/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-10-16T07:33:07.000Z</published>
    <updated>2020-10-16T11:50:37.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="api-设计"><a href="#api-设计" class="headerlink" title="api 设计"></a>api 设计</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    root = <span class="literal">null</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    size()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n</span><br><span class="line">    &#125;</span><br><span class="line">    putNode( key, value )&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.put( <span class="keyword">this</span>.root, key, value )</span><br><span class="line">    &#125;</span><br><span class="line">    put( node, key, value )&#123;</span><br><span class="line">        <span class="keyword">if</span>( node === <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">this</span>.n ++</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode( key, value, <span class="literal">null</span>, <span class="literal">null</span> )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 node 子树不为空</span></span><br><span class="line">        <span class="comment">// 比较 node 节点的键和 key 的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key &gt; node.key )&#123;</span><br><span class="line">            <span class="comment">// 如果 key 大于 node 节点的键，则继续找 node 的右子节点</span></span><br><span class="line">            node.right = <span class="keyword">this</span>.put( node.right, key, value )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node.key )&#123;</span><br><span class="line">            <span class="comment">//  如果小于 node 节点的键，继续寻找左子节点</span></span><br><span class="line">            node.left = <span class="keyword">this</span>.put( node.left, key, value )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相等，替换当前节点的值</span></span><br><span class="line">            node.value = value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    getValue( key )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get( <span class="keyword">this</span>.root, key )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>( node, key )&#123;</span><br><span class="line">        <span class="keyword">if</span>( node === <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较 key 和 x 节点的键的大小</span></span><br><span class="line">        <span class="keyword">if</span>( key &gt; node.key )&#123;</span><br><span class="line">            <span class="comment">// key 大于当前节点，继续寻找右节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">get</span>( node.right, key )</span><br><span class="line">        &#125; else if( key &lt; node.key )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">get</span>( node.left, key )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除树中 key 对应的节点，并返回删除后的新树</span></span><br><span class="line">    deleteNode( key )&#123;</span><br><span class="line">        <span class="keyword">this</span>.delete( <span class="keyword">this</span>.root, key )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>( node, key )&#123;</span><br><span class="line">        <span class="keyword">if</span>( node === <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( key &gt; node.key )&#123;</span><br><span class="line">            node.right = <span class="keyword">this</span>.delete( node.right, key )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node.key )&#123;</span><br><span class="line">            node.left = <span class="keyword">this</span>.delete( node.left, key )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 相等，删除当前节点</span></span><br><span class="line">            <span class="keyword">this</span>.n --</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判定当前节点是否只有一个子节点，只有一个子节点，就把那个子节点接到父节点</span></span><br><span class="line">            <span class="keyword">if</span>( !node.left )&#123;</span><br><span class="line">                <span class="keyword">return</span> node.right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !node.right )&#123;</span><br><span class="line">                <span class="keyword">return</span> node.left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两个子节点都在，获取右子节点最小的子节点，</span></span><br><span class="line">            <span class="comment">// 为什么获取右边的，因为这样的交换操作次数可以最小</span></span><br><span class="line">            <span class="comment">// 如果是取左边最大值的话，需要不断的创建节点，交换顺序</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 得到右子树中最小的节点</span></span><br><span class="line">            <span class="keyword">let</span> minNode = node.right</span><br><span class="line">            <span class="keyword">while</span>( minNode.left !== <span class="literal">null</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>( minNode.left.left === <span class="literal">null</span> )&#123;</span><br><span class="line">                    <span class="keyword">let</span> temp = minNode.left</span><br><span class="line">                    <span class="comment">// 删除右子树中最小的节点</span></span><br><span class="line">                    minNode.left = <span class="literal">null</span></span><br><span class="line">                    minNode = temp</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    minNode = minNode.left</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让 node 节点的左子树成为 minNode 的左子树</span></span><br><span class="line">            minNode.left = node.left</span><br><span class="line">            <span class="comment">// 让 node 节点的左子树成为 minNode 的右子树</span></span><br><span class="line">            minNode.right = node.right</span><br><span class="line">            <span class="comment">// 让 node 节点的父节点指向 minNode 节点</span></span><br><span class="line">            node = minNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在整颗树中查找最小的键</span></span><br><span class="line">    getTreeMin()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getNodeMin( <span class="keyword">this</span>.root )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getNodeMin( node )&#123;</span><br><span class="line">        <span class="keyword">if</span>( node.left )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getNodeMin( node.left )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在整颗树中找最大的值</span></span><br><span class="line">    getTreeMax()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getNodeMax( <span class="keyword">this</span>.root )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getNodeMax( node )&#123;</span><br><span class="line">        <span class="keyword">if</span>( node.right )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getNodeMax( node.right )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定树中的所有节点,并将节点的 key 放入到队列中</span></span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    preMap( node, queue=[] )&#123;</span><br><span class="line">        <span class="keyword">if</span>( !node ) <span class="keyword">return</span></span><br><span class="line">        queue.push( node.key )</span><br><span class="line">        <span class="comment">// 递归左子节点</span></span><br><span class="line">        node.left &amp;&amp; <span class="keyword">this</span>.preMap( node.left, queue )</span><br><span class="line">        <span class="comment">// 递归右子节点</span></span><br><span class="line">        node.right &amp;&amp; <span class="keyword">this</span>.preMap( node.right, queue )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    midMap( node, queue=[] )&#123;</span><br><span class="line">        <span class="keyword">if</span>( !node ) <span class="keyword">return</span></span><br><span class="line">        node.left &amp;&amp; <span class="keyword">this</span>.midMap( node.left, queue )</span><br><span class="line">        queue.push( node.key )</span><br><span class="line">        node.right &amp;&amp; <span class="keyword">this</span>.midMap( node.right, queue )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    afterMap( node, queue=[] )&#123;</span><br><span class="line">        <span class="keyword">if</span>( !node ) <span class="keyword">return</span></span><br><span class="line">        node.left &amp;&amp; <span class="keyword">this</span>.midMap( node.left, queue )</span><br><span class="line">        node.right &amp;&amp; <span class="keyword">this</span>.midMap( node.right, queue )</span><br><span class="line">        queue.push( node.key )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    layerMap()&#123;</span><br><span class="line">        <span class="comment">// 定义两个队列，一个存储 key，另一个存储节点</span></span><br><span class="line">        <span class="keyword">let</span> keys = []</span><br><span class="line">        <span class="keyword">let</span> queue = [ <span class="keyword">this</span>.root ]</span><br><span class="line">        <span class="keyword">while</span>( queue.length )&#123;</span><br><span class="line">            <span class="keyword">let</span> item = queue.shift()</span><br><span class="line">            keys.push( item.key )</span><br><span class="line">            item.left &amp;&amp; queue.push( item.left )</span><br><span class="line">            item.right &amp;&amp; queue.push( item.right )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回整个树的高度</span></span><br><span class="line">    getTreeDepth()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getNodeDepth( <span class="keyword">this</span>.root )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回指定树的高度</span></span><br><span class="line">    getNodeDepth( node )&#123;</span><br><span class="line">        <span class="keyword">if</span>( !node ) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> maxL = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> maxR = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 左子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span>( !node.left )&#123;</span><br><span class="line">            maxL = <span class="keyword">this</span>.getNodeDepth( node.left )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span>( !node.right )&#123;</span><br><span class="line">            maxR = <span class="keyword">this</span>.getNodeDepth( node.right )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = maxL &gt; maxR ? maxL+<span class="number">1</span> : maxR+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binaryTree = <span class="keyword">new</span> BinaryTree()</span><br><span class="line"></span><br><span class="line">binaryTree.putNode( <span class="number">1</span>, <span class="number">1</span> )</span><br><span class="line">binaryTree.putNode( <span class="number">9</span>, <span class="number">9</span> )</span><br><span class="line">binaryTree.putNode( <span class="number">2</span>, <span class="number">2</span> )</span><br><span class="line">binaryTree.putNode( <span class="number">8</span>, <span class="number">8</span> )</span><br><span class="line">binaryTree.putNode( <span class="number">3</span>, <span class="number">3</span> )</span><br><span class="line">binaryTree.putNode( <span class="number">7</span>, <span class="number">7</span> )</span><br><span class="line">binaryTree.putNode( <span class="number">4</span>, <span class="number">4</span> )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"搜索树："</span>, binaryTree )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> min = binaryTree.getTreeMin()</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"最小值："</span>, min )</span><br><span class="line"><span class="keyword">let</span> max = binaryTree.getTreeMax()</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"最小值："</span>, max )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">let</span> premap = binaryTree.layerMap()</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"前序："</span>, premap )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;api-设计&quot;&gt;&lt;a href=&quot;#api-设计&quot; class=&quot;headerlink&quot; title=&quot;api 设计&quot;&gt;&lt;/a&gt;api 设计&lt;/h2&gt;&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://blog.curtaintan.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="树" scheme="http://blog.curtaintan.club/tags/%E6%A0%91/"/>
    
      <category term="二叉查找树" scheme="http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://blog.curtaintan.club/2020/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://blog.curtaintan.club/2020/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</id>
    <published>2020-10-14T12:30:39.000Z</published>
    <updated>2020-10-16T07:37:20.051Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/10/14/0IDnHO.png" alt=""></p><p>经过一轮轮的秋招面试，体会到数据结构的重要性，打算系统的学习一遍</p><a id="more"></a><h2 id="api-设计"><a href="#api-设计" class="headerlink" title="api 设计"></a>api 设计</h2><h2 id="实现堆"><a href="#实现堆" class="headerlink" title="实现堆"></a>实现堆</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 储存堆中的元素</span></span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">        <span class="comment">// 记录堆中元素的个数</span></span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断堆中索引 i 处的元素是否小于索引 j 处的元素</span></span><br><span class="line">    less( i=<span class="number">0</span>, j=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[i] &lt; <span class="keyword">this</span>.items[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换堆中索引 i 和 j 处的值</span></span><br><span class="line">    swop( i=<span class="number">0</span>, j=<span class="number">0</span> )&#123;</span><br><span class="line">        [ <span class="keyword">this</span>.items[i], <span class="keyword">this</span>.items[j] ] = [ <span class="keyword">this</span>.items[j], <span class="keyword">this</span>.items[i] ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除堆中最大的元素，并返回这个最大的元素</span></span><br><span class="line">    deleteMax()&#123;</span><br><span class="line">        <span class="keyword">let</span> max = <span class="keyword">this</span>.items[ <span class="number">1</span> ]</span><br><span class="line">        <span class="comment">// 交换索引 1 处的元素与最大索引处的元素，让完全二叉树的最右侧元素变为根节点</span></span><br><span class="line">        <span class="keyword">this</span>.swop( <span class="number">1</span>, <span class="keyword">this</span>.n )</span><br><span class="line">        <span class="comment">// 删除最大元素</span></span><br><span class="line">        <span class="keyword">this</span>.items[ <span class="keyword">this</span>.n ] = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 元素个数 -1</span></span><br><span class="line">        <span class="keyword">this</span>.n --</span><br><span class="line">        <span class="comment">// 通过下沉调整堆，让堆重新有序</span></span><br><span class="line">        <span class="keyword">this</span>.sink( <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往堆中插入一个元素</span></span><br><span class="line">    insert( value )&#123;</span><br><span class="line">        <span class="keyword">this</span>.items[ ++<span class="keyword">this</span>.n ] = value</span><br><span class="line">        <span class="keyword">this</span>.swim( <span class="keyword">this</span>.n )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用上浮算法，使索引 k 处的元素能在堆中处于正确的位置</span></span><br><span class="line">    swim( k=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">// 父级链进行比较</span></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 比较当前节点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="keyword">this</span>.less( <span class="built_in">Math</span>.floor( k/<span class="number">2</span> ), k ) )&#123;</span><br><span class="line">                <span class="keyword">this</span>.swop( <span class="built_in">Math</span>.floor( k/<span class="number">2</span> ), k )</span><br><span class="line">            &#125;</span><br><span class="line">            k = <span class="built_in">Math</span>.floor( k/<span class="number">2</span> )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用下沉算法，使索引 k 处的元素能在堆中处于正确的位置</span></span><br><span class="line">    sink( k=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">// 通过循环不断对比当前 k 节点和其左子节点 2*k 以及 右子节点 2*k+1 处中较大值的元素</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= <span class="keyword">this</span>.n )&#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的子节点中较大的节点</span></span><br><span class="line">            <span class="keyword">let</span> max  <span class="comment">// 记录较大节点所在的索引</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="number">2</span>*k + <span class="number">1</span> &lt;= <span class="keyword">this</span>.n )&#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="keyword">this</span>.less( <span class="number">2</span>*k, <span class="number">2</span>*k + <span class="number">1</span> ) )&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较当前节点和较大节点的值</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="keyword">this</span>.less( max, k ) )&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换 k 索引处的值和 max 做阴处的值</span></span><br><span class="line">            <span class="keyword">this</span>.swop( k, max )</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 变换 k 的值</span></span><br><span class="line">            k = max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> myHeap = <span class="keyword">new</span> Heap()</span><br><span class="line">myHeap.insert(<span class="number">1</span>)</span><br><span class="line">myHeap.insert(<span class="number">2</span>)</span><br><span class="line">myHeap.insert(<span class="number">3</span>)</span><br><span class="line">myHeap.insert(<span class="number">4</span>)</span><br><span class="line">myHeap.insert(<span class="number">5</span>)</span><br><span class="line">myHeap.insert(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line"><span class="keyword">while</span>( (res = myHeap.deleteMax()) !== <span class="literal">null</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( res )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现堆排序的堆"><a href="#实现堆排序的堆" class="headerlink" title="实现堆排序的堆"></a>实现堆排序的堆</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 堆排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 heap 堆中索引 i 处的元素是否小于索引 j 处的元素</span></span><br><span class="line">    less( heap=[], i=<span class="number">0</span>, j=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i] &lt; heap[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换 heap 堆中 i 索引和 j 索引的值</span></span><br><span class="line">    swop( heap=[], i=<span class="number">0</span>, j=<span class="number">0</span> )&#123;</span><br><span class="line">        [ heap[i], heap[j] ] = [ heap[j], heap[i] ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据原数据 source，构造出堆 heap</span></span><br><span class="line">    createHeap( source=[], heap=[] )&#123;</span><br><span class="line">        <span class="comment">// 把 source 中的元素拷贝到 heap 中，heap 是一个无序堆</span></span><br><span class="line">        <span class="comment">// 将第一个元素空出来</span></span><br><span class="line">        heap.push( <span class="string">""</span>, ...source )</span><br><span class="line">        <span class="comment">// 对堆中的元素做下沉调整（从长度的一半开始下沉）</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="built_in">Math</span>.floor( source.length / <span class="number">2</span> ); i &gt; <span class="number">0</span>; i -- )&#123;</span><br><span class="line">            <span class="keyword">this</span>.sink( heap, i, heap.length<span class="number">-1</span> )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sink( heap=[], target=<span class="number">0</span>, range=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*target &lt;= range )&#123;</span><br><span class="line">            <span class="comment">// 找出当前节点较大的子节点</span></span><br><span class="line">            <span class="keyword">let</span> max</span><br><span class="line">            <span class="keyword">if</span>( <span class="number">2</span>*target+<span class="number">1</span> &lt;= range )&#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="keyword">this</span>.less( heap, <span class="number">2</span>*target, <span class="number">2</span>*target+<span class="number">1</span> ) )&#123;</span><br><span class="line">                    max = <span class="number">2</span>*target+<span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*target</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*target</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较当前节点的值和较大节点的值</span></span><br><span class="line">            <span class="keyword">if</span>( !<span class="keyword">this</span>.less( heap, target, max ) )&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.swop( heap, target, max )</span><br><span class="line">            target = max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort( source=[] )&#123;</span><br><span class="line">        <span class="comment">// 构建堆</span></span><br><span class="line">        <span class="keyword">let</span> newHeap = []</span><br><span class="line">        <span class="keyword">this</span>.createHeap( source, newHeap )</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"变换后的堆："</span>, newHeap )</span><br><span class="line">        <span class="comment">// 定义一个变量，记录为排序的元素中最大的索引</span></span><br><span class="line">        <span class="keyword">let</span> n = newHeap.length - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 通过循环，交换1索引处的元素和排序的元素中最大的索引的元素</span></span><br><span class="line">        <span class="keyword">while</span>( n &gt; <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 交换元素</span></span><br><span class="line">            <span class="keyword">this</span>.swop( newHeap, <span class="number">1</span>, n )</span><br><span class="line">            <span class="comment">// 排除交换后最大元素所在的索引，让他不要参与下沉</span></span><br><span class="line">            n --</span><br><span class="line">            <span class="comment">// 对索引1处的元素进行下沉调整</span></span><br><span class="line">            <span class="keyword">this</span>.sink( newHeap, <span class="number">1</span>, n )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把 heap 中的数据复制到原 source 中</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"交换后的堆："</span>, newHeap )</span><br><span class="line">        newHeap.shift()</span><br><span class="line">        source.length = <span class="number">0</span></span><br><span class="line">        source.push( ...newHeap )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// 待排序的数组</span></span><br><span class="line"><span class="keyword">let</span> sourceArr = [ <span class="string">"S"</span>,<span class="string">"O"</span>,<span class="string">"R"</span>,<span class="string">"T"</span>,<span class="string">"E"</span>,<span class="string">"X"</span>,<span class="string">"A"</span>,<span class="string">"M"</span>,<span class="string">"P"</span>,<span class="string">"L"</span>,<span class="string">"E"</span> ]</span><br><span class="line"><span class="comment">// 通过 heapSort 对数组进行排序</span></span><br><span class="line"><span class="keyword">let</span> heapSort = <span class="keyword">new</span> HeapSort()</span><br><span class="line">heapSort.sort( sourceArr )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( sourceArr )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0IDnHO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过一轮轮的秋招面试，体会到数据结构的重要性，打算系统的学习一遍&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://blog.curtaintan.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="堆" scheme="http://blog.curtaintan.club/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>10.14-每日一题--查找常用字符</title>
    <link href="http://blog.curtaintan.club/2020/10/14/10-14-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/14/10-14-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-14T01:26:53.000Z</published>
    <updated>2020-10-14T02:09:30.283Z</updated>
    
    <content type="html"><![CDATA[<ol start="1002"><li>查找常用字符</li></ol><a id="more"></a><h2 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a><a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符</a></h2><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：[“bella”, “label”, “roller”]<br>输出：[“e”, “l”, “l”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“cool”, “lock”, “cook”]<br>输出：[“c”, “o”]</p></blockquote><h2 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h2><ol><li>取出第一个元素，以第一个元素为基准迭代</li><li>在剩下的元素里面查找迭代的字母</li><li>找到就替换找到的字母，没找到就跳出此次循环</li><li>判断是否是最后一个元素，是就把当前元素存到 res 数组里</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> commonChars = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> A[<span class="number">0</span>] )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">1</span>; i &lt; A.length; i ++ )&#123;</span><br><span class="line">            <span class="keyword">let</span> index = A[i].indexOf( item )</span><br><span class="line">            <span class="keyword">if</span>( index === <span class="number">-1</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>( i === A.length - <span class="number">1</span> )&#123;</span><br><span class="line">                    res.push( item )</span><br><span class="line">                &#125;</span><br><span class="line">                A[i] = A[i].replace( item, <span class="string">""</span> )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h2><p>因为每个元素都必须含有该字母，故可以使用 <code>Array.every()</code> 函数来判定每个元素都存在该字母</p><p><strong>解释：</strong></p><p><code>Array.every( cb=()=&gt;{} )</code> 方法的每一项回调函数都返回 <code>true</code> 的时候，该方法返回 <code>true</code></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> commonChars = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> A[<span class="number">0</span>] )&#123;</span><br><span class="line">        <span class="keyword">if</span>( A.every( <span class="function"><span class="params">nowItem</span> =&gt;</span> nowItem.includes( item ) ) )&#123;</span><br><span class="line">            A = A.map( <span class="function"><span class="params">m</span> =&gt;</span> m.replace( item, <span class="string">"0"</span> ) )</span><br><span class="line">            res.push( item )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;1002&quot;&gt;
&lt;li&gt;查找常用字符&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="字符串" scheme="http://blog.curtaintan.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>10.13-每日一题--两两交换链表中的节点</title>
    <link href="http://blog.curtaintan.club/2020/10/13/10-13-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/13/10-13-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-13T08:17:39.000Z</published>
    <updated>2020-10-13T12:47:42.888Z</updated>
    
    <content type="html"><![CDATA[<ol start="24"><li>两两交换链表中的节点</li></ol><a id="more"></a><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1：</p><blockquote><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p></blockquote><p>示例 2：</p><blockquote><p>输入：head = []<br>输出：[]</p></blockquote><p>示例 3：</p><blockquote><p>输入：head = [1]<br>输出：[1]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>创建两个节点，一个返回时使用，另一个用于第一次操作</li><li>遍历时，取出前一个节点和操作的下一个节点，</li><li>交换两个节点的 next</li><li>连接前一个节点和操作的下一个节点</li><li>下移当前节点和前一个节点</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode()</span><br><span class="line">  res.next = head</span><br><span class="line">  <span class="keyword">let</span> pre = res</span><br><span class="line">  <span class="keyword">let</span> chain = res.next</span><br><span class="line">  <span class="keyword">while</span>( chain &amp;&amp; chain.next )&#123;</span><br><span class="line">      <span class="comment">// 获取操作节点和后续节点</span></span><br><span class="line">      <span class="keyword">let</span> next = chain.next</span><br><span class="line">      <span class="keyword">let</span> nextNext = next &amp;&amp; next.next</span><br><span class="line">      <span class="comment">// 修改 next</span></span><br><span class="line">      pre.next = next</span><br><span class="line">      chain.next = nextNext</span><br><span class="line">      next.next = chain</span><br><span class="line">      <span class="comment">// 赋值-下移</span></span><br><span class="line">      pre = chain</span><br><span class="line">      chain = nextNext</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;24&quot;&gt;
&lt;li&gt;两两交换链表中的节点&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="链表" scheme="http://blog.curtaintan.club/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>10.12-每日一题--二叉搜索树的最小绝对差</title>
    <link href="http://blog.curtaintan.club/2020/10/12/10-12-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/12/10-12-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-12T12:54:27.000Z</published>
    <updated>2020-10-12T13:00:14.811Z</updated>
    
    <content type="html"><![CDATA[<ol start="530"><li>二叉搜索树的最小绝对差</li></ol><a id="more"></a><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></h2><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><style>.bg-pre {    padding: 10px;    background: rgba(33,150,243,.2);    border-radius: 4px;}</style><p>示例：</p><p>输入：</p><pre class="bg-pre">   1    \     3    /   2</pre><p>输出：<br>1</p><p>解释：<br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由题可知树为排序二叉树，排序二叉树的特性是：中序遍历为升序</p><p>存下上一个节点的值，递归到下一个节点时，用下一个节点的值减上一个节点的值，依次递归，取最小值即可</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="built_in">Number</span>.MAX_SAFE_INTEGER, pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-1</span>) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="built_in">Math</span>.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;530&quot;&gt;
&lt;li&gt;二叉搜索树的最小绝对差&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="二叉树" scheme="http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="搜索树" scheme="http://blog.curtaintan.club/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="中序遍历" scheme="http://blog.curtaintan.club/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>10.10-每日一题--最小高度树</title>
    <link href="http://blog.curtaintan.club/2020/10/10/10-10-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/10/10-10-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-10T12:59:38.000Z</published>
    <updated>2020-10-10T14:51:08.307Z</updated>
    
    <content type="html"><![CDATA[<ol start="310"><li>最小高度树</li></ol><a id="more"></a><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></p><p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p><p>格式</p><p>该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。</p><p>你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。</p><p>示例 1:</p><style>.bg-pre {    padding: 10px;    background: rgba(33,150,243,.2);    border-radius: 4px;}</style><p>输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]</p><pre class="bg-pre">        0        |        1       / \      2   3 </pre><p>输出: [1]<br>示例 2:</p><p>输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</p><pre class="bg-pre">     0  1  2      \ | /        3        |        4        |        5 </pre><p>输出: [3, 4]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用邻接表存储树的节点</li><li>使用一个数组保存入度为以的节点</li><li>依次互相消除值</li><li>遍历数组，返回最后结果</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; edges</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinHeightTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n, edges</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储树</span></span><br><span class="line">    <span class="keyword">let</span> graph = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: n &#125;, ()=&gt;([]))</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> edges )&#123;</span><br><span class="line">        graph[item[<span class="number">0</span>]].push( item[<span class="number">1</span>] )</span><br><span class="line">        graph[item[<span class="number">1</span>]].push( item[<span class="number">0</span>] )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入度为 1 的节点</span></span><br><span class="line">    <span class="keyword">let</span> oneArr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: n &#125;, ()=&gt;(<span class="literal">false</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( n &gt; <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="comment">// 取出入度为 1 的节点</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">in</span> graph )&#123;</span><br><span class="line">            <span class="keyword">if</span>( graph[item].length === <span class="number">1</span> )&#123;</span><br><span class="line">                oneArr[item] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历入度为 1 的节点</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> i <span class="keyword">in</span> graph )&#123;</span><br><span class="line">            <span class="keyword">if</span>( oneArr[i] &amp;&amp; graph[i].length )&#123;</span><br><span class="line">                <span class="comment">// 互相删除节点</span></span><br><span class="line">                <span class="keyword">let</span> otherPoint = graph[i].pop()</span><br><span class="line">                graph[otherPoint] = graph[otherPoint].filter( <span class="function"><span class="params">aa</span> =&gt;</span> aa != i )</span><br><span class="line">                n --</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出结果</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i <span class="keyword">in</span> oneArr )&#123;</span><br><span class="line">     <span class="keyword">if</span>( !oneArr[i] ) res.push(i)    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;310&quot;&gt;
&lt;li&gt;最小高度树&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="图" scheme="http://blog.curtaintan.club/tags/%E5%9B%BE/"/>
    
      <category term="邻接表" scheme="http://blog.curtaintan.club/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-前缀树(字典树)</title>
    <link href="http://blog.curtaintan.club/2020/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91(%E5%AD%97%E5%85%B8%E6%A0%91)/"/>
    <id>http://blog.curtaintan.club/2020/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91(%E5%AD%97%E5%85%B8%E6%A0%91)/</id>
    <published>2020-10-09T07:28:02.000Z</published>
    <updated>2020-10-16T07:34:04.455Z</updated>
    
    <content type="html"><![CDATA[<p><fancybox><img src="https://img-blog.csdn.net/2018061522564299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></fancybox></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前缀树是N叉树的一种特殊形式。前缀树的每一个节点通常表示一个字符或者字符串。每一个节点拥有多个不同的子节点。值得注意的是，根节点表示空字符串。</p><p>前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是前缀树名称的由来。</p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><p>根据标题图可知，可以将前缀树分为两个对象，节点对象和前缀树对象，他们的功能各不相同</p><p>节点对象 <code>TrieNode</code>：</p><ol><li><code>val</code>: string 用来存储当前节点的值</li><li><code>children</code>: object 用来存储子节点</li><li><code>isWord</code>: boolean 用来表示是一个单词</li><li><code>add(val: string)</code>: TrieNode 插入节点，并返回插入的节点</li></ol><p>前缀树对象 <code>Trie</code>：</p><ol><li><code>root</code>: TrieNode 存储节点</li><li><code>insert(word: string)</code>: void 向树中插入词语</li><li><code>search(word: string)</code>: boolean 查找是否有该词语</li><li><code>startsWith(prefix: string)</code>: boolean 前缀词语</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">var</span> TrieNode = <span class="function"><span class="keyword">function</span> (<span class="params"> val = <span class="string">""</span> </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 一个节点只保存一个值</span></span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="comment">// 用来存储子节点</span></span><br><span class="line">    <span class="keyword">this</span>.children = &#123;&#125;</span><br><span class="line">    <span class="comment">// 标记单词结束</span></span><br><span class="line">    <span class="keyword">this</span>.isWord = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向当前节点添加子节点</span></span><br><span class="line">TrieNode.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"> val </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> child = <span class="keyword">new</span> TrieNode( val )</span><br><span class="line">    <span class="keyword">this</span>.children[val] = child</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.children[val]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode(<span class="string">""</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts a word into the trie. </span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; word</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> words = word.split(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> words )&#123;</span><br><span class="line">        <span class="keyword">if</span>( current.children[ item ] )&#123;</span><br><span class="line">            current = current.children[item]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.add( item )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current.isWord = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns if the word is in the trie. </span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; word</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> words = word.split(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> words )&#123;</span><br><span class="line">        <span class="keyword">if</span>( current.children[item] )&#123;</span><br><span class="line">            current = current.children[item]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.isWord</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns if there is any word in the trie that starts with the given prefix. </span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; prefix</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> prefixs = prefix.split(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> prefixs )&#123;</span><br><span class="line">        <span class="keyword">if</span>( current.children[item] )&#123;</span><br><span class="line">            current = current.children[item]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><p><a href="https://blog.csdn.net/yuzhiqiang666/article/details/80711441?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">数据结构与算法（十一）Trie字典树</a></p><p><a href="https://juejin.im/post/6844903799732060167#heading-34" target="_blank" rel="noopener">数据结构的故事之二叉树, 前缀树, N叉树</a></p><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">leetcode-208. 实现 Trie (前缀树)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;fancybox&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018061522564299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;&gt;&lt;/fancybox&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://blog.curtaintan.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="树" scheme="http://blog.curtaintan.club/tags/%E6%A0%91/"/>
    
      <category term="前缀树" scheme="http://blog.curtaintan.club/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>10.9-每日一题-找到小镇的法官</title>
    <link href="http://blog.curtaintan.club/2020/10/09/10-9-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/09/10-9-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-09T07:07:06.000Z</published>
    <updated>2020-10-09T07:26:28.089Z</updated>
    
    <content type="html"><![CDATA[<ol start="997"><li>找到小镇的法官</li></ol><a id="more"></a><h2 id="997-找到小镇的法官"><a href="#997-找到小镇的法官" class="headerlink" title="997. 找到小镇的法官"></a><a href="https://leetcode-cn.com/problems/find-the-town-judge/" target="_blank" rel="noopener">997. 找到小镇的法官</a></h2><p>在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。</p><p>如果小镇的法官真的存在，那么：</p><p>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足属性 1 和属性 2 。<br>给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。</p><p>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。</p><p>示例 1：</p><blockquote><p>输入：N = 2, trust = [[1,2]]<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：N = 3, trust = [[1,3],[2,3]]<br>输出：3</p></blockquote><p>示例 3：</p><blockquote><p>输入：N = 3, trust = [[1,3],[2,3],[3,1]]<br>输出：-1</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可知，关系图是图，</p><p>图的表示方式有两种：</p><ol><li>邻接矩阵</li><li>邻接表</li></ol><p><strong>本题使用邻接表实现</strong></p><h2 id="使用对象代替数组实现"><a href="#使用对象代替数组实现" class="headerlink" title="使用对象代替数组实现"></a>使用对象代替数组实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; trust</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findJudge = <span class="function"><span class="keyword">function</span>(<span class="params">N, trust</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建邻接表</span></span><br><span class="line">    <span class="keyword">if</span>( trust.length === <span class="number">0</span> &amp;&amp; N === <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> trust )&#123;</span><br><span class="line">        <span class="comment">// 存为对象</span></span><br><span class="line">        <span class="keyword">if</span>( map[ item[<span class="number">0</span>] ] )&#123;</span><br><span class="line">            map[ item[<span class="number">0</span>] ].trusting.push( item[<span class="number">1</span>] )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[ item[<span class="number">0</span>] ] = &#123;</span><br><span class="line">                trusting: [ item[<span class="number">1</span>] ],</span><br><span class="line">                trusted: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将被信任的人也存为对象</span></span><br><span class="line">        <span class="keyword">if</span>( map[item[<span class="number">1</span>]] )&#123;</span><br><span class="line">            map[item[<span class="number">1</span>]].trusted.push( item[<span class="number">0</span>] )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[item[<span class="number">1</span>]] = &#123;</span><br><span class="line">                trusted: [ item[<span class="number">0</span>] ],</span><br><span class="line">                trusting: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> key <span class="keyword">in</span> map )&#123;</span><br><span class="line">        <span class="comment">// 信任的人和不信任的人</span></span><br><span class="line">        <span class="keyword">if</span>( map[key].trusting.length === <span class="number">0</span> &amp;&amp; map[key].trusted.length === N - <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用数组实现"><a href="#使用数组实现" class="headerlink" title="使用数组实现"></a>使用数组实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; trust</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findJudge = <span class="function"><span class="keyword">function</span>(<span class="params">N, trust</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建邻接表</span></span><br><span class="line">    <span class="keyword">let</span> graph = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: N + <span class="number">1</span>&#125;, () =&gt; (&#123; <span class="attr">trusted</span>:[], <span class="attr">trusting</span>: []&#125;))</span><br><span class="line">    <span class="keyword">if</span>( trust.length === <span class="number">0</span> &amp;&amp; N === <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> trust )&#123;</span><br><span class="line">        graph[item[<span class="number">0</span>]].trusting.push( item[<span class="number">1</span>] )</span><br><span class="line">        graph[item[<span class="number">1</span>]].trusted.push( item[<span class="number">0</span>] )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N + <span class="number">1</span>; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( graph[i].trusting.length === <span class="number">0</span> &amp;&amp; graph[i].trusted.length === N - <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;997&quot;&gt;
&lt;li&gt;找到小镇的法官&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="图" scheme="http://blog.curtaintan.club/tags/%E5%9B%BE/"/>
    
      <category term="邻接表" scheme="http://blog.curtaintan.club/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>10.8-每日一题--反转字符串</title>
    <link href="http://blog.curtaintan.club/2020/10/08/10-8-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/08/10-8-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-08T01:30:07.000Z</published>
    <updated>2020-10-08T12:35:09.056Z</updated>
    
    <content type="html"><![CDATA[<ol start="344"><li>反转字符串</li></ol><a id="more"></a><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><blockquote><p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p></blockquote><p>解题思路：</p><p>使用双指针，左右下标元素互相替换</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;character[]&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>( ; left &lt; right; left ++, right -- )&#123;</span><br><span class="line">        [ s[left], s[ right ] ] = [ s[right], s[left] ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;344&quot;&gt;
&lt;li&gt;反转字符串&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="数组" scheme="http://blog.curtaintan.club/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://blog.curtaintan.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>10.7-每日一题--75. 颜色分类</title>
    <link href="http://blog.curtaintan.club/2020/10/07/10-7-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/07/10-7-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-07T02:51:35.000Z</published>
    <updated>2020-10-07T03:14:25.613Z</updated>
    
    <content type="html"><![CDATA[<ol start="75"><li>颜色分类</li></ol><a id="more"></a><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://leetcode-cn.com/problems/sort-colors/" alt="75. 颜色分类"></h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><blockquote><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p></blockquote><p>进阶：</p><p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h2 id="解法一：冒泡排序"><a href="#解法一：冒泡排序" class="headerlink" title="解法一：冒泡排序"></a>解法一：冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt; nums[j] )&#123;</span><br><span class="line">                [ nums[i], nums[j] ] = [ nums[j], nums[i] ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：单指针"><a href="#解法二：单指针" class="headerlink" title="解法二：单指针"></a>解法二：单指针</h2><p>解题思路：使用单指针，依次排 <code>0</code> 和 <code>1</code>，需要进行 <code>n-1</code> 次循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums[i] === <span class="number">0</span> )&#123;</span><br><span class="line">            [ nums[i], nums[index] ] = [ nums[index], nums[i] ]</span><br><span class="line">            index ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = index; i &lt; nums.length; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums[i] === <span class="number">1</span> )&#123;</span><br><span class="line">            [ nums[i], nums[index] ] = [ nums[index], nums[i] ]</span><br><span class="line">            index ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>解题思路：</p><ol><li>使用一个指针记录 <code>0</code> 的下标</li><li>使用一个指针记录 <code>2</code> 的下标</li><li>向中间逼近，中间的元素就是 <code>1</code></li></ol><p>该方法比较适合只有三个元素排序的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> eIndex = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>( i &lt;= eIndex )&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums[i] === <span class="number">0</span> )&#123;</span><br><span class="line">            [ nums[i], nums[sIndex] ] = [ nums[sIndex], nums[i] ]</span><br><span class="line">            sIndex ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( nums[i] === <span class="number">2</span> )&#123;</span><br><span class="line">            [ nums[i], nums[eIndex] ] = [ nums[eIndex], nums[i] ]</span><br><span class="line">            eIndex --</span><br><span class="line">            <span class="comment">// 位置回退，因为不知道交换后的元素的值，故需要重新判断一次</span></span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;75&quot;&gt;
&lt;li&gt;颜色分类&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="数组" scheme="http://blog.curtaintan.club/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="http://blog.curtaintan.club/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>10.5-每日一题--四数之和</title>
    <link href="http://blog.curtaintan.club/2020/10/05/10-5-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/05/10-5-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-05T01:48:17.000Z</published>
    <updated>2020-10-05T02:04:32.414Z</updated>
    
    <content type="html"><![CDATA[<ol start="18"><li>四数之和</li></ol><a id="more"></a><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：</p><blockquote><p>[<br> [-1,  0, 0, 1],<br> [-2, -1, 1, 2],<br> [-2,  0, 0, 2]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>对数组进行排序</li><li>将取得的值以 <strong>数组字符串</strong> 的形式存入数组</li><li>使用 <code>Set</code> 去重</li><li>使用 <code>JSON.parse()</code> 将元素恢复为数组对象</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">if</span>( len &lt; <span class="number">4</span> ) <span class="keyword">return</span> res</span><br><span class="line">    nums = nums.sort( <span class="function">(<span class="params"> a, b </span>) =&gt;</span> a - b )</span><br><span class="line">    <span class="comment">// 获取合适的值</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j ++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">let</span> x = j + <span class="number">1</span>; x &lt; len - <span class="number">1</span>; x ++ )&#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">let</span> y = x + <span class="number">1</span>; y &lt; len; y ++ )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( nums[i] + nums[j] + nums[x] + nums[y] === target )&#123;</span><br><span class="line">                        <span class="comment">// 将值以字符串的形式存入数组</span></span><br><span class="line">                        res.push( <span class="string">`[<span class="subst">$&#123;nums[i]&#125;</span>,<span class="subst">$&#123;nums[j]&#125;</span>,<span class="subst">$&#123;nums[x]&#125;</span>,<span class="subst">$&#123;nums[y]&#125;</span>]`</span> )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    res = [ ...new <span class="built_in">Set</span>(res) ]</span><br><span class="line">    <span class="comment">// 恢复元素为数组</span></span><br><span class="line">    res = res.map( <span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">JSON</span>.parse( item ) )</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用 <code>JSON.stringify()</code> 函数处理对象时，属性为 <code>undefined</code> 和 <code>function</code> 会被忽略，所以在使用 <code>JSON.stringify()</code> 时需要先查看对象是否适合使用</p><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"tan"</span>,</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    book: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">"chinese"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">"math"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"my name is "</span>, <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( obj )</span><br><span class="line"><span class="comment">// "&#123;"name":"tan","book":[&#123;"name":"chinese"&#125;,&#123;"name":"math"&#125;]&#125;"</span></span><br></pre></td></tr></table></figure><p>可知，值为 <code>undefined</code> 和 <code>function</code> 的属性已经被忽略了</p>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;18&quot;&gt;
&lt;li&gt;四数之和&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>javascript之位操作</title>
    <link href="http://blog.curtaintan.club/2020/10/04/javascript%E4%B9%8B%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.curtaintan.club/2020/10/04/javascript%E4%B9%8B%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2020-10-04T14:30:02.000Z</published>
    <updated>2020-10-07T06:57:04.713Z</updated>
    
    <content type="html"><![CDATA[<p>位运算平时用得比较少，但是在进行数字操作的时候，还是有必要了解的</p><a id="more"></a><h3 id="数的二进制表示"><a href="#数的二进制表示" class="headerlink" title="数的二进制表示"></a>数的二进制表示</h3><p>接下来要介绍的操作符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。既然知道了这些，就只需要考虑32位整数即可。</p><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><p>有符号整数使用32位的前31位表示整数值。第32位表示数值的符号，如0表示正，1表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即31位中的每一位都代表2的幂。第一位（称为第0位）表示2^0，第二位表示2^1，依此类推。如果一个位是空的，则以0填充，相当于忽略不计。比如，数值18的二进制格式为00000000000000000000000000010010，或更精简的10010。后者是用到的5个有效位，决定了实际的值。</p><h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><p>负值以一种称为二补数的二进制编码存储。一个数值的二补数通过如下3个步骤计算得到：<br>(1) 确定绝对值的二进制表示（如，对于-18，先确定18的二进制表示）；<br>(2) 找到数值的一补数，换句话说，就是每个0都变成1，每个1都变成0；<br>(3) 给结果加1。<br>基于上述步骤确定-18的二进制表示，首先从18的二进制表示开始：</p><blockquote><p>0000 0000 0000 0000 0000 0000 0001 0010</p></blockquote><p>然后，计算一补数，即反转每一位的二进制值：</p><blockquote><p>1111 1111 1111 1111 1111 1111 1110 1101</p></blockquote><p>最后，给一补数加1：</p><blockquote><p>1111 1111 1111 1111 1111 1111 1110 1101<br>+1</p></blockquote><hr><blockquote><p>1111 1111 1111 1111 1111 1111 1110 1110</p></blockquote><p>那么，-18的二进制表示就是11111111111111111111111111101110。要注意的是，在处理有符号整数时，我们无法访问第31位。ECMAScript会帮我们记录这些信息。在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：</p><blockquote><p>let num = -18;<br>console.log(num.toString(2)); // “-10010”</p></blockquote><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>位操作有 7 种操作：</p><ol><li>按位非( ~ )</li><li>按位与( &amp; )</li><li>按位或( | )</li><li>按位异或( ^ )</li><li>左移( &lt;&lt; )</li><li>有符号位右移( &gt;&gt; )</li><li>无符号位右移( &gt;&gt;&gt; )</li></ol><h3 id="1-按位非"><a href="#1-按位非" class="headerlink" title="1.按位非( ~ )"></a>1.按位非( ~ )</h3><blockquote><p>按位非~会将数值的32位二进制的每一位取反(0变为1，1变为0)。按位非的操作符的本质取操作数的负值，然后减一</p></blockquote><p>真值表</p><table><thead><tr><th>a</th><th>~a</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~10</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ~ 取反</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上面的公式反推</span></span><br><span class="line"><span class="comment">// 先 - 1</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span></span><br><span class="line"><span class="comment">// 再取反   得到 -11   8+2+1=11</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure><h3 id="2-按位与-amp"><a href="#2-按位与-amp" class="headerlink" title="2.按位与( &amp; )"></a>2.按位与( &amp; )</h3><blockquote><p>按位与&amp;, 本质上将两个操作数的32位二进制数的每一位对齐。</p></blockquote><p>真值表：</p><table><thead><tr><th>a</th><th>b</th><th>a&amp;b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10&amp;8  -&gt; 8</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>    <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>    <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h3 id="3-按位或"><a href="#3-按位或" class="headerlink" title="3.按位或( | )"></a>3.按位或( | )</h3><p>真值表：</p><p>|a|b|a | b|<br>|–|–|–|<br>|0|0|0<br>|0|1|1<br>|1|0|1<br>|1|1|1</p><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10 | 8  -&gt; 10</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>    <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="4-按位异或"><a href="#4-按位异或" class="headerlink" title="4.按位异或( ^ )"></a>4.按位异或( ^ )</h3><p>真值表：</p><table><thead><tr><th>a</th><th>b</th><th>a ^ b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10 ^ 8  -&gt; 2</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span>    <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span>    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="5-左移-lt-lt"><a href="#5-左移-lt-lt" class="headerlink" title="5.左移( &lt;&lt; )"></a>5.左移( &lt;&lt; )</h3><blockquote><p>左移(&lt;&lt;)将32位二进制向左移动指定的位数，空缺的位将会使用0填充。左移不会影响符号位</p></blockquote><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>&lt;&lt;<span class="number">2</span>   -&gt; <span class="number">40</span></span><br><span class="line"><span class="number">0</span>|<span class="number">000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 符号位不会被挤掉</span></span><br><span class="line"><span class="number">0</span>|<span class="number">000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">1000</span>    <span class="comment">// 2^5+2^3 = 32+8 = 40</span></span><br></pre></td></tr></table></figure><h3 id="5-右移-gt-gt"><a href="#5-右移-gt-gt" class="headerlink" title="5.右移( &gt;&gt; )"></a>5.右移( &gt;&gt; )</h3><blockquote><p>右移(&gt;&gt;)将32位二进制向右移动指定的位数，但是保留符号位，右移空缺的符号位使用0填充</p></blockquote><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>&gt;&gt;<span class="number">2</span>   -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">0</span>|<span class="number">000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 符号位不会被挤掉</span></span><br><span class="line"><span class="number">0</span>|<span class="number">000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span>    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="5-无符号位右移-gt-gt-gt"><a href="#5-无符号位右移-gt-gt-gt" class="headerlink" title="5.无符号位右移( &gt;&gt;&gt; )"></a>5.无符号位右移( &gt;&gt;&gt; )</h3><blockquote><p>无符号位右移，会将所有32位数都向右移动。对于正数来说右移和无符号位右移的结果是一致的。</p></blockquote><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10&gt;&gt;&gt;2   -&gt; 2</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span>    <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 符号位不会被挤掉</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span>    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -11</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0101</span></span><br><span class="line"><span class="comment">// -11&gt;&gt;&gt;29  -&gt; 7</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>    <span class="comment">// 1+2+4=7</span></span><br></pre></td></tr></table></figure><h2 id="位操作符的用法"><a href="#位操作符的用法" class="headerlink" title="位操作符的用法"></a>位操作符的用法</h2><ul><li>~~向下取整</li></ul><blockquote><p>按位非，将操作数取负值再减1，对于浮点数，位操作会舍弃小数部分，再进行取反，就能获得舍去小数部分的数了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">12.3</span></span><br><span class="line"><span class="comment">// -13</span></span><br><span class="line">~~<span class="number">12.3</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><ul><li>~判断索引是否存在</li></ul><p>由上述表达式可知，负数取反的结果是将负数变为正数再减 1，则 <code>~-1 = 0</code></p><p>在平时使用 <code>indexOf()</code> 函数时，当没有找到结果时会返回 <code>-1</code>，此时我们可以使用取反操作来做判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf( <span class="number">5</span> ) &gt; <span class="number">-1</span> )&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用取反做判断</span></span><br><span class="line"><span class="keyword">if</span>( ~[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf( <span class="number">5</span> ) )&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>&amp;</code> 判断奇偶</li></ul><p>由二进制计算方式可知（ 2^n+2^n-1+…+2^1+2^0 ），只有最后一位可以为奇数，则可以使用按位与 <code>&amp;</code> 来判断奇数偶数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奇数</span></span><br><span class="line"><span class="number">3</span>^<span class="number">1</span>    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偶数</span></span><br><span class="line"><span class="number">4</span>^<span class="number">1</span>    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位操作平时虽然用得少，但是技多不压身</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;位运算平时用得比较少，但是在进行数字操作的时候，还是有必要了解的&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://blog.curtaintan.club/categories/JavaScript/"/>
    
    
      <category term="js基础" scheme="http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"/>
    
      <category term="科普" scheme="http://blog.curtaintan.club/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>10.4-每日一题--两数相加(链表)</title>
    <link href="http://blog.curtaintan.club/2020/10/04/10-4-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/04/10-4-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-04T14:14:22.000Z</published>
    <updated>2020-10-04T14:20:36.581Z</updated>
    
    <content type="html"><![CDATA[<ol start="2"><li>两数相加</li></ol><a id="more"></a><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 记录下返回的节点</span></span><br><span class="line">    <span class="keyword">let</span> res = node</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>( l1 || l2 )&#123;</span><br><span class="line">        <span class="comment">// 当其中一个节点为 null 时取 0</span></span><br><span class="line">        <span class="keyword">let</span> now = ( l1 &amp;&amp; l1.val || <span class="number">0</span> ) + ( l2 &amp;&amp; l2.val || <span class="number">0</span> ) + flag</span><br><span class="line">        <span class="comment">// 超过十，标记进位</span></span><br><span class="line">        flag = now &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        node.next = <span class="keyword">new</span> ListNode( now % <span class="number">10</span> )</span><br><span class="line">        node = node.next</span><br><span class="line">        l1 = l1 &amp;&amp; l1.next</span><br><span class="line">        l2 = l2 &amp;&amp; l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算完后，有进位，需要加上进位</span></span><br><span class="line">    <span class="keyword">if</span>( flag )&#123;</span><br><span class="line">        node.next = <span class="keyword">new</span> ListNode( flag )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>答题要点：</p><ol><li>记录首节点</li><li>记录进位</li><li>添加进位数</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;两数相加&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="链表" scheme="http://blog.curtaintan.club/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>10.3-每日一题-缺失数字</title>
    <link href="http://blog.curtaintan.club/2020/10/03/10.3-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/03/10.3-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-03T10:22:51.000Z</published>
    <updated>2020-10-05T01:52:53.431Z</updated>
    
    <content type="html"><![CDATA[<ol start="268"><li>缺失数字</li></ol><a id="more"></a><h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p>示例 1:</p><blockquote><p>输入: [3,0,1]<br>输出: 2<br>示例 2:</p></blockquote><blockquote><p>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p></blockquote><h2 id="解法一-高斯求和公式"><a href="#解法一-高斯求和公式" class="headerlink" title="解法一   高斯求和公式"></a>解法一   高斯求和公式</h2><p>使用数学解法：</p><ol><li>利用高斯求和公式求出序列长度值总和</li><li>遍历数列，求出现有总和</li><li>相减得差</li></ol><p>可知，和为 0 到 n 的和，<br>高斯求和公式：总个数 / 2 * ( 最小的数 + 最大的数 )</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为缺失了一个数，所以长度要加一，</span></span><br><span class="line">    <span class="comment">// 最大的数就是数组的长度那个数，那个数加上 0</span></span><br><span class="line">    <span class="keyword">let</span> allcount = ( nums.length + <span class="number">1</span> ) / <span class="number">2</span> * ( nums.length + <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i ++ )&#123;</span><br><span class="line">        res += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allcount - res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-位运算"><a href="#解法二-位运算" class="headerlink" title="解法二   位运算"></a>解法二   位运算</h2><p>异或运算满足结合律，两个相同的数异或运算返回 0，不相同的数异或返回原来的数</p><p>异或运算的真值表：</p><table><thead><tr><th>a</th><th>b</th><th>a^b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>案例：</p><blockquote><p>1^1   // 0<br>1^2   // 3   10^1 -&gt; 11 -&gt; 2+1=3<br>4^5   // 1    4-&gt;100  5-&gt;101  100^101 -&gt; 001 -&gt; 1</p></blockquote><p>解释：会把数字转换为二进制，再进行异或运算</p><p>案例：</p><p>有这样的案例：</p><p>|下标|0|1|2|3|<br>|–|–|–|–|<br>|数字|0|1|3|4|</p><blockquote><p>得到公式：4^(0^0)^(1^1)^(2^3)^(3^4)<br>交换律：  = (4^4)^(0^0)^(1^1)^(3^3)^2<br>最后结果：= 0^0^0^0^2<br>         = 2</p></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.length</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i ++ )&#123;</span><br><span class="line">        n ^= nums[i] ^ i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当涉及到数字运算时，可以优先考虑数学公式和位运算</p>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;268&quot;&gt;
&lt;li&gt;缺失数字&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="位操作" scheme="http://blog.curtaintan.club/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>10.2-每日一题-宝石与石头</title>
    <link href="http://blog.curtaintan.club/2020/10/02/10-2-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/10/02/10-2-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-10-02T00:54:32.000Z</published>
    <updated>2020-10-02T01:11:42.667Z</updated>
    
    <content type="html"><![CDATA[<ol start="771"><li>宝石与石头</li></ol><a id="more"></a><h3 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头</a></h3><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:</p><blockquote><p>输入: J = “aA”, S = “aAAbbbb”<br>输出: 3<br>示例 2:</p></blockquote><blockquote><p>输入: J = “z”, S = “ZZ”<br>输出: 0</p></blockquote><p>注意:</p><ul><li>S 和 J 最多含有50个字母。</li><li>J 中的字符不重复。</li></ul><h3 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h3><p>解题原理：使用正则搭配 <code>replace()</code> 完成计数</p><ol><li>在 J 的每个元素后面加上 <code>*</code> ，表示宝石有任意个</li><li>构建正则，使用 <code>g</code> 全局模式</li><li>使用 <code>replace</code> 函数计数并替换元素</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J, S</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建正则</span></span><br><span class="line">    <span class="keyword">let</span> Jstr = J.split(<span class="string">""</span>).join(<span class="string">"*"</span>) + <span class="string">"*"</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>( Jstr, <span class="string">"g"</span> )</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 替换元素并技术</span></span><br><span class="line">    S = S.replace( reg, (all) =&gt; &#123;</span><br><span class="line">        res += all.length</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><p>使用两次遍历</p><ol><li>遍历 J 将每一个元素存在对象内</li><li>遍历 S 判定元素是否存在对象上</li><li>计数返回结果</li></ol><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J, S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 存入 map</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> J )&#123;</span><br><span class="line">        map[item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> S )&#123;</span><br><span class="line">        map[item] &amp;&amp; res ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>适当的使用 map 来存储值，可以减小时间复杂度</p>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;771&quot;&gt;
&lt;li&gt;宝石与石头&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="字符串" scheme="http://blog.curtaintan.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>红宝书第三章-语言基础</title>
    <link href="http://blog.curtaintan.club/2020/09/30/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.curtaintan.club/2020/09/30/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-30T02:17:45.000Z</published>
    <updated>2020-10-02T09:44:48.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h2><h3 id="1-1-变量命名规则"><a href="#1-1-变量命名规则" class="headerlink" title="1.1 变量命名规则"></a>1.1 变量命名规则</h3><ol><li>第一个字符必须是一个字符、下划线（_）或美元符号（$）</li><li>剩下的字符可以是字母、下划线、美元符号和数字，也可以是 Unicode 的字母字符</li></ol><h3 id="1-2-严格模式"><a href="#1-2-严格模式" class="headerlink" title="1.2 严格模式"></a>1.2 严格模式</h3><p>概念：ES5 添加了严格模式，严格模式是一个预处理指令，严格模式的目的是处理一些不规范写法，对于不安全的活动抛错误</p><p>如何添加严格模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在脚本开头添加一行</span></span><br><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或在函数体内第一行添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>严格模式的影响：</strong></p><h4 id="1-2-1-针对变量："><a href="#1-2-1-针对变量：" class="headerlink" title="1.2.1 针对变量："></a>1.2.1 针对变量：</h4><ol><li>不允许以外创建全局变量，给一个没有声明的变量赋值，抛错 ReferenceError 引用错误</li><li>不能对变量使用 delete 操作符</li><li>不能使用保留字作为变量名</li></ol><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式:创建全局变量 </span></span><br><span class="line"><span class="comment">// 严格模式:抛出 ReferenceError</span></span><br><span class="line">name = <span class="string">"tan"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非严格模式:静默失败 </span></span><br><span class="line"><span class="comment">//严格模式:抛出 ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">delete</span> color;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-针对对象："><a href="#1-2-2-针对对象：" class="headerlink" title="1.2.2 针对对象："></a>1.2.2 针对对象：</h4><ol><li>为只读属性赋值会抛出 <code>TypeError</code></li><li>对不可配置的属性（noConfigurable）使用 delete 操作会抛出 TypeError</li><li>对不可扩展的对象添加属性会抛出 <code>TypeError</code></li><li>使用对象字面量时，属性名必须唯一</li></ol><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// read-only </span></span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">value: <span class="string">"tan"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非严格模式: 默认修改失败</span></span><br><span class="line"><span class="comment">// 严格模式: 抛出错误 Cannot assign to read only property "name"</span></span><br><span class="line">obj.name = <span class="string">"yu"</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-针对函数："><a href="#1-2-3-针对函数：" class="headerlink" title="1.2.3 针对函数："></a>1.2.3 针对函数：</h4><ol><li>要求命名函数的参数必须唯一</li><li>在非严格模式下，修改命名参数的值会反映到 arguments 对象中，而在严格模式下，值是独立的</li><li>arguments.callee 和 arguments.caller，在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError</li><li>只能在脚本的顶级和函数内部生命函数</li></ol><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非严格模式: 没有错误，后面的参数覆盖前面的值</span></span><br><span class="line"><span class="comment">//严格模式: 抛出语法错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"> num, str, num </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 非严格模式：undefined 12</span></span><br><span class="line">    <span class="comment">// 严格模式: 抛出语法错误</span></span><br><span class="line">    <span class="built_in">console</span>.log( num, str )</span><br><span class="line">&#125;</span><br><span class="line">fn( <span class="number">12</span>, <span class="string">"tan"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//非严格模式: 修改会反映到 arguments 中 </span></span><br><span class="line"><span class="comment">//严格模式: 修改不会反映到 arguments 中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value = <span class="string">"yu"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// "yu" </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 非严格模式:"yu"，严格模式:"tan"</span></span><br><span class="line">&#125;</span><br><span class="line">showValue(<span class="string">"tan"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问 arguments.callee </span></span><br><span class="line"><span class="comment">//非严格模式:没有问题 </span></span><br><span class="line"><span class="comment">//严格模式:抛出 TypeError</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=factorial(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 if 语句中声明函数 </span></span><br><span class="line"><span class="comment">//非严格模式:将函数提升到 if 语句外部 </span></span><br><span class="line"><span class="comment">//严格模式:抛出语法错误</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// todo </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-针对-eval-函数中的变量"><a href="#1-2-4-针对-eval-函数中的变量" class="headerlink" title="1.2.4 针对 eval() 函数中的变量"></a>1.2.4 针对 eval() 函数中的变量</h4><ol><li>在严格模式中，它在包含上下文中不再创建变量或函数</li><li>在 eval() 函数中声明的变量和函数，只在特殊的终于用中有效，随后将被销毁</li></ol><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 eval()创建变量</span></span><br><span class="line"><span class="comment">//非严格模式:弹出对话框显示 10</span></span><br><span class="line"><span class="comment">//严格模式:调用 alert(x)时会抛出 ReferenceError</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var x=10"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"var x=10, y=11; x+y"</span>);</span><br><span class="line">alert(result);  <span class="comment">// 21   执行结果存在变量内</span></span><br></pre></td></tr></table></figure><h4 id="1-2-5-抑制-this-指向"><a href="#1-2-5-抑制-this-指向" class="headerlink" title="1.2.5 抑制 this 指向"></a>1.2.5 抑制 this 指向</h4><p>在非严格模式下使用函数的 apply()或 call()方法时，null 或 undefined 值会被转换为全局 对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值</p><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问属性</span></span><br><span class="line"><span class="comment">// 非严格模式: 传入null, 函数的this值是全局对象</span></span><br><span class="line"><span class="comment">// 严格模式: 抛出错误，因为this的值为 null</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">displayColor.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="1-2-6-其他影响"><a href="#1-2-6-其他影响" class="headerlink" title="1.2.6 其他影响"></a>1.2.6 其他影响</h4><ol><li>严格模式去掉了 JavaScript 中的八进制字面量</li><li>严格模式下 parseInt()的行为，八进制字面量在严格模式下会被当作以 0 开头的十进制字面量</li></ol><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用八进制字面量 </span></span><br><span class="line"><span class="comment">//非严格模式:值为 8 </span></span><br><span class="line"><span class="comment">//严格模式:抛出语法错误</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 parseInt()解析八进制字面量 </span></span><br><span class="line"><span class="comment">//非严格模式:值为 8 </span></span><br><span class="line"><span class="comment">//严格模式:值为 10</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="built_in">parseInt</span>(<span class="string">"010"</span>);</span><br></pre></td></tr></table></figure><h4 id="1-2-7-总结"><a href="#1-2-7-总结" class="headerlink" title="1.2.7 总结"></a>1.2.7 总结</h4><p>简单的概括一下，严格模式会造成以下影响：</p><ol><li>变量必须定义后才能赋值，且不能随意删除</li><li>修改对象中只读属性和不可配置的属性时，会报错</li><li>函数中，arguments 与参数独立，操作互不影响</li><li>显式绑定 this 时，不能将函数绑定到 null 上</li><li>其他影响，eval 函数执行中的变量定义和定义数字时的进制问题</li></ol><p>严格模式的目的：</p><ol><li>消除 js 语法不严谨的地方，减少奇怪行为（不定义变量，直接赋值，八进制数字）</li><li>消除代码运行不安全的地方（修改只读属性）</li><li>提高编译效率和运行速度</li><li>为未来做铺垫</li></ol><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><p>有三个关键字可以声明变量：<code>var</code>、<code>let</code>、<code>const</code></p><h3 id="2-1-var、let、const-的区别"><a href="#2-1-var、let、const-的区别" class="headerlink" title="2.1 var、let、const 的区别"></a>2.1 var、let、const 的区别</h3><table><thead><tr><th>关键字</th><th>变量提升</th><th>块级作用域</th><th>重新赋值</th><th>重复声明</th></tr></thead><tbody><tr><td>var</td><td>存在</td><td>不存在</td><td>可以</td><td>可以</td></tr><tr><td>let</td><td>不存在</td><td>存在</td><td>可以</td><td>不可以</td></tr><tr><td>const</td><td>不存在</td><td>存在</td><td>不可以</td><td>不可以</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>const 必须初始化一个值</li><li>var 声明的变量在浏览器环境会挂载到 window 上，而 let 和 const 不会</li></ol><h3 id="2-2-var、let、const-的使用"><a href="#2-2-var、let、const-的使用" class="headerlink" title="2.2 var、let、const 的使用"></a>2.2 var、let、const 的使用</h3><ol><li>不使用 var 定义变量</li><li>使用 let 定义需要改变的基础变量</li><li>使用 const 定义常量或不会直接更改引用的对象</li></ol><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p>ECMAScript 有其中简单数据类型（原始类型）：</p><ol><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol</li><li>bigInt</li></ol><p>复杂数据类型：object（包含对象、function）</p><h3 id="3-1-typeof-操作符"><a href="#3-1-typeof-操作符" class="headerlink" title="3.1 typeof 操作符"></a>3.1 typeof 操作符</h3><p>对一个值使用 <code>typeof</code> 会返回以下字符串之一：</p><ol><li><code>undefined</code> 表示值未定义</li><li><code>boolean</code> 表示值为布尔值</li><li><code>string</code> 表示值为字符串</li><li><code>number</code> 表示值为数字</li><li><code>object</code> 表示值为对象（不是函数）或 null</li><li><code>function</code> 表示值为函数</li><li><code>symbol</code> 表示值为符号</li><li><code>bigint</code> 表示值为bigint</li></ol><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>  <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>  <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"tan"</span>  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">12</span>  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">12n</span>  <span class="comment">// bigint</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">"yuuu"</span> &#125;  <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> fn  <span class="comment">// function</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、语法&quot;&gt;&lt;a href=&quot;#一、语法&quot; class=&quot;headerlink&quot; title=&quot;一、语法&quot;&gt;&lt;/a&gt;一、语法&lt;/h2&gt;&lt;h3 id=&quot;1-1-变量命名规则&quot;&gt;&lt;a href=&quot;#1-1-变量命名规则&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="红宝书" scheme="http://blog.curtaintan.club/categories/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
      <category term="js基础" scheme="http://blog.curtaintan.club/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>9.30-每日一题</title>
    <link href="http://blog.curtaintan.club/2020/09/30/9-30-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/09/30/9-30-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-09-30T00:30:49.000Z</published>
    <updated>2020-09-30T02:16:18.856Z</updated>
    
    <content type="html"><![CDATA[<ol start="701"><li>二叉搜索树中的插入操作</li></ol><a id="more"></a><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如：</p><style>.bg-pre {    padding: 10px;    background: rgba(33,150,243,.2);    border-radius: 4px;}</style><pre class="bg-pre" >给定二叉搜索树:        4       / \      2   7     / \    1   3和 插入的值: 5</pre><p>你可以返回这个二叉搜索树:</p><pre class="bg-pre" >         4       /   \      2     7     / \   /    1   3 5</pre><p>或者这个树也是有效的:</p><pre class="bg-pre" >         5       /   \      2     7     / \       1   3         \          4</pre><p><strong>提示：</strong></p><p>新值和原始二叉搜索树中的任意节点值都不同</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由题可知，题目是搜索二叉树，搜索二叉树的特点是，左子节点的值小于当前节点的值，右子节点的值大于当前节点的值</p><p>迭代进行比较，一直比较到下一个位置为 null 时停止，并创建一个节点放在最后就完成了插入</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !root ) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">let</span> node = root</span><br><span class="line">    <span class="comment">// 依次迭代</span></span><br><span class="line">    <span class="keyword">while</span>( node )&#123;</span><br><span class="line">        <span class="keyword">if</span>( val &lt; node.val )&#123;</span><br><span class="line">            <span class="comment">// 迭代到最后，插入节点</span></span><br><span class="line">            <span class="keyword">if</span>( !node.left )&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( !node.right )&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回首节点</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归实现：</p><blockquote><p>递归结束条件：当前节点为 null，返回以 val 新建的节点<br>将节点的左右节点进行赋值，赋值为当前函数的调用<br>最后返回当前节点</p></blockquote><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !root ) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">if</span>( val &lt; root.val )&#123;</span><br><span class="line">        root.left = insertIntoBST( root.left, val )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = insertIntoBST( root.right, val )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;701&quot;&gt;
&lt;li&gt;二叉搜索树中的插入操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="二叉树" scheme="http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>9.29-每日一题--二叉树后序遍历</title>
    <link href="http://blog.curtaintan.club/2020/09/29/9-29-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.curtaintan.club/2020/09/29/9-29-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2020-09-29T00:47:28.000Z</published>
    <updated>2020-09-29T01:36:51.539Z</updated>
    
    <content type="html"><![CDATA[<ol start="145"><li>二叉树的后序遍历</li></ol><a id="more"></a><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><p>给定一个二叉树，返回它的 后序 遍历。</p><style>.bg-pre {    padding: 10px;    background: rgba(33,150,243,.2);    border-radius: 4px;}</style><p>示例:</p><pre class="bg-pre" > 输入: [1,null,2,3]     1    \     2    /   3 </pre><p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol><li>当前节点存在左节点，递归左节点</li><li>当前节点存在右节点，递归右节点</li><li>将当前节点的值存到结果中</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存最后结果</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params"> node </span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( !node ) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 左右子树递归</span></span><br><span class="line">        node.left &amp;&amp; dfs( node.left )</span><br><span class="line">        node.right &amp;&amp; dfs( node.right )</span><br><span class="line">        res.push( node.val )</span><br><span class="line">    &#125;</span><br><span class="line">    dfs( root )</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;145&quot;&gt;
&lt;li&gt;二叉树的后序遍历&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.curtaintan.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://blog.curtaintan.club/tags/leetcode/"/>
    
      <category term="二叉树" scheme="http://blog.curtaintan.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
