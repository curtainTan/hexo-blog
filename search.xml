<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则小记之匹配规则]]></title>
    <url>%2Fhexo-blog%2F2019%2F08%2F15%2F%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%E4%B9%8B%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[前言前面看了正则的相关方法，现在看下如何书写正则语句吧。 创建一个正则表达式 字面量方法const reg =/\bis\b/g 构造函数方法const reg = new RegExp(‘\bis\b’, ‘g’) 注意：第一个参数为正则表达式字符串（注意转译），第二个参数为修饰符。 模式标识符 常用的模式标识符有三个： g: global，执行一个全局匹配 i: ignore case执行一个不区分大小写的匹配 m: multiple lines多行匹配 这里解释下m 当字符串存在\n换行的情况下使用，可以连续匹配。 案例：123var str = "abcggab\nabcoab";var preg1 = /^abc/gm; str.match(preg1) // 结果为：["abc", "abc"]var preg2 = /ab$/gm; str.match(preg2) // 结果为：["ab", "ab"] 位置边界 单词边界\b boundary 可匹配的位置：行首，行位，单词边界（空格） 案例： 12345var str = "The cat scattered his food"var yu = str.replace( /cat/g, "dog" )console.log( yu ) // The dog sdogtered his foodyu = str.replace( /\bcat\b/g, "dog" )console.log( yu ) // The dog scattered his food 我只想换cat这个单词，不想换scattered中的cat，就要用到\b划分单词边界， 当然你也可以用\s，\s匹配的位置必须由空格，不能匹配行首和行尾，除非行首和行尾有空格。 案例：123var str = "cat scattered his food"console.log( /\scat/.test( str ) ) // falseconsole.log( /\bcat/.test( str ) ) // true 字符串边界元字符^用来匹配字符串的开头 元字符$用来匹配字符串的末尾 其他边界 (?=p)和(?!p)(?=p)，其中p是一个子模式，即p前面的位置。 比如(?=l)，表示’l’字符前面的位置，例如：123var result = "hello".replace(/(?=l)/g, '#');console.log(result); // =&gt; "he#l#lo" 而(?!p)就是(?=p)的反面意思，就是匹配到的字符串后面一个位置。比如： 1234var result = "hello".replace(/(?!l)/g, '#');console.log(result); // =&gt; "#h#ell#o#" 单个符号字符 特殊字符 正则表达式 记忆方式 换行符 \n new line 换页符 \f form feed 回车符 \r return 空白符 \s space 制表符 \t tab 垂直制表符 \v vertical tab 回退符 [\b] backspace,之所以使用[]符号是避免和\b重复 字符组 说明：需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一。如果想要表示一类的字符怎么办呢？？这里就出现了字符组。 简写形式： \d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。 \D就是[^0-9]。表示除数字外的任意字符。 \w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。\W是[^0-9a-zA-Z_]。非单词字符。 \s是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。 \S是[^ \t\v\n\r\f]。 非空白符。.就是[^\n\r\u2028\u2029]。 通配符. 表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。 如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个。 量词 说明：量词也称重复。掌握{m,n}的准确含义后，只需要记住一些简写形式。 { m, } 表示至少初选m次，注意后面的逗号哦。 { m } 表示出现m次们不能多，也不能少。 ? 等价于{ 0， 1 }, 表示出现或者不出现， 记忆方式：问号的意思表示，有吗？ + 等价于{ 1, },表示至少出现一次，记忆方式，表示追加，得先有一个。 * 等价于{ 0, }，表示出现任意次，可以出现也可以不出现。 使用量词需知道贪婪匹配和惰性匹配： 贪婪模式 1234var regex = /\d&#123;2,5&#125;/g;var string = "123 1234 12345 123456";console.log( string.match(regex) ); // =&gt; ["123", "1234", "12345", "12345"] 惰性模式 1234var regex = /\d&#123;2,5&#125;?/g;var string = "123 1234 12345 123456";console.log( string.match(regex) ); // =&gt; ["12", "12", "34", "12", "34", "12", "34", "56"] 案例： 要求从 &lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt; 提取出id=”container”。 可能最开始想到的正则是：1234var regex = /id=".*"/var string = '&lt;div id="container" class="main"&gt;&lt;/div&gt;';console.log(string.match(regex)[0]); // =&gt; id="container" class="main" 因为.是通配符，本身就匹配双引号的，而量词*又是贪婪的，当遇到container后面双引号时，不会停下来，会继续匹配，直到遇到最后一个双引号为止。 1234var regex = /id=".*?"/var string = '&lt;div id="container" class="main"&gt;&lt;/div&gt;';console.log(string.match(regex)[0]); // =&gt; id="container" 当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：1234var regex = /id="[^"]*"/var string = '&lt;div id="container" class="main"&gt;&lt;/div&gt;';console.log(string.match(regex)[0]); // =&gt; id="container" 因为[^”]匹配的是非”符号，所以匹配到后面的第一个引号的时候就停止了。 多选分支 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 例如要匹配”good”和”nice”可以使用/good|nice/。测试如下： 1234var regex = /good|nice/g;var string = "good idea, nice try.";console.log( string.match(regex) ); // =&gt; ["good", "nice"] 括号（分组） 其中分组体现在：所有以(和)元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之replace]]></title>
    <url>%2Fhexo-blog%2F2019%2F08%2F15%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8Breplace%2F</url>
    <content type="text"><![CDATA[语法：str.replace( regexp | substr, newSubStr | function ) 参数 regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描述请参考 指定一个函数作为参数 小节. 说明该方法并不改变调用它的字符串本身，而只是返回替换后的字符串. 搭配与demo可见，replace有两个参数，4种搭配。 1. replace( substr, newSubStr )123var a = "what is this? before";var b = a.replace("before","after");console.log(b); // "what is this? after" 说明，此方法可以链式调用，但是一次执行只替换第一次匹配的值。 2. replace( Regexp, newSubStr )123var a = "what is this? before";var b = a.replace(/(^\w+).*?(\w+)$/,"$2 $1");//括号分割的部分依次为子串1....nconsole.log(b); // "before what" 注意： 当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号 例如，把”2,3,5”，变成”5=2+3”： 123var result = "2,3,5".replace(/(\d+),(\d+),(\d+)/, "$3=$1+$2");console.log(result);// =&gt; "5=2+3" 又例如，把”2,3,5”，变成”222,333,555”: 123var result = "2,3,5".replace(/(\d+)/g, "$&amp;$&amp;$&amp;");console.log(result);// =&gt; "222,333,555" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”: 123var result = "2+3=5".replace(/=/, "$&amp;$`$&amp;$'$&amp;");console.log(result);// =&gt; "2+3=2+3=5=5" 3. replace( Regexp, function )function(match,p1…,offset,string),可见至少包含三个形参(即arguments.length&gt;=3) 函数参数说明： match表示第一个参数(整个正则表达式)匹配的字符串 p1至pn表示第1..n个括号匹配的字符串,如果没有括号则不存在该项 offset表示匹配的起点在原字符串中的偏移 string表示原字符串 123456"1234 2345 3456".replace(/(\d)\d&#123;2&#125;(\d)/g, function(match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; ["1234", "1", "4", 0, "1234 2345 3456"]// =&gt; ["2345", "2", "5", 5, "1234 2345 3456"]// =&gt; ["3456", "3", "6", 10, "1234 2345 3456"] 4. replace( substr, function )1234567function replacer(match,offset,string)&#123; //由于字符串中不会有括号进行分组,此时没有子串 return offset+" that";//偏移为4&#125;var a = "what is this? before";var b = a.replace(" is this",replacer);console.log(b); // "what4 that? before" 结语这下可以说是真真正正的理解replace的用法了。 写下这篇文章，希望对你有帮助。 加油哦，与君共勉！！ 参考材料： String.prototype.replace高阶技能 我的文章借鉴与此片文章，对文章没补充到的进行了补充和说明。 JS正则表达式完整教程（略长） 补充的内容来自这篇文章。 MDN-replace MDN-repalce说明]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则小记]]></title>
    <url>%2Fhexo-blog%2F2019%2F08%2F14%2F%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 正则，用简短的一句话概括，正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则的方法和与正则有关的方法 共有6个，字符串实例4个，正则实例2个： String#search String#split String#match String#replace RegExp#test RegExp#exec 1.search() 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子：1234var regex = /\d/;var string = "abc123";console.log( string.search(regex) );// =&gt; 3 2.split 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 例子：1234567var regex = /\D/console.log( "2017/06/26".split(regex) )console.log( "2017.06.26".split(regex) )console.log( "2017-06-26".split(regex) )// =&gt; ["2017", "06", "26"]// =&gt; ["2017", "06", "26"]// =&gt; ["2017", "06", "26"] 3.match 定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则： 匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 案例：1234var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;var string = "2017-06-26";console.log( string.match(regex) );// =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"] 4.replace 语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. replace后面单独写一篇文章总结 案例：12345678var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;var string = "2017-06-26";var date = [];string.replace(regex, function(match, year, month, day) &#123; date.push(year, month, day);&#125;);console.log(date);// =&gt; ["2017", "06", "26"] 5.test 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例：1234var regex = /\d/;var string = "abc123";console.log( regex.test(string) );// =&gt; true 6.exec 说明：exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 这个方法很类似match方法。 案例：1234var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;var string = "2017-06-26";console.log( regex.exec(string) );// =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"] 相关API注意要点 1 search和match的参数问题我们知道字符串实例的那4个方法参数都支持正则和字符串。 但search和match，会把字符串转换为正则的。 1234567891011121314151617181920212223var string = "2017.06.27";console.log( string.search(".") );// =&gt; 0//需要修改成下列形式之一console.log( string.search("\\.") );console.log( string.search(/\./) );// =&gt; 4// =&gt; 4console.log( string.match(".") );// =&gt; ["2", index: 0, input: "2017.06.27"]//需要修改成下列形式之一console.log( string.match("\\.") );console.log( string.match(/\./) );// =&gt; [".", index: 4, input: "2017.06.27"]// =&gt; [".", index: 4, input: "2017.06.27"]console.log( string.split(".") );// =&gt; ["2017", "06", "27"]console.log( string.replace(".", "/") );// =&gt; "2017/06.27" 2 match返回结果的格式问题match返回结果的格式，与正则对象是否有修饰符g有关。 1234567var string = "2017.06.27";var regex1 = /\b(\d+)\b/;var regex2 = /\b(\d+)\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]// =&gt; ["2017", "06", "27"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有g，返回的是所有匹配的内容。 3 exec比match更强大当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。 而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配： 123456789101112131415161718var string = "2017.06.27";var regex2 = /\b(\d+)\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]// =&gt; 4// =&gt; ["06", "06", index: 5, input: "2017.06.27"]// =&gt; 7// =&gt; ["27", "27", index: 8, input: "2017.06.27"]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环：123456789var string = "2017.06.27";var regex2 = /\b(\d+)\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"] 4// =&gt; ["06", "06", index: 5, input: "2017.06.27"] 7// =&gt; ["27", "27", index: 8, input: "2017.06.27"] 10 4 修饰符g，对exex和test的影响 上面提到了正则实例的lastIndex属性，表示尝试匹配时，从字符串的lastIndex位开始去匹配。 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。 而正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。下面让我们以test为例，看看你是否会迷糊： 1234567var regex = /a/g;console.log( regex.test("a"), regex.lastIndex );console.log( regex.test("aba"), regex.lastIndex );console.log( regex.test("ababc"), regex.lastIndex );// =&gt; true 1// =&gt; true 3// =&gt; false 0 注意上面代码中的第三次调用test，因为这一次尝试匹配，开始从下标lastIndex即3位置处开始查找，自然就找不到了。 如果没有g，自然都是从字符串第0个字符处开始尝试匹配：1234567var regex = /a/;console.log( regex.test("a"), regex.lastIndex );console.log( regex.test("aba"), regex.lastIndex );console.log( regex.test("ababc"), regex.lastIndex );// =&gt; true 0// =&gt; true 0// =&gt; true 0 5 test整体匹配时需要使用^和$ 这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾：123456console.log( /123/.test("a123b") );// =&gt; trueconsole.log( /^123$/.test("a123b") );// =&gt; falseconsole.log( /^123$/.test("123") );// =&gt; true 6 split相关注意事项 split方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度：123var string = "html,css,javascript";console.log( string.split(/,/, 2) );// =&gt;["html", "css"] 7 replace是很强大的 《JavaScript权威指南》认为exec是这6个API中最强大的，而我始终认为replace才是最强大的。 因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第1~99个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&apos; 匹配到的子串的右边文本 $$ 美元符号 例如，把”2,3,5”，变成”5=2+3”：123var result = "2,3,5".replace(/(\d+),(\d+),(\d+)/, "$3=$1+$2");console.log(result);// =&gt; "5=2+3" 又例如，把”2,3,5”，变成”222,333,555”:123var result = "2,3,5".replace(/(\d+)/g, "$&amp;$&amp;$&amp;");console.log(result);// =&gt; "222,333,555" 再例如，把”2+3=5”，变成”2+3=2+3=5=5”:123var result = "2+3=5".replace(/=/, "$&amp;$`$&amp;$'$&amp;");console.log(result);// =&gt; "2+3=2+3=5=5" 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：123456"1234 2345 3456".replace(/(\d)\d&#123;2&#125;(\d)/g, function(match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; ["1234", "1", "4", 0, "1234 2345 3456"]// =&gt; ["2345", "2", "5", 5, "1234 2345 3456"]// =&gt; ["3456", "3", "6", 10, "1234 2345 3456"] 此时我们可以看到replace拿到的信息，并不比exec少。 8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多\。12345678var string = "2017-06-27 2017.06.27 2017/06/27";var regex = /\d&#123;4&#125;(-|\.|\/)\d&#123;2&#125;\1\d&#123;2&#125;/g;console.log( string.match(regex) );// =&gt; ["2017-06-27", "2017.06.27", "2017/06/27"]regex = new RegExp("\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;", "g");console.log( string.match(regex) );// =&gt; ["2017-06-27", "2017.06.27", "2017/06/27"] 9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline 10 source属性 正则实例对象属性，除了global、ingnoreCase、multiline、lastIndex属性之外，还有一个source属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么：1234var className = "high";var regex = new RegExp("(^|\\s)" + className + "(\\s|$)");console.log( regex.source )// =&gt; (^|\s)high(\s|$) 即字符串"(^|\\s)high(\\s|$)" 11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是$1,…,$9之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp[&quot;$&apos;&quot;] 测试代码如下：1234567891011121314151617181920212223var regex = /([abc])(\d)/g;var string = "a1b2c3d4e5";string.match(regex);console.log( RegExp.input );console.log( RegExp["$_"]);// =&gt; "a1b2c3d4e5"console.log( RegExp.lastMatch );console.log( RegExp["$&amp;"] );// =&gt; "c3"console.log( RegExp.lastParen );console.log( RegExp["$+"] );// =&gt; "3"console.log( RegExp.leftContext );console.log( RegExp["$`"] );// =&gt; "a1b2"console.log( RegExp.rightContext );console.log( RegExp["$'"] );// =&gt; "d4e5" 结语： 我搜查列出了相关的6个方法，并对6个方法进行了说明。 后面我会对replace再单独出一篇文章。 参考资料里的第一篇文章真的非常好，值得仔细研读。 如果你想粗略了解正则的方法，看我这篇文章是没错了，后面列出的相应方法的坑点和注意点。 后面，我会再慢慢补充匹配规则，我会单独列出一篇文章，因为匹配规则也有很多注意点呢。 哈哈哈，其实也是在下面的文章里面看的啦，文章真的写得好---嘻嘻 其实正则也没有那么难的啦----- 希望这篇文章对你有帮助，每天都要加油哦。 加油，与君共勉！！！ 参考资料： JS正则表达式完整教程（略长） 文章真的写的不错，认认真真，细嚼慢咽的看完这篇文章，保证你学会正则。 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。 MDN-RegExp MDN-String]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM操作之sequelize]]></title>
    <url>%2Fhexo-blog%2F2019%2F08%2F02%2FORM%E6%93%8D%E4%BD%9C%E4%B9%8Bsequelize%2F</url>
    <content type="text"><![CDATA[前言： 说实话，这篇文章本想自己写的，因为一开始就是研究 官方文档 和 github上翻译的文章，奈何，还是被官方文档所折服，其实觉得官方文档写得还是不错的，只是缺少案例，我在做demo的时候，还是遇到了一些疑惑，故google了一下，结果发现了下面这三篇文章，文章架构合理，条条是道，非常适合学习，也是我想要的总结的文章，帮我解决了很多疑惑。 总结难点： 我来说说我遇到的难点： 1. 关联，在create时，如何添加外键： 这里我确实没理解到 文档 的意思，而且文档给的伪代码有点难懂。 算了，我就不说难点了，我感觉主要还是我的问题，没理解到文档的要义（但是感觉文档的案例确实有点抽象）。 来一点配置总结吧 async同步表参数 name type default description force bool false 强制同步,会删除表中数据 match RegExp null 在同步之前将正则表达式与数据库名称匹配，对在测试中使用force：true而不是实时代码的情况进行安全检查 logging bool/功能函数 console.log 记录sql查询的函数 schema string — 应该在其中创建表的模式。可以为sequelize.define中的每个表覆盖此模式 hooks bool true 如果hooks为true，则在BeforeSync之前，afterSync，beforeBulkSync之后，将调用afterBulkSync钩子 alter bool false 改变表格以适合模型。不建议用于生产用途。删除已删除的列中的数据或在模型中更改其类型的数据 说明：如果想要增加字段，就设置alter为true，但是当你更改表结构的时候，没有的字段就会被删除，那个字段的数据也会被删除 常用数据类型 123456789101112131415161718Sequelize.STRING // VARCHAR(255)Sequelize.STRING(1234) // VARCHAR(1234)Sequelize.TEXT // TEXTSequelize.TEXT('tiny') // TINYTEXTSequelize.INTEGER // INTEGERSequelize.FLOAT // FLOATSequelize.DOUBLE // DOUBLESequelize.DATEONLY // DATE 不带时间.Sequelize.DATE // mysql / sqlite 为 DATETIME, postgres 为带时区的 TIMESTAMPSequelize.UUID // PostgreSQL 和 SQLite 的 UUID 数据类型,MySQL 的 CHAR(36) BINARY(使用defaultValue:Sequelize.UUIDV1 或 Sequelize.UUIDV4 来让 sequelize 自动生成 id).Sequelize.JSON // JSON 列. 仅 PostgreSQL, SQLite 和 MySQL.Sequelize.JSONB // JSONB 列. 仅 PostgreSQL.Sequelize.BLOB // BLOB (PostgreSQL 为 bytea) 模型定义 参数有两种定义方式，我喜欢最新的这种，参考这里， 下面我只列出我觉得比较常用的，需要查看全部字段的请点击 这里直达 init( attributes：Object，options：Object ) 字段参数 类型 属性/默认值 描述 type 数据类型 必填 数据类型 allowNull bool true 如果为false，则列将具有NOT NULL约束，并且在保存实例之前将运行非null验证。 defaultValue any null 默认值、可以是sql语句和fn函数，（fn函数我没用过） unique bool false 如果为true，则列将获得唯一约束。如果提供了字符串，则该列将成为复合唯一索引的一部分。如果多个列具有相同的字符串，则它们将是同一个唯一索引的一部分 primaryKey bool false 主键 field string null 如果设置，则sequelize会将属性名称映射到数据库中的其他名称,就是在数据库中这个字段的名称设置为这个string autoIncrement bool false 自增 comment string null 字段的说明 references Model null/obj 具有参考配置的对象 references.model model 可选 如果此列引用另一个表，请在此处将其作为模型或字符串提供 references.key string 默认id 此列引用的外表的列 validate obj 选择 字段验证，详情请参考这里 options - - 第二个参数，对象 sequelize obj 必填 db实例对象 modelName string op 设置模型的名称。默认情况下与类名相同 timestamps bool true 将createdAt和updatedAt时间戳添加到模型中 paranoid bool false 调用destroy不会删除模型，而是设置deletedAt时间戳，如果这是真的。需要timestamps=true工作 underscored bool false 将下划线字段添加到所有属性，这包括用户定义的属性，时间戳和外键。不会使用显式设置field选项影响属性 createdAt bool op — updatedAt bool op — deletedAt bool op — example: 12345678910111213141516171819Project.init(&#123; columnA: &#123; type: Sequelize.BOOLEAN, validate: &#123; is: ['[a-z]','i'], // will only allow letters max: 23, // only allow values &lt;= 23 isIn: &#123; args: [['en', 'zh']], msg: "Must be English or Chinese" &#125; &#125;, field: 'column_a' // Other attributes here &#125;, columnB: Sequelize.STRING, columnC: 'MY VERY OWN COLUMN TYPE'&#125;, &#123;sequelize&#125;)sequelize.models.modelName // The model will now be available in models under the class name 定义模型的方法我们在定义模型时：定义在继承的Model中 模型扩展语法：123456789101112class User extends Model &#123; // 添加一个类级别的方法 static classLevelMethod() &#123; return 'foo'; &#125; // 添加实例级别方法 instanceLevelMethod() &#123; return 'bar'; &#125;&#125;User.init(&#123; firstname: Sequelize.STRING &#125;, &#123; sequelize &#125;); example: 12345678910111213141516171819202122232425262728293031323334353637383940// 继承Model定义方式class Foo extends Model &#123; get fullName() &#123; return this.firstname + ' ' + this.lastname; &#125; set fullName(value) &#123; const names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); &#125;&#125;Foo.init(&#123; firstname: Sequelize.STRING, lastname: Sequelize.STRING&#125;, &#123; sequelize, modelName: 'foo'&#125;);// 或使用 `sequelize.define`sequelize.define('Foo', &#123; firstname: Sequelize.STRING, lastname: Sequelize.STRING&#125;, &#123; getterMethods: &#123; fullName() &#123; return this.firstname + ' ' + this.lastname; &#125; &#125;, setterMethods: &#123; fullName(value) &#123; const names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); &#125; &#125;&#125;); 模型引入都使用db实例import()引入： example：12var sequelize = require("../config/db"); // db的导出实例var User = sequelize.import("./user"); 推荐的文章 这是一个系列文章，强烈推荐 Sequelize 快速入门 Sequelize 系列教程之一对一模型关系 Sequelize 系列教程之一对多模型关系 Sequelize 系列教程之多对多模型关系 基本的操作都有详细的案例，很赞！ 官方文档： 官方文章 github翻译文档 中文api文章]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>sequelize</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔：一路烟霞]]></title>
    <url>%2Fhexo-blog%2F2019%2F08%2F02%2F%E9%9A%8F%E7%AC%94%EF%BC%9A%E4%B8%80%E8%B7%AF%E7%83%9F%E9%9C%9E%2F</url>
    <content type="text"><![CDATA[前言： 现在是下午三点五十四分，午睡两小时刚醒。 心心念念的随笔终于要开始写了，曾多次在睡前构思，下笔时，却又毫无头绪了。 时光如梭，大学两年了， 这一路走来，真的感悟良多呢----]]></content>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之apply-call-bind]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F30%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8Bapply-call-bind%2F</url>
    <content type="text"><![CDATA[前言： 在学习js的过程中，看到不少方法中有使用call、apply、bind方法，特别react中，经常使用bind方法，如果理解得好，你可以非常灵活的使用他们….. 比如： 怎么利用call、apply来求一个数组中最大或者最小值 如何利用call、apply来做继承 apply、call、bind的区别和主要应用场景 虽然网上有很多关于这方面的博客和文章，但还是决定写一篇自己对这方面知识的理解。 GO!!! 首先问个问题，这三个函数的存在意义是什么？答案是改变函数执行时的上下文，再具体一点就是改变函数运行时的this指向。有了这个认识，接下来我们来看一下,怎么使用这三个函数。 举个栗子 1234567891011function Person(name)&#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, showName: function()&#123; console.log(this.name); &#125;&#125;var person = new Person('curtainTan');person.showName(); // curtainTan 接下来 123var animal = &#123; name: 'cat'&#125; 上面代码中有一个对象字面量，他没有所谓的showName方法，但是我还是想用？怎么办？(坑爹了，这好像在让巧媳妇去做无米之炊)，不过没关系，call、apply、bind可以帮我们干这件事。 123456// 1 callperson.showName.call(animal); // cat// 2 applyperson.showName.apply(animal); // cat// 3 bindperson.showName.bind(animal)(); // cat 啦啦啦，有木有很神奇，控制台输出了三次cat 我们拿别人的showName方法，并动态改变其上下文帮自己输出了信息，说到底就是实现了复用 区别 上面看起来三个函数的作用差不多，干的事几乎是一样的，那为什么要存在3个家伙呢，留一个不就可以。所以其实他们干的事从本质上讲都是一样的动态的改变this上下文,但是多少还是有一些差别的.. call、apply与bind的差别 call和apply改变了函数的this上下文后便执行该函数. bind则是返回改变了上下文后的一个函数. call、apply的区别 call(): 语法：fn.call(obj, arg1, arg2, arg3…); 参数： obj ：可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 arg1, arg2, … : 指定的参数列表。 apply(): 语法：fn.call(obj, [argsArray] ); 参数： obj ：可选的, 同上。 argsArray : 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。 应用 知道了怎么使用和他们之间的区别，接下来我们来了解一下通过call、apply、bind的常见应用场景。 求数组中的最大和最小值 12345var arr = [34,5,3,6,54,6,-67,5,7,6,-8,687];Math.max.apply(Math, arr);Math.max.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);Math.min.apply(Math, arr);Math.min.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687); 利用call和apply做继承 123456789101112var Person = function (name, age) &#123; this.name = name; this.age = age;&#125;;var Girl = function (name) &#123; Person.call(this, name);&#125;;var Boy = function (name, age) &#123; Person.apply(this, arguments);&#125;var g1 = new Girl ('qing');var b1 = new Boy('qianlong', 100); 将伪数组转化为数组 js中的伪数组(例如通过document.getElementsByTagName获取的元素)具有length属性，并且可以通过0、1、2…下标来访问其中的元素，但是没有Array中的push、pop等方法。我们可以利用call、apply来将其转化为真正的数组这样便可以方便地使用数组方法了。 12345678var arrayLike = &#123; 0: '11111', 1: '22222', 2: '33333', length: 3&#125;var arr = Array.prototype.slice.call(arrayLike); 上面arr便是一个包含arrayLike元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有length属性 ) 数组追加 在js中要往数组中添加元素，可以直接用push方法， 12345var arr1 = [1,2,3];var arr2 = [4,5,6];[].push.apply(arr1, arr2);// arr1 [1, 2, 3, 4, 5, 6]// arr2 [4,5,6] 结语：总的来说三个方法都是改变this指向。 区别有二： apply()和call()会立即执行，bind()不会立即执行 apply()的第二个参数是一个数组或类数组，call()的参数是参数列表 不知道会不会有人看，就假装有人看吧！！！ 哈哈哈，共勉 参考资料： js中call、apply、bind那些事 写给新人的call、apply、bind]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖与节流]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F30%2F%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖 123456789101112131415161718192021222324function debounce(fn,interval)&#123; var timer, isFirst = true, can = false; return function()&#123; var args = arguments, that = this; if(timer)&#123; clearTimeout(timer) timer = null &#125; if(isFirst)&#123; fn.apply(that,args) isFirst = false setTimeout(() =&gt; &#123; can = true &#125;, interval || 1000); &#125;else if(can)&#123; timer = setTimeout(() =&gt; &#123; fn.apply(null,args) &#125;, interval || 1000); &#125; &#125;&#125; 节流 1234567891011121314151617181920function throttle(fn,interval)&#123; var timer, isFirst = true; return function()&#123; var args = arguments, that = this; if(isFirst)&#123; fn.apply(that,args) return isFirst = false &#125; if(timer)&#123; return &#125; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null fn.apply(that,args) &#125;, interval || 1000); &#125; &#125; 结语 个人防抖用得较多，曾经写防抖和节流都是在全局上做标记。 参考wclimb的防抖与节流，我会了闭包节流与防抖。感觉不错 关于使用apply的解释：参考资料JavaScript之节流与防抖]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之关键字与保留字]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F30%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%2F</url>
    <content type="text"><![CDATA[关键字 JavaScript 所有关键字 12345678910111213141516171819202122232425breakcasecatchcontinuedefaultdeletedoelsefinallyforfunctionifininstanceofnewreturnswitchthisthrowtrytypeofvarvoidwhilewith 主要想整理下几个自己不怎么了解的关键字： delete 定义：删除对象（而非构造方法或原型）的某个属性 1234567891011121314function obj(id,name)&#123; this.id = id; this.name = name; this.getName = function()&#123; return this.name; &#125; &#125; var objTwo = new obj(2,"objTwoName"); console.log("objOne名字为："+objTwo.getName()); // objOne名字为：objTwoName delete objTwo.name; console.log("objOne名字为："+objTwo.name); // objOne名字为：undefined 注意： 只能删除自身定义的公有属性，即”this.属性名”定义的属性， 而不能删除私有属性或通过proptotype定义的公有属性。 此外可删除直接在对象上添加的属性，如var a = new Object();a.name = “name”;delete a.name; throw 与 try…catch…finally：操作异常 JS 的几种具体异常类型（都继承自Error 异常类）： （1）、SyntaxError：语法错误，如代码中不小心按了个特殊符号； （2）、ReferenceError：引用错误，常见提示：Uncaught ReferenceError: a is not defined； （3）、RangeError：范围错误，常见对数组的操作等； （4）、TypeError：类型错误，如：xxx is not a function； （5）、.URLError：与url相关参数不正确，主要是encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数； （6）、EvalError：全局函数eval 执行错误（注：eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码）。 1234567891011121314151617181920212223&lt;script&gt; function CommonException(message, code) &#123; this.message = message; this.code = code; &#125; try &#123; var exception = new CommonException('您的代码出错啦', 1); throw exception; alert('这地方的代码将不会执行到'); &#125; catch (e) &#123; alert(e.message); alert(e.code) &#125; &lt;/script&gt; in in：与for 一起使用用于遍历对象的属性名 12345678910111213141516var obj = &#123; "key1":"value1", "key2":"value2", "key3":"value3"&#125;; //属性名function EnumaKey()&#123; for(var key in obj )&#123; console.log(key); &#125;&#125;// key1// key2// key3 重点： 在使用for in遍历对象时候，对象有一个重要的方法：hasOwnProperty()。该方法可以在遍历对象属性的时候可以过滤掉从原型链上下来的属性。 判断某个对象是否具有某个属性对于一般的对象属性需要用字符串指定属性的名称 如: 123var mycar = &#123;make: "Honda", model: "Accord", year: 1998&#125;;"make" in mycar // returns true"model" in mycar // returns true 对于数组对象，元素值对应的属性名为数字类型，如： 12345678// Arraysvar trees = new Array("redwood", "bay", "cedar", "oak", "maple");0 in trees // returns true3 in trees // returns true6 in trees // returns false"bay" in trees // returns false (you must specify the index number, // not the value at that index)"length" in trees // returns true (length is an Array property) 注意：in 的右边必须是一个对象，如：你可以指定一个用String构造器生成的，但是不能指定字符串直接量的形式： 1234var color1 = new String("green");"length" in color1 // returns truevar color2 = "coral";"length" in color2 // generates an error (color is not a String object) instanceof 定义：返回的是布尔值，而typeof 返回的是几种数据类型的字符串值。 with 定义：引用一个对象，使访问属性与方法更加方便（只能访问与修改属性，不能增加属性与方法） 12345678910111213141516function obj(id,name)&#123; this.id = id; this.name = name; this.getName = function()&#123; return this.name; &#125;&#125;var myObj = new obj(3,"three");with(myObj)&#123; alert(id);//提示3 alert(name);//提示three alert(getName());//提示three id = 4; alert(id);//提示4&#125;alert(myObj.id);//提示4，说明with中是通过引用方式访问的，而不是复制值的方式 JavaScript 所有保留字 保留字是为以后js的扩展用的，不能作为普通变量名。列表： 12345678910111213141516171819202122232425262728293031abstractbooleanbytecharclassconstdebuggerdoubleenumexportextendsfinalfloatgotoimplementsimportintinterfacelongnativepackageprivateprotectedpublicshortstaticsupersynchronizedthrowstransientvolatile 结语：之前看Obj的代码的时候，不知道delete怎么用，后来专门查了一下，并补充了一下基础知识。 —-文章总结的挺好的，共勉—– 参考材料转载于： JS 基础 —— JavaScript 关键字（keyword）与保留字]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习之Object]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0%E4%B9%8BObject%2F</url>
    <content type="text"><![CDATA[Object 静态方法总结 create 创建一个对象12345678910111213141516171819202122232425262728const obj = Object.create(&#123;a:1&#125;, &#123;b: &#123;value: 2&#125;&#125;)// 第一个参数为对象，对象为函数调用之后返回新对象的原型对象，// 第二个参数为对象本身的实例方法（默认不能修改,不能枚举）obj.__proto__.a === 1 // true obj.b = 3;console.log(obj.b) // 2//创建一个可写的,可枚举的,可配置的属性pobj2 = Object.create(&#123;&#125;, &#123;p: &#123; value: 2, // 属性值 writable: true, // 是否可以重写值 enumerable: true, //是否可枚举 configurable: true //是否可以修改以上几项配置&#125;&#125;);obj2.p = 3;console.log(obj2.p) // 3注意： enumerable 会影响以下for…in 遍历包括对象原型上属性Object.keys() 只能遍历自身属性JSON.stringify 只能序列化自身属性 defineProperty 定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法：Object.defineProperty(obj, prop, descriptor) 123456789101112131415161718192021222324252627282930313233343536 添加数据属性`` var obj = &#123;&#125;; // 1.添加一个数据属性 Object.defineProperty(obj, "newDataProperty", &#123; value: 101, writable: true, enumerable: true, configurable: true &#125;); obj.newDataProperty // 101 // 2.修改数据属性 Object.defineProperty(obj, "newDataProperty", &#123; writable:false &#125;); //添加访问器属性 var obj = &#123;&#125;; Object.defineProperty(obj, "newAccessorProperty", &#123; set: function (x) &#123; this.otherProperty = x; &#125;, get: function () &#123; return this.otherProperty; &#125;, enumerable: true, configurable: true &#125;);注意： 1.第一个参数必须为对象 2.descriptor 不能同时具有 （value 或 writable 特性）（get 或 set 特性）。 3.configurable 为false 时，不``能重新修改装饰器 defineProperties 定义：定义多个属性 语法：Object.defineProperties(object, {prop1 : descriptor1, prop2 : descriptor2, …) 123456789101112var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125; // etc. etc.&#125;); keys() 定义： 遍历可枚举的属性，只包含对象本身可枚举属性，不包含原型链可枚举属性 1234567let arr = ["a", "b", "c"];let obj = &#123; foo: "bar", baz: 42 &#125;;let ArrayLike = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;Object.keys(arr) // ['0', '1', '2']Object.keys(obj) // ["foo","baz"]Object.keys(ArrayLike) // ['0', '1', '2'] values() 定义：遍历可枚举的属性值，只包含对象本身可枚举属性值，不包含原型链可枚举属性值 1234567let arr = ["a", "b", "c"];let obj = &#123; foo: "bar", baz: 42 &#125;;let ArrayLike = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;Object.values(arr) // ["a", "b", "c"]Object.values(obj) // ["bar",42]Object.values(ArrayLike) // ["a", "b", "c"] assign 定义：Object.assign( target, source, source1 ) 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false） 语法：Object.assign(target, …sources) 参数： 参数 说明 target 目标对象。 sources 源对象。 返回值 目标对象。 12345678910111213const o1 = &#123; a: 1, b: 1, c: 1 &#125;;const o2 = &#123; b: 2, c: 2 &#125;;const o3 = &#123; c: 3 &#125;;const obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;特殊情况：let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // trueObject.assign([1, 2, 3], [4, 5]) // [4, 5, 3] 说明：Object.assign方法实行的是浅拷贝，而不是深拷贝。 1234567const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;console.log(obj2.a.b) //2obj2.a.b = 3console.log(obj1.a.b) //3 getPrototypeOf() 说明：获取指定对象的原型（内部[[Prototype]]属性的值） 1234567const prototype1 = &#123;&#125;;const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1); // true注意：Object.getPrototypeOf(Object) 不是 Object.prototype Object.getPrototypeOf( Object ) === Function.prototype; // true setPrototypeOf 说明：设置一个指定的对象的原型 12345const obj = &#123;a: 1&#125;, proto = &#123;b:2&#125;Object.setPrototypeOf(obj, proto)obj.__proto__ === proto //true getOwnPropertyNames 说明：与keys相似，但包含遍历，包含不可枚举属性, 返回属性数组 12345678910var my_obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function() &#123; return this.foo; &#125;, enumerable: false &#125;&#125;);my_obj.foo = 1;Object.getOwnPropertyNames(my_obj).sort() // ["foo", "getFoo"] getOwnPropertyDescriptor() 说明：获取该属性的描述对象， 返回说明对象 语法：Object.getOwnPropertyDescriptor(obj, prop) 123456789101112131415161718192021222324252627282930313233var o, d;o = &#123; get foo() &#123; return 17; &#125; &#125;;d = Object.getOwnPropertyDescriptor(o, "foo");// d &#123;// configurable: true,// enumerable: true,// get: /*the getter function*/,// set: undefined// &#125;o = &#123; bar: 42 &#125;;d = Object.getOwnPropertyDescriptor(o, "bar");// d &#123;// configurable: true,// enumerable: true,// value: 42,// writable: true// &#125;o = &#123;&#125;;Object.defineProperty(o, "baz", &#123; value: 8675309, writable: false, enumerable: false&#125;);d = Object.getOwnPropertyDescriptor(o, "baz");// d &#123;// value: 8675309,// writable: false,// enumerable: false,// configurable: false// &#125; getOwnPropertyDescriptors 说明：返回指定对象所有自身属性（非继承属性）的描述对象 123456789101112131415161718192021222324252627282930const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;; console.dir(Object.getOwnPropertyDescriptors(obj))// &#123; foo:&#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:&#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; // &#125;使用场景：Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型Object.create() 方法可以实现上面说的这些，配合getPrototypeOf，以及getOwnPropertyDescriptors实现全面浅拷贝Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); entries 说明：分割对象 方法返回一个给定对象自身可枚举属性的键值对数组， 其排列与使用 for...in 循环遍历该对象时返回的顺序一致（ 区别在于 for-in 循环也枚举原型链中的属性）。 1234567891011const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// array like objectconst obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]// stringObject.entries('abc') // [['0', 'a'], ['1', 'b'], ['2', 'c']]Object.entries(100) // [] is 说明：它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 12345678910Object.is('foo', 'foo') // trueObject.is(&#123;&#125;, &#123;&#125;) // false不同于 === 之处+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true preventExtensions 说明：让一个对象变的不可扩展，也就是永远不能再添加新的属性&amp;isExtensible 判断一个对象是否可扩展 1234567891011121314151617181920let empty = &#123;&#125;Object.isExtensible(empty) //trueempty.a = 1 //添加成功//将对象变为不可拓展Object.preventExtensions(empty)Object.isExtensible(empty) //falseempty.b = 2 //静默失败,不抛出错误empty.a = 5 //修改a属性值为5 修改成功总结： 1.preventExtensions 可以让这个对象变的不可扩展，也就是不能再有新的属性。 2.需要注意的是不可扩展的对象的属性通常仍然可以被删除。 3.尝试给一个不可扩展对象添加新属性的操作将会失败，不过可能是静默失败， 也可能会抛出 TypeError 异常（严格模式）。 4.Object.preventExtensions 只能阻止一个对象不能再添加新的自身属性， 仍然可以为该对象的原型添加属性。 seal &amp;&amp; isSealed 说明： seal()将一个对象密封 isSealed 判断一个对象是否为密封的 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。 isSealed 判断一个对象是否为密封的 1234567891011121314151617181920212223242526272829303132333435363738394041密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。1. 先讲seal 方法：var o2 = &#123;b: 1&#125;o2.d = 2 //添加成功var obj2 = Object.seal(o2);obj2 === o2 //true 方法返回原对象，栈指针指向同一块内存Object.isSealed(o2) // trueo2.b = 111 //修改b属性值成功o2.f = 222 //静默失败,属性f没有成功添加delete o2.b //静默失败,属性b没有成功删除2. 讲isSealed 方法：let o = &#123;&#125;;Object.isSealed(o) //false// 之后通过Object.preventExtensions方法将空对象设置为不可扩展。Object.preventExtensions(o);Object.isSealed(o) // true但是如果为非空对象呢？let o2 = &#123;a: 1&#125;Object.preventExtensions(o2);Object.isSealed(o2) // false因为属性 a 是可配置的（configurable为true），所以不是密封的对象，修改方法如下：let o2 = &#123;a: 1&#125;Object.preventExtensions(o2);Object.defineProperty(o2, "a", &#123; configurable: false &#125;);Object.isSealed(o2) //true总结： 1.密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。 2.属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。 3.但属性的值仍然可以修改。 4.尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常（严格模式）。 freeze &amp;&amp; isFrozen说明： freeze()冻结一个对象 isFrozen()判断一个对象是否已经被冻结 一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性， 不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性， 以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591.先讲freeze 方法：let o3 = &#123;a: 1&#125;o3.b = 2 //添加属性b成功Object.freeze(o3)Object.isFrozen(o3) //true 对象已被冻结o3.a = 2 //修改属性a值失败o3.c = 5 //添加属性c失败delete o3.b //删除属性b失败2.再讲isfrozen 方法：let o4 = &#123;a: 1&#125;o4.b = 2 // 添加属性b成功Object.priventExtensions(o4)Object.defineProperties(o4, &#123; a: &#123;configurable: false, writable: false&#125;, b: &#123;configurable: false, writable: false&#125;&#125;)Object.isFrozen(o4) //true o4 已经被冻结总结： 1.冻结对象的所有自身属性都不可能以任何方式被修改。 2.任何尝试修改该对象的操作都会失败，可能是静默失败，也可能会抛出异常（严格模式中）。 3.数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。 4.如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。 浅冻结与深冻结：(function () &#123; obj = &#123; internal :&#123;&#125; &#125;; Object.freeze(obj);//浅冻结 obj.internal.a = "aValue"; console.log(obj.internal.a);//"aValue" //想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数. function deepFreeze(o)&#123; var prop,propKey; Object.freeze(o);//首先冻结第一层对象 for(propKey in o)&#123; prop = o[propKey]; if(!o.hasOwnProperty(propKey) || !(typeof prop === "object") || Object.isFrozen(prop))&#123; continue; &#125; deepFreeze(prop);//递归 &#125; &#125; deepFreeze(obj); obj.internal.b = "bValue";//静默失败 console.log(obj.internal.b);//undefined&#125;)(); hasOwnProperty() 12345678910111213141516171819202122方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性let o = &#123;a: 1 &#125;o.hasOwnProperty('a') //trueo.hasOwnProperty('b') //false 对象自身没有属性bo.hasOwnProperty('toString'); //false 不能检测对象原型链上的属性如何遍历一个对象的所有自身属性，例子：var buz = &#123; fog: 'stack'&#125;;for (var name in buz) &#123; if (buz.hasOwnProperty(name)) &#123; console.log("this is fog (" + name + ") for sure. Value: " + buz[name]); &#125; else &#123; console.log(name); // toString or something else &#125;&#125; isPrototypeOf() 123456789101112131415isPrototypeOf方法用于测试一个对象是否存在于另一个对象的原型链上function Foo() &#123;&#125;function Bar() &#123;&#125;function Baz() &#123;&#125;Bar.prototype = Object.create(Foo.prototype);Baz.prototype = Object.create(Bar.prototype);var baz = new Baz();console.log(Baz.prototype.isPrototypeOf(baz)); // trueconsole.log(Bar.prototype.isPrototypeOf(baz)); // trueconsole.log(Foo.prototype.isPrototypeOf(baz)); // trueconsole.log(Object.prototype.isPrototypeOf(baz)); // true propertyIsEnumerable 说明：指定的属性是否可枚举 12345678910111213141516171819202122232425262728293031323334obj.propertyIsEnumerable(prop) prop为被测试的属性名1. 一般情况下var o = &#123;&#125;;var a = [];o.prop = 'is enumerable';a[0] = 'is enumerable';o.propertyIsEnumerable('prop'); // 返回 truea.propertyIsEnumerable(0); // 返回 true2. 浏览器内置对象var a = ['is enumerable'];a.propertyIsEnumerable(0); // 返回 truea.propertyIsEnumerable('length'); // 返回 falseMath.propertyIsEnumerable('random'); // 返回 falsethis.propertyIsEnumerable('Math'); // 返回 false3. 自身属性和继承属性（原型链上propertyIsEnumerable不被考虑）var fn = function()&#123; this.prop = '123';&#125;fn.prototype = &#123; prototypeProp: true&#125;var o = new fn()o.propertyIsEnumerable('prop') // trueo.propertyIsEnumerable('prototypeProp') // false caller 说明：返回当前函数的调用者 12345678910111213141516171819202122function test()&#123; if(test.caller == null)&#123; alert("JavaScript顶层作用域调用了test()函数"); &#125;else&#123; alert( test.caller + "函数调用了test()函数"); &#125;&#125;;test(); // JavaScript顶层作用域调用了test()函数function callTest()&#123; test();&#125;callTest(); // function callTest()&#123; test(); &#125;函数调用了test()函数function callTest2()&#123; // setTimeout()或setInterval()中定时执行的函数也属于顶层作用域调用 setTimeout(test, 5000); // JavaScript顶层作用域调用了test()函数&#125;callTest2(); valueOf() 说明：需要返回对象的原始值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162备注：js对象中的valueOf()方法和toString()方法非常类似，但是，当需要返回对象的原始值而非字符串的时候才调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用valueOf()方法。const o = &#123;a: 1, valueOf: function()&#123; return 123123 &#125; &#125;Number(o) //123123// 给大家出一个题const o2 = &#123; x: 1, valueOf: function()&#123; return this.x++ &#125;&#125;if(o2 == 1 &amp;&amp; o2 == 2 &amp;&amp; o2 == 3)&#123; console.log('down') console.log(o2.x)&#125;else&#123; console.log('faild')&#125;// Array：返回数组对象本身var array = ["CodePlayer", true, 12, -5];array.valueOf() === array; // true// Date：当前时间距1970年1月1日午夜的毫秒数var date = new Date(2013, 7, 18, 23, 11, 59, 230);date.valueOf() // 1376838719230// Number：返回数字值var num = 15.26540;num.valueOf() // 15.2654// 布尔：返回布尔值true或falsevar bool = true;bool.valueOf() === bool // true// new一个Boolean对象var newBool = new Boolean(true);// valueOf()返回的是true，两者的值相等newBool.valueOf() == newBool // true// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型newBool.valueOf() === newBool // false// Function：返回函数本身function foo()&#123; &#125;foo.valueOf() === foo // truevar foo2 = new Function("x", "y", "return x + y;");foo2.valueOf() === foo2 // true// Object：返回对象本身var obj = &#123;name: "张三", age: 18&#125;;obj.valueOf() === obj // true// String：返回字符串值var str = "http://www.365mini.com";str.valueOf() === str // true// new一个字符串对象var str2 = new String("http://www.365mini.com");// 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型str2.valueOf() === str2 // false getOwnPropertySymbols 说明：在给定对象自身上找到的所有 Symbol 属性的数组。 123456789101112var obj = &#123;&#125;;var a = Symbol("a");var b = Symbol.for("b");obj[a] = "localSymbol";obj[b] = "globalSymbol";var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols.length); // 2console.log(objectSymbols) // [Symbol(a), Symbol(b)]console.log(objectSymbols[0]) // Symbol(a) toString &amp;&amp; toLocalString 12345678910111213toString 方法不做过多介绍区别：当被转化的值是个时间对象时，toLocaleString会将转化的结果以本地表示。(new Date).toString(); //"Mon Nov 06 2017 13:02:46 GMT+0800 (China Standard Time)"(new Date).toLocaleString(); //"2017/11/6 下午1:03:12"另外当被转化的值是个时间戳时，toLocaleString会把时间戳每三位添加一个逗号，代码如下。(Date.parse(new Date())).toLocaleString() //"1,509,944,637,000"(Date.parse(new Date())).toString() //"1509944643000" length &amp;&amp; name12Object.length //1Object.name //"Object" 总结：又是一片好文章，每个api的案例都很好。 参考资料js Object方法大全（自己整理） MDN–Object文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历方法总结]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2Fjs%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言学习一门语言，遍历是少不了的！！ gogogo,开始吧 标准操作 for循环 就是正常的for循环， 123456789var arr = ['element1', 'element2', 'element3'];for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(arr[i]);&#125;// element1// element2// element3 数组自带方法forEach 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值 123456789var arr = ['element1', 'element2', 'element3'];arr.forEach(function(value, index, arr) &#123; console.log(value);&#125;);// element1// element2// element3 说明：比较遗憾的是以上的代码未能按照我们的预期运行（break、continue等语句跨越了函数边界），所以这个看似完美的办法实际上只能一条道走到黑，像吃了炫迈一样根本停不下来。当数组很大，没办法通过提前终止遍历来节省资源。 for in循环 很强大！！1234567var arr = ['element1', 'element2', 'element3'];for (var i in arr) &#123; console.log(arr[i]);&#125;// element1// element2// element3 for in语句是一种精准的迭代语句，可以枚举对象的所有可枚举属性(可以使用Object.getOwnPropertyDescriptor(targetObj, attrName)方法来查看对象的某个属性是否可枚举)。It means that，可以用它来遍历对象： 12345678910111213var obj = &#123; a: 1, b: 1, c: 1&#125;;for (let attr in obj) &#123; console.log(attr, obj[attr]);&#125;// a 1// b 1// c 1 除了遍历对象、数组之外，for in循环还可兼职遍历字符串：1234567var str = 'I am a handsome boy!';for (var i in str) &#123; console.log(str[i]);&#125;// 太帅(chang)了，结果就不打印了 当然，也支持break、continue的操作，例子我就不写了。 缺点：123456789101112131415161718192021222324var father = &#123; fatherAttr: 1&#125;;// 以father为原型创建对象实例instancevar instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;for (var attr in instance) &#123; console.log(attr, instance[attr]);&#125;// a 1// b 1// c 1// fatherAttr 1// 获取instance实例的自有属性名console.log(Object.getOwnPropertyNames(instance));// ["a", "b", "c"] 上面这个例子中，首先以father对象为原型创建了一个对象实例instance，然后为这个实例instance添加了a、b、c三个属性，接着使用for in循环遍历这个对象。通过查看instance的自有属性可以发现，fatherAttr并不是instance的属性，而是其原型father的属性，for in循环会将对象的原型属性也一并列举出来。故使用此方法去遍历对象属性的时候，需要加多一层判断： 12345for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; // 是对象的自有属性，可以尽情的玩耍了 &#125;&#125; for of循环 通过for in循环可以解决传统for循环需要维护边界的问题，但也引入了一些新问题，跟搬砖工作者的日常操作“解决3个bug，引入8个新bug”场景极度相似。 所以换个es6定义的for of循环操作试试：12345678910111213let str = 'a 𠮷 c';for (let char of str) &#123; if (char === ' ') &#123; continue; &#125; else &#123; console.log(char); &#125;&#125;// a// 𠮷// c 从上面的例子来看，效果简直是perfect：索引去掉了，边界去掉了，想继续就继续，想退出就退出，还能顺便解决一下字符串的编码问题。 缺点： 运行环境为ES6及以上版本，所以兼容性没有for in循环以及传统的操作好，如果需要考虑兼容上世纪的浏览器，就不能使用这个东西 只能用于遍历可迭代对象，即存在生成器方法（用于产生迭代器）的对象，如果用于遍历不可迭代对象，分分钟报错没商量。可以通过检测对象的Symbol.iterator方法（相关内容将放在下一篇）是否为函数来判断对象是否可迭代。 实际上，大多数JavaScript的内置对象都支持迭代，例如：Array、Set、Map、String等，当使用for of循环遍历上述对象时，就会使用其默认的生成器生成的迭代器： 123456789101112131415161718192021let map = new Map([['a', 1], ['b', 1], ['c', 1], ['d', 1]]);// 正经操作for (let item of map) &#123; console.log(item);&#125;// ["a", 1]// ["b", 1]// ["c", 1]// ["d", 1]// 使用解构，方便读取值for (let [key, value] of map) &#123; console.log(key, value);&#125;// a 1// b 1// c 1// d 1 上面的例子使用了for of遍历了Map类型实例map，迭代对象为Map类型的默认生成器生成的迭代器。当然，像Array、Set、Map类型还提供了一些特殊的生成器，可以让搬砖工作者更方便的去处理其想关注的内容： entries() 返回一个迭代器，其返回值为键值对数组（Map集合的默认迭代器；对于Set集合，返回值数组的元素相同，即value） keys() 返回一个迭代器，其返回值为集合的键名（对于Set集合，此迭代器跟values迭代器返回值相同;对于数组，此迭代器返回值为索引） values() 返回一个迭代器，其返回值为集合的值（Array、Set集合的默认迭代器） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let arr = ['a', 'b', 'c', 'd']let set = new Set(arr);for (let item of set.entries()) &#123; console.log(item);&#125;for (let item of arr.entries()) &#123; console.log(item);&#125;// ["a", "a"]// ["b", "b"]// ["c", "c"]// ["d", "d"]// [0, "a"]// [1, "b"]// [2, "c"]// [3, "d"]for (let item of set.keys()) &#123; console.log(item);&#125;for (let item of arr.keys()) &#123; console.log(item);&#125;// a// b// c// d// 0// 1// 2// 3for (let item of set.values()) &#123; console.log(item);&#125;for (let item of arr.values()) &#123; console.log(item);&#125;// a// b// c// d// a// b// c// d 除了JavaScript的内置对象，一些DOM标准的类型如NodeList也可以使用for of循环进行遍历： 12345let containers = document.querySelectorAll('.container');for (let node of containers) &#123; // 搞事情专用注释&#125; 很遗憾的是，for of循环居然不支持自定义对象的遍历（心中一万匹***奔腾而过……），所以如果不想使用for in循环遍历对象，只能转个弯了。 遍历对象的转弯操作 Object.keys()获取键名数组 使用Object.keys()可以获取到对象实例的所有可枚举属性，其返回值为一个数组，数组元素为对象的键名： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;// 以father为原型创建对象实例instancelet instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.keys(instance)) &#123; console.log(key);&#125;// a// b// c 不了解Object.defineProperty，可以参考: 深入浅出Object.defineProperty(),文章写得同属易懂，每个api都有案例。 Object.defineProperty( obj, prop, desc ) desc主要有四个 属性（value,writable, enumerable, configurable） Object.getOwnPropertyNames()获取键名数组 此方法跟keys方法表现一样，所不同的是，其返回的数组包含了对象的不可枚举属性： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.getOwnPropertyNames(instance)) &#123; console.log(key);&#125;// a// b// c// d Object.entries()获取键值对数组 这个方法返回什么东西就无需多言了吧，看例子： 123456789101112131415161718192021222324let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.entries(instance)) &#123; console.log(key);&#125;// ["a", 1]// ["b", 1]// ["c", 1] Object.values()获取对象的属性值数组 获取对象的值。 Object.getOwnPropertySymbols()获取Symbol属性名上面提到的几个方法都无法获取到对象实例的Symbol类型的属性名，如果需要遍历这个玩意，需要使用Object.getOwnPropertySymbols()方法： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;instance[Symbol('I am a handsome boy!')] = 1;for (let key of Object.keys(instance)) &#123; console.log(key);&#125;// a// b// cfor (let key of Object.getOwnPropertySymbols(instance)) &#123; console.log(key);&#125;// Symbol(I am a handsome boy!) 结语ok！这篇文章也是抄的: avaScript骚操作之遍历、枚举与迭代（上篇） 觉得总结的蛮好的。 当然，还有部分遍历是数组特有的方法。 比如：map，reduce， filter, every, some等，都可以遍历数组 好了，文章写完了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之字符串]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[String构造器方法 raw(ES6)定义：raw() 方法基于ECMAScript 2015（ES6）规范，它是一个模板字符串的标签函数，防止转义 如下是python的字符串前缀r： 1234# 防止特殊字符串被转义print r'a\nb\tc' # 打印出来依然是 "a\nb\tc"# python中常用于正则表达式regExp = r'(?&lt;=123)[a-z]+' 如下是String.raw作为前缀的用法： 1234567// 防止特殊字符串被转义String.raw`a\nb\tc`; // 输出为 "a\nb\tc"// 支持内插表达式let name = "louis";String.raw`Hello \n $&#123;name&#125;`; // "Hello \n louis"// 内插表达式还可以运算String.raw`1+2=$&#123;1+2&#125;,2*3=$&#123;2*3&#125;`; // "1+2=3,2*3=6" String.raw作为函数来调用的场景不太多，如下是用法： 1234// 对象的raw属性值为字符串时，从第二个参数起，它们分别被插入到下标为0，1，2，...n的元素后面String.raw(&#123;raw: 'abcd'&#125;, 1, 2, 3); // "a1b2c3d"// 对象的raw属性值为数组时，从第二个参数起，它们分别被插入到数组下标为0，1，2，...n的元素后面String.raw(&#123;raw: ['a', 'b', 'c', 'd']&#125;, 1, 2, 3); // "a1b2c3d" String.prototype和其他所有对象一样，字符串实例的所有方法均来自String.prototype。以下是它的属性特性： 值 属性 writable false enumerable false configurable false 可见，字符串属性不可编辑，任何试图改变它属性的行为都将抛出错误 与html无关的字符串方法常用的方法有： charAt、charCodeAt、concat、indexOf、lastIndexOf、localeCompare match、replace、search、slice、split、substr substring、toLocaleLowerCase、toLocaleUpperCase、toLowerCase、toString、toUpperCase trim、valueof 等ES5支持的， 以及 codePointAt、contains、endsWith、normalize、repeat、startsWith 等ES6支持的， 还包括 quote、toSource、trimLeft、trimRight 等非标准的。 charAt 定义：charAt() 方法返回字符串中指定位置的字符。语法：str.charAt(index) charCodeAt 定义：charCodeAt() 返回指定索引处字符的 Unicode 数值。 语法：str.charCodeAt(index) index 为一个从0至length-1的整数。如果不是一个数值，则默认为 0，如果小于0或者大于字符串长度，则返回 NaN。 Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样. concat 定义：concat() 方法将一个或多个字符串拼接在一起，组成新的字符串并返回。 语法：str.concat(string2, string3, …) 但是 concat 的性能表现不佳，强烈推荐使用赋值操作符（+或+=）代替 concat。”+” 操作符大概快了 concat 几十倍。 indexOf &amp;&amp; lastIndexOf 定义：indexOf() 方法用于查找子字符串在字符串中首次出现的位置，没有则返回 -1。 语法：str.indexOf(searchValue [, fromIndex=0])，str.lastIndexOf(searchValue [, fromIndex=0]) match 定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 描述： 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 相关 RegExp 方法 若需测试字符串是否匹配正则，请参考 RegExp.test(str)。 若只需第一个匹配结果，请参考 RegExp.exec(str)。 123456var str = "World Internet Conference";console.log(str.match(/[a-d]/i)); // ["d", index: 4, input: "World Internet Conference"]console.log(str.match(/[a-d]/gi)); // ["d", "C", "c"]// RegExp 方法如下console.log(/[a-d]/gi.test(str)); // trueconsole.log(/[a-d]/gi.exec(str)); // ["d", index: 4, input: "World Internet Conference"] search 定义：search() 方法用于测试字符串对象是否包含某个正则匹配，相当于正则表达式的 test 方法，且该方法比 match() 方法更快。如果匹配成功，search() 返回正则表达式在字符串中首次匹配项的索引，否则返回-1。 语法：str.search(regexp) 12var str = "abcdefg";console.log(str.search(/[d-g]/)); // 3, 匹配到子串"defg",而d在原字符串中的索引为3 search() 方法不支持全局匹配（正则中包含g参数），如下：1console.log(str.search(/[d-g]/g)); // 3, 与无g参数时,返回相同 slice 定义：slice() 方法提取字符串的一部分，并返回新的字符串。该方法有些类似 Array.prototype.slice 方法。 语法：str.slice(start, end) split 定义：split() 方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的 其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素 如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组 limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 eg:123456789var str = "today is a sunny day";console.log(str.split()); // ["today is a sunny day"]console.log(str.split("")); // ["t", "o", "d", "a", "y", " ", "i", "s", " ", "a", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y"]console.log(str.split(" ")); // ["today", "is", "a", "sunny", "day"]console.log(str.split(/\s*is\s*/)); // ["today", "a sunny day"]console.log(str.split(/(\s*is\s*)/)); // ["today", " is ", "a sunny day"] substr 定义：substr() 方法返回字符串指定位置开始的指定数量的字符。 语法：str.substr(start[, length]) 参数： start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。 length 表示截取的字符长度。 eg:123var str = "Yesterday is history. Tomorrow is mystery. But today is a gift.";console.log(str.substr(47)); // today is a gift.console.log(str.substr(-16)); // today is a gift. substring 定义：substring() 方法返回字符串两个索引之间的子串。 语法：str.substring(indexA[, indexB]) indexA、indexB 表示字符串索引，其中 indexB 可选，如果省略，则表示返回从 indexA 到字符串末尾的子串。 描述: substring 要截取的是从 indexA 到 indexB（不包含）之间的字符，符合以下规律： 若 indexA == indexB，则返回一个空字符串； 若 省略 indexB，则提取字符一直到字符串末尾； 若 任一参数小于 0 或 NaN，则被当作 0； 若 任一参数大于 length，则被当作 length。 而 如果 indexA &gt; indexB，则 substring 的执行效果就像是两个参数调换一般。比如：str.substring(0, 1) == str.substring(1, 0)eg:123456var str = "Get outside every day. Miracles are waiting everywhere.";console.log(str.substring(1,1)); // ""console.log(str.substring(0)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(-1)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(0,100)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(22,NaN)); // Get outside every day. toLocaleLowerCase &amp; toLocaleUpperCase &amp; toLowerCase &amp; toUpperCase 定义：转换成大小写 语法：str.toLocaleLowerCase(), str.toLocaleUpperCase() toString &amp; valueOf 定义：这两个方法都是返回字符串本身。 语法：str.toString(), str.valueOf() trim 定义：trim() 方法清除字符串首尾的空白并返回。 语法：str.trim() includes(ES6) 定义：includes() 方法基于ECMAScript 2015（ES6）规范，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。 语法：str.includes(subString [, position]) eg:123var str = "Practice makes perfect.";console.log(str.includes("perfect")); // trueconsole.log(str.includes("perfect",100)); // false endsWith(ES6) 定义：endsWith() 方法基于ECMAScript 2015（ES6）规范，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。 语法：str.endsWith(substring [, position]) 与contains 方法不同，position 参数的默认值为字符串长度。123var str = "Learn and live.";console.log(str.endsWith("live.")); // trueconsole.log(str.endsWith("Learn",5)); // true normalize(ES6) 定义：normalize() 方法基于ECMAScript 2015（ES6）规范，它会按照指定的 Unicode 正规形式将原字符串正规化。 语法：str.normalize([form]) form 参数可省略，目前有四种 Unicode 正规形式，即 “NFC”、”NFD”、”NFKC” 以及 “NFKD”，form的默认值为 “NFC”。如果form 传入了非法的参数值，则会抛出 RangeError 错误。 123456var str = "\u4f60\u597d";console.log(str.normalize()); // 你好console.log(str.normalize("NFC")); // 你好console.log(str.normalize("NFD")); // 你好console.log(str.normalize("NFKC")); // 你好console.log(str.normalize("NFKD")); // 你好 repeat(ES6) 定义：repeat() 方法基于ECMAScript 2015（ES6）规范，它返回重复原字符串多次的新字符串。 语法：str.repeat(count) count 参数只能取大于等于0 的数字。若该数字不为整数，将自动转换为整数形式，若为负数或者其他值将报错。 12345var str = "A still tongue makes a wise head.";console.log(str.repeat(0)); // ""console.log(str.repeat(1)); // A still tongue makes a wise head.console.log(str.repeat(1.5)); // A still tongue makes a wise head.console.log(str.repeat(-1)); // RangeError:Invalid count value startsWith(ES6) 定义：startsWith() 方法基于ECMAScript 2015（ES6）规范，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false 语法：str.startsWith(subString [, position]) 与html相关的方法anchor &amp;&amp; link anchor 定义：anchor() 方法创建一个锚标签。 语法：str.anchor(name) 参数：name 指定被创建的a标签的name属性，使用该方法创建的锚点，将会成为 document.anchors 数组的元素。 123var str = "this is a anchor tag";document.body.innerHTML = document.body.innerHTML + str.anchor("anchor1"); // body末尾将会追加这些内容 &lt;a name="anchor1"&gt;this is a anchor tag&lt;/a&gt; link 定义：link() 方法同样创建一个a标签。 语法：str.link(url) 参数：url 指定被创建的a标签的href属性， 如果url中包含特殊字符，将自动进行编码。 例如 “ 会被转义为 &amp;\quot。 使用该方法创建的a标签，将会成为 document.links 数组中的元素。 123var str = "百度";document.write(str.link("https://www.baidu.com")); // &lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; 小结: 没错，这篇文章也是抄的，但是作者真的写得好啊！ 我想把他记录到我的博客里面，这样我想看的时候好找些。 加油！！！ 部分字符串方法之间存在很大的相似性，要注意区分他们的功能和使用场景。如： substr 和 substring，都是两个参数，作用基本相同，两者第一个参数含义相同，但用法不同，前者可为负数，后者值为负数或者非整数时将隐式转换为0。前者第二个参数表示截取字符串的长度，后者第二个参数表示截取字符串的下标；同时substring第一个参数大于第二个参数时，执行结果同位置调换后的结果。 search方法与indexOf方法作用基本一致，都是查询到了就返回子串第一次出现的下标，否则返回-1，唯一的区别就在于search默认会将子串转化为正则表达式形式，而indexOf不做此处理，也不能处理正则。 另外，还记得吗？concat方法由于效率问题，不推荐使用。 常用的方法就charAt、indexOf、lastIndexOf、match、replace、search、slice、split、substr、substring、toLowerCase、toUpperCase、trim、valueof 等这些。 参考JavaScript字符串所有API全解密]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之数组]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Array构造器12345678// 使用Array构造器var a = Array(8); // [undefined × 8]// 使用对象字面量var b = [];b.length = 8; // [undefined × 8]Array.of(8.0); // [8]Array(8); // [empty × 8] Array.of和Array的区别：很明显，当Array传入一个数字参数时，这个参数会作为数组的长度 Array.isArray我们至少有如下5种方式去判断一个值是否数组：1234567891011var a = [];// 1.基于instanceofa instanceof Array;// 2.基于constructora.constructor === Array;// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a);// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype;// 5.基于Object.prototype.toStringObject.prototype.toString.apply(a) === '[object Array]'; 还有Array.isArray():12Array.isArray([]); // trueArray.isArray(&#123;0: 'a', length: 1&#125;); // false 改变自身值的方法(9个)基于ES6，改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill。 pop pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。如果是栈的话，这个过程就是栈顶弹出。 push push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。如果是栈的话，这个过程就是栈顶压入语法：arr.push(element1, …, elementN) shift shift()方法删除数组的第一个元素，并返回这个元素。如果是栈的话，这个过程就是栈底弹出。语法：arr.shift() unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。语法：arr.unshift(element1, …, elementN) splice() 添加/删除数组元素 定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 语法： array.splice(index,howmany,item1,…..,itemX) reverse reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。语法：arr.reverse() ES6: copyWithin() 指定位置的成员复制到其他位置 定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。语法:1array.copyWithin(target, start = 0, end = this.length) 参数: 三个参数都是数值，如果不是，会自动转为数值. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。 eg:1234567// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]var a=['OB1','Koro1','OB2','Koro2','OB3','Koro3','OB4','Koro4','OB5','Koro5']// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换a.copyWithin(2,3,5)// ["OB1","Koro1","Koro2","OB3","OB3","Koro3","OB4","Koro4","OB5","Koro5"] ES6: fill() 填充数组 定义: 使用给定值，填充一个数组。语法： Array.fill( val, startp, endp )参数: 第一个元素(必须): 要填充数组的值 第二个元素(可选): 填充的开始位置,默认值为0 第三个元素(可选)：填充的结束位置，默认是为this.lengtheg:1234['a', 'b', 'c'].fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] sort sort()方法对数组元素进行排序，并返回这个数组。sort方法比较复杂，这里我将多花些篇幅来讲这块。语法：arr.sort([comparefn]) comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：12345678var array = ["apple","Boy","Cat","dog"];var array2 = array.sort();console.log(array); // ["Boy", "Cat", "apple", "dog"]console.log(array2 == array); // truearray = [10, 1, 3, 20];var array3 = array.sort();console.log(array3); // [1, 10, 20, 3] 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素： 若 comparefn(a, b) &lt; 0，那么a 将排到 b 前面； 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变； 若 comparefn(a, b) &gt; 0，那么a , b 将调换位置； 不改变原数组的方法(8个):ES5： slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、 ES7： includes slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。语法：array.slice(begin, end);参数： begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。 end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。语法： array.join(str) toLocaleString() 数组转字符串 定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。语法： array.toLocaleString()eg:12let a=[&#123;name:'OBKoro1'&#125;,23,'abcd',new Date()];let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 如上述栗子：调用数组的toLocaleString方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。 toString() 数组转字符串 不推荐 该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。 cancat 定义： 方法用于合并两个或多个数组，返回一个新数组。语法： var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) ES6扩展运算符…合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1语法: array.indexOf(searchElement,fromIndex) 参数:searchElement(必须):被查找的元素fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索:数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。indexOf()不能识别NaNeg:1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）与上面的indexOf相同 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值语法： array.includes(searchElement,fromIndex=0)参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 eg:12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组 遍历方法(12个):js中遍历数组并不会改变原始数组的方法总共有12个: ES5： forEach、every 、some、 filter、map、reduce、reduceRight、 ES6： find、findIndex、keys、values、entries forEach 定义: 按升序为数组中含有效值的每一项执行一次回调函数。 语法： array.forEach(function(currentValue, index, arr), thisValue) 参数: function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 关于forEach()你要知道： 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值。 需要注意： 1. 对于空数组是不会执行回调函数的 2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。 4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。 eg:12345678910111213let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)let obj = &#123; name: 'OBKoro1' &#125;;let result = a.forEach(function (value, index, array) &#123; a[3] = '改变元素'; a.push('添加到尾端，不会被遍历') console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log('不会执行，因为return 会执行下一次循环回调')&#125;, obj);console.log(result); // 即使return了一个值,也还是返回undefined// 回调函数也接受接头函数写法 every 检测数组所有元素是否都符合判断条件 定义: 方法用于检测数组所有元素是否都符合函数定义的条件 语法： array.every(function(currentValue, index, arr), thisValue) 方法返回值规则: 如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true。 some 数组中的是否有满足判断条件的元素 定义：数组中的是否有满足判断条件的元素 语法： array.some(function(currentValue, index, arr), thisValue) 方法返回值规则: 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false。 filter 过滤原始数组，返回新数组 定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。 语法： let new_array = arr.filter(function(currentValue, index, arr), thisArg)eg:12345let a = [32, 33, 16, 40];let result = a.filter(function (value, index, array) &#123; return value &gt;= 18; // 返回a数组中所有大于18的元素&#125;);console.log(result,a);// [32,33,40] [32,33,16,40] map 对数组中的每个元素进行处理，返回新的数组 定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法： let new_array = arr.map(function(currentValue, index, arr), thisArg) reduce 为数组提供累加器，合并为一个值 定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。 语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 参数： function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. total(必须)，初始值, 或者上一次调用回调返回的值 2. currentValue(必须),数组当前元素的值 3. index(可选), 当前元素的索引值 4. arr(可选),数组对象本身 回调第一次执行时: 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值； 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。 reduceRight 从右至左累加 这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。 ES6：find()&amp; findIndex() 根据条件找到数组成员 find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。 findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 语法： let new_array = arr.find(function(currentValue, index, arr), thisArg) let new_array = arr.findIndex(function(currentValue, index, arr), thisArg) ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值 定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。 语法： array.keys() array.values() array.entries() 添加两个没有的api Array.prototype.flat() Array.prototype.flatMap() Array.prototype.flat() 定义：flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 语法：var newArray = arr.flat(depth) 参数：depth （可选）指定要提取嵌套数组的结构深度，默认值为 1。 返回一个新数组 扁平化嵌套数组: eg:123456789101112131415var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]//使用 Infinity 作为深度，展开任意深度的嵌套数组arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6] 扁平化与空项 flat() 方法会移除数组中的空项: 123var arr4 = [1, 2, , 4, 5];arr4.flat();// [1, 2, 4, 5] Array.prototype.flatMap() 定义：flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 语法：var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素 return }[, thisArg]) 参数： currentValue –（必选）– 当前正在数组中处理的元素 index –（可选）– 数组中正在处理的当前元素的索引 array –（可选）– 当前数组 eg:1234567let arr = ["今天天气不错", "", "早上好"]arr.map(s =&gt; s.split(""))// [["今", "天", "天", "气", "不", "错"],[""],["早", "上", "好"]]arr.flatMap(s =&gt; s.split(''));// ["今", "天", "天", "气", "不", "错", "", "早", "上", "好"] 结语很早就看完并按照例子做一遍了，一直想写篇文章记录下，今天终于写了， 希望自己继续加油！！！ 参考资料 【干货】js 数组详细操作方法及解析合集 注：这篇文章就是参考的上面这篇文章，哈哈哈，真的觉得作者写得好，通过这篇文章也让我总结了js数组相关的知识 作者的github 作者的博客 本篇文章 MDN–Array–Api]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electorn初探]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F16%2Felectorn%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>桌面应用</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Next主题]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F14%2F%E9%85%8D%E7%BD%AENext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录一下配置过程配置背景图片修改文件：themes\next\source\css_custom\custom.styl，增加下面的代码： body{ background:url(http://curtaintan.club/hexo-bg.jpg); background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%; } // 修改主体透明度 .main-inner { background: #fff; opacity: 0.8; } // 修改菜单栏透明度 .header-inner { opacity: 0.8; } 修改背景动画粒子颜色修改文件：next\layout_scripts\vendors.swig，搜索找到：canvas_nest修改为： {% if theme.canvas_nest %} {% endif %} 修改后为： 设置加载本地图片 打开_config.yml文件，修改下述内容 post_asset_folder: true 安装插件： npm install hexo-asset-image –save 对插件进行修改： 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123;var config = hexo.config;if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125;&#125;&#125;); 注意： 如果你的主目录的_config.yml内的URL配置如下配置： 请修改为下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, &quot;/&quot; + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+ link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 其他详情请参考：最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 谢谢，文章写得不好---请见谅]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter配置web]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F13%2Fflutter%E9%85%8D%E7%BD%AEweb%2F</url>
    <content type="text"><![CDATA[flutter配置web今天配置了web端，记一下配置过程，配置还是蛮复杂的 第一步：下载web包 下载整个项目到本地， 运行：flutter pub global activate webdev 此时会提示：将.pub-cache/bin加入电脑的环境变量，他会把完整的路径给你，如果没有，你可以去自己flutterSDK的安装目录下找到，如下图： 找到一篇文章，看这篇文章吧—-点击跳转 写后感：写文章，还是要脑子的，但是我没有----]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fhexo-blog%2F2019%2F04%2F26%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一篇文章记录下，嘻嘻三级标题 列表一 列表二 a 子列表a b 子列表2 c 子列表3 列表三 链接测试-优秀博客 下面是关于字体斜体字字体加粗代码块引用&lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 这里是引用 hexo clean &amp;&amp; hexo ghexo s]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
