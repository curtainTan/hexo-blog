<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全面学习之Object]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0%E4%B9%8BObject%2F</url>
    <content type="text"><![CDATA[Object 静态方法总结 create 创建一个对象12345678910111213141516171819202122232425262728const obj = Object.create(&#123;a:1&#125;, &#123;b: &#123;value: 2&#125;&#125;)// 第一个参数为对象，对象为函数调用之后返回新对象的原型对象，// 第二个参数为对象本身的实例方法（默认不能修改,不能枚举）obj.__proto__.a === 1 // true obj.b = 3;console.log(obj.b) // 2//创建一个可写的,可枚举的,可配置的属性pobj2 = Object.create(&#123;&#125;, &#123;p: &#123; value: 2, // 属性值 writable: true, // 是否可以重写值 enumerable: true, //是否可枚举 configurable: true //是否可以修改以上几项配置&#125;&#125;);obj2.p = 3;console.log(obj2.p) // 3注意： enumerable 会影响以下for…in 遍历包括对象原型上属性Object.keys() 只能遍历自身属性JSON.stringify 只能序列化自身属性 defineProperty 定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法：Object.defineProperty(obj, prop, descriptor) 123456789101112131415161718192021222324252627282930313233343536 添加数据属性`` var obj = &#123;&#125;; // 1.添加一个数据属性 Object.defineProperty(obj, "newDataProperty", &#123; value: 101, writable: true, enumerable: true, configurable: true &#125;); obj.newDataProperty // 101 // 2.修改数据属性 Object.defineProperty(obj, "newDataProperty", &#123; writable:false &#125;); //添加访问器属性 var obj = &#123;&#125;; Object.defineProperty(obj, "newAccessorProperty", &#123; set: function (x) &#123; this.otherProperty = x; &#125;, get: function () &#123; return this.otherProperty; &#125;, enumerable: true, configurable: true &#125;);注意： 1.第一个参数必须为对象 2.descriptor 不能同时具有 （value 或 writable 特性）（get 或 set 特性）。 3.configurable 为false 时，不``能重新修改装饰器 defineProperties 定义：定义多个属性 语法：Object.defineProperties(object, {prop1 : descriptor1, prop2 : descriptor2, …) 123456789101112var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125; // etc. etc.&#125;); keys() 定义： 遍历可枚举的属性，只包含对象本身可枚举属性，不包含原型链可枚举属性 1234567let arr = ["a", "b", "c"];let obj = &#123; foo: "bar", baz: 42 &#125;;let ArrayLike = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;Object.keys(arr) // ['0', '1', '2']Object.keys(obj) // ["foo","baz"]Object.keys(ArrayLike) // ['0', '1', '2'] values() 定义：遍历可枚举的属性值，只包含对象本身可枚举属性值，不包含原型链可枚举属性值 1234567let arr = ["a", "b", "c"];let obj = &#123; foo: "bar", baz: 42 &#125;;let ArrayLike = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;Object.values(arr) // ["a", "b", "c"]Object.values(obj) // ["bar",42]Object.values(ArrayLike) // ["a", "b", "c"] assign 定义：Object.assign( target, source, source1 ) 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false） 语法：Object.assign(target, …sources) 参数： 参数 说明 target 目标对象。 sources 源对象。 返回值 目标对象。 12345678910111213const o1 = &#123; a: 1, b: 1, c: 1 &#125;;const o2 = &#123; b: 2, c: 2 &#125;;const o3 = &#123; c: 3 &#125;;const obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;特殊情况：let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // trueObject.assign([1, 2, 3], [4, 5]) // [4, 5, 3] 说明：Object.assign方法实行的是浅拷贝，而不是深拷贝。 1234567const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;console.log(obj2.a.b) //2obj2.a.b = 3console.log(obj1.a.b) //3 getPrototypeOf() 说明：获取指定对象的原型（内部[[Prototype]]属性的值） 1234567const prototype1 = &#123;&#125;;const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1); // true注意：Object.getPrototypeOf(Object) 不是 Object.prototype Object.getPrototypeOf( Object ) === Function.prototype; // true setPrototypeOf 说明：设置一个指定的对象的原型 12345const obj = &#123;a: 1&#125;, proto = &#123;b:2&#125;Object.setPrototypeOf(obj, proto)obj.__proto__ === proto //true getOwnPropertyNames 说明：与keys相似，但包含遍历，包含不可枚举属性, 返回属性数组 12345678910var my_obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function() &#123; return this.foo; &#125;, enumerable: false &#125;&#125;);my_obj.foo = 1;Object.getOwnPropertyNames(my_obj).sort() // ["foo", "getFoo"] getOwnPropertyDescriptor() 说明：获取该属性的描述对象， 返回说明对象 语法：Object.getOwnPropertyDescriptor(obj, prop) 123456789101112131415161718192021222324252627282930313233var o, d;o = &#123; get foo() &#123; return 17; &#125; &#125;;d = Object.getOwnPropertyDescriptor(o, "foo");// d &#123;// configurable: true,// enumerable: true,// get: /*the getter function*/,// set: undefined// &#125;o = &#123; bar: 42 &#125;;d = Object.getOwnPropertyDescriptor(o, "bar");// d &#123;// configurable: true,// enumerable: true,// value: 42,// writable: true// &#125;o = &#123;&#125;;Object.defineProperty(o, "baz", &#123; value: 8675309, writable: false, enumerable: false&#125;);d = Object.getOwnPropertyDescriptor(o, "baz");// d &#123;// value: 8675309,// writable: false,// enumerable: false,// configurable: false// &#125; getOwnPropertyDescriptors 说明：返回指定对象所有自身属性（非继承属性）的描述对象 123456789101112131415161718192021222324252627282930const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;; console.dir(Object.getOwnPropertyDescriptors(obj))// &#123; foo:&#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:&#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; // &#125;使用场景：Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型Object.create() 方法可以实现上面说的这些，配合getPrototypeOf，以及getOwnPropertyDescriptors实现全面浅拷贝Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); entries 说明：分割对象 方法返回一个给定对象自身可枚举属性的键值对数组， 其排列与使用 for...in 循环遍历该对象时返回的顺序一致（ 区别在于 for-in 循环也枚举原型链中的属性）。 1234567891011const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// array like objectconst obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]// stringObject.entries('abc') // [['0', 'a'], ['1', 'b'], ['2', 'c']]Object.entries(100) // [] is 说明：它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 12345678910Object.is('foo', 'foo') // trueObject.is(&#123;&#125;, &#123;&#125;) // false不同于 === 之处+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true preventExtensions 说明：让一个对象变的不可扩展，也就是永远不能再添加新的属性&amp;isExtensible 判断一个对象是否可扩展 1234567891011121314151617181920let empty = &#123;&#125;Object.isExtensible(empty) //trueempty.a = 1 //添加成功//将对象变为不可拓展Object.preventExtensions(empty)Object.isExtensible(empty) //falseempty.b = 2 //静默失败,不抛出错误empty.a = 5 //修改a属性值为5 修改成功总结： 1.preventExtensions 可以让这个对象变的不可扩展，也就是不能再有新的属性。 2.需要注意的是不可扩展的对象的属性通常仍然可以被删除。 3.尝试给一个不可扩展对象添加新属性的操作将会失败，不过可能是静默失败， 也可能会抛出 TypeError 异常（严格模式）。 4.Object.preventExtensions 只能阻止一个对象不能再添加新的自身属性， 仍然可以为该对象的原型添加属性。 seal &amp;&amp; isSealed 说明： seal()将一个对象密封 isSealed 判断一个对象是否为密封的 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。 isSealed 判断一个对象是否为密封的 1234567891011121314151617181920212223242526272829303132333435363738394041密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。1. 先讲seal 方法：var o2 = &#123;b: 1&#125;o2.d = 2 //添加成功var obj2 = Object.seal(o2);obj2 === o2 //true 方法返回原对象，栈指针指向同一块内存Object.isSealed(o2) // trueo2.b = 111 //修改b属性值成功o2.f = 222 //静默失败,属性f没有成功添加delete o2.b //静默失败,属性b没有成功删除2. 讲isSealed 方法：let o = &#123;&#125;;Object.isSealed(o) //false// 之后通过Object.preventExtensions方法将空对象设置为不可扩展。Object.preventExtensions(o);Object.isSealed(o) // true但是如果为非空对象呢？let o2 = &#123;a: 1&#125;Object.preventExtensions(o2);Object.isSealed(o2) // false因为属性 a 是可配置的（configurable为true），所以不是密封的对象，修改方法如下：let o2 = &#123;a: 1&#125;Object.preventExtensions(o2);Object.defineProperty(o2, "a", &#123; configurable: false &#125;);Object.isSealed(o2) //true总结： 1.密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。 2.属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。 3.但属性的值仍然可以修改。 4.尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常（严格模式）。 freeze &amp;&amp; isFrozen说明： freeze()冻结一个对象 isFrozen()判断一个对象是否已经被冻结 一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性， 不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性， 以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591.先讲freeze 方法：let o3 = &#123;a: 1&#125;o3.b = 2 //添加属性b成功Object.freeze(o3)Object.isFrozen(o3) //true 对象已被冻结o3.a = 2 //修改属性a值失败o3.c = 5 //添加属性c失败delete o3.b //删除属性b失败2.再讲isfrozen 方法：let o4 = &#123;a: 1&#125;o4.b = 2 // 添加属性b成功Object.priventExtensions(o4)Object.defineProperties(o4, &#123; a: &#123;configurable: false, writable: false&#125;, b: &#123;configurable: false, writable: false&#125;&#125;)Object.isFrozen(o4) //true o4 已经被冻结总结： 1.冻结对象的所有自身属性都不可能以任何方式被修改。 2.任何尝试修改该对象的操作都会失败，可能是静默失败，也可能会抛出异常（严格模式中）。 3.数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。 4.如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。 浅冻结与深冻结：(function () &#123; obj = &#123; internal :&#123;&#125; &#125;; Object.freeze(obj);//浅冻结 obj.internal.a = "aValue"; console.log(obj.internal.a);//"aValue" //想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数. function deepFreeze(o)&#123; var prop,propKey; Object.freeze(o);//首先冻结第一层对象 for(propKey in o)&#123; prop = o[propKey]; if(!o.hasOwnProperty(propKey) || !(typeof prop === "object") || Object.isFrozen(prop))&#123; continue; &#125; deepFreeze(prop);//递归 &#125; &#125; deepFreeze(obj); obj.internal.b = "bValue";//静默失败 console.log(obj.internal.b);//undefined&#125;)(); hasOwnProperty() 12345678910111213141516171819202122方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性let o = &#123;a: 1 &#125;o.hasOwnProperty('a') //trueo.hasOwnProperty('b') //false 对象自身没有属性bo.hasOwnProperty('toString'); //false 不能检测对象原型链上的属性如何遍历一个对象的所有自身属性，例子：var buz = &#123; fog: 'stack'&#125;;for (var name in buz) &#123; if (buz.hasOwnProperty(name)) &#123; console.log("this is fog (" + name + ") for sure. Value: " + buz[name]); &#125; else &#123; console.log(name); // toString or something else &#125;&#125; isPrototypeOf() 123456789101112131415isPrototypeOf方法用于测试一个对象是否存在于另一个对象的原型链上function Foo() &#123;&#125;function Bar() &#123;&#125;function Baz() &#123;&#125;Bar.prototype = Object.create(Foo.prototype);Baz.prototype = Object.create(Bar.prototype);var baz = new Baz();console.log(Baz.prototype.isPrototypeOf(baz)); // trueconsole.log(Bar.prototype.isPrototypeOf(baz)); // trueconsole.log(Foo.prototype.isPrototypeOf(baz)); // trueconsole.log(Object.prototype.isPrototypeOf(baz)); // true propertyIsEnumerable 说明：指定的属性是否可枚举 12345678910111213141516171819202122232425262728293031323334obj.propertyIsEnumerable(prop) prop为被测试的属性名1. 一般情况下var o = &#123;&#125;;var a = [];o.prop = 'is enumerable';a[0] = 'is enumerable';o.propertyIsEnumerable('prop'); // 返回 truea.propertyIsEnumerable(0); // 返回 true2. 浏览器内置对象var a = ['is enumerable'];a.propertyIsEnumerable(0); // 返回 truea.propertyIsEnumerable('length'); // 返回 falseMath.propertyIsEnumerable('random'); // 返回 falsethis.propertyIsEnumerable('Math'); // 返回 false3. 自身属性和继承属性（原型链上propertyIsEnumerable不被考虑）var fn = function()&#123; this.prop = '123';&#125;fn.prototype = &#123; prototypeProp: true&#125;var o = new fn()o.propertyIsEnumerable('prop') // trueo.propertyIsEnumerable('prototypeProp') // false caller 说明：返回当前函数的调用者 12345678910111213141516171819202122function test()&#123; if(test.caller == null)&#123; alert("JavaScript顶层作用域调用了test()函数"); &#125;else&#123; alert( test.caller + "函数调用了test()函数"); &#125;&#125;;test(); // JavaScript顶层作用域调用了test()函数function callTest()&#123; test();&#125;callTest(); // function callTest()&#123; test(); &#125;函数调用了test()函数function callTest2()&#123; // setTimeout()或setInterval()中定时执行的函数也属于顶层作用域调用 setTimeout(test, 5000); // JavaScript顶层作用域调用了test()函数&#125;callTest2(); valueOf() 说明：需要返回对象的原始值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162备注：js对象中的valueOf()方法和toString()方法非常类似，但是，当需要返回对象的原始值而非字符串的时候才调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用valueOf()方法。const o = &#123;a: 1, valueOf: function()&#123; return 123123 &#125; &#125;Number(o) //123123// 给大家出一个题const o2 = &#123; x: 1, valueOf: function()&#123; return this.x++ &#125;&#125;if(o2 == 1 &amp;&amp; o2 == 2 &amp;&amp; o2 == 3)&#123; console.log('down') console.log(o2.x)&#125;else&#123; console.log('faild')&#125;// Array：返回数组对象本身var array = ["CodePlayer", true, 12, -5];array.valueOf() === array; // true// Date：当前时间距1970年1月1日午夜的毫秒数var date = new Date(2013, 7, 18, 23, 11, 59, 230);date.valueOf() // 1376838719230// Number：返回数字值var num = 15.26540;num.valueOf() // 15.2654// 布尔：返回布尔值true或falsevar bool = true;bool.valueOf() === bool // true// new一个Boolean对象var newBool = new Boolean(true);// valueOf()返回的是true，两者的值相等newBool.valueOf() == newBool // true// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型newBool.valueOf() === newBool // false// Function：返回函数本身function foo()&#123; &#125;foo.valueOf() === foo // truevar foo2 = new Function("x", "y", "return x + y;");foo2.valueOf() === foo2 // true// Object：返回对象本身var obj = &#123;name: "张三", age: 18&#125;;obj.valueOf() === obj // true// String：返回字符串值var str = "http://www.365mini.com";str.valueOf() === str // true// new一个字符串对象var str2 = new String("http://www.365mini.com");// 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型str2.valueOf() === str2 // false getOwnPropertySymbols 说明：在给定对象自身上找到的所有 Symbol 属性的数组。 123456789101112var obj = &#123;&#125;;var a = Symbol("a");var b = Symbol.for("b");obj[a] = "localSymbol";obj[b] = "globalSymbol";var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols.length); // 2console.log(objectSymbols) // [Symbol(a), Symbol(b)]console.log(objectSymbols[0]) // Symbol(a) toString &amp;&amp; toLocalString 12345678910111213toString 方法不做过多介绍区别：当被转化的值是个时间对象时，toLocaleString会将转化的结果以本地表示。(new Date).toString(); //"Mon Nov 06 2017 13:02:46 GMT+0800 (China Standard Time)"(new Date).toLocaleString(); //"2017/11/6 下午1:03:12"另外当被转化的值是个时间戳时，toLocaleString会把时间戳每三位添加一个逗号，代码如下。(Date.parse(new Date())).toLocaleString() //"1,509,944,637,000"(Date.parse(new Date())).toString() //"1509944643000" length &amp;&amp; name12Object.length //1Object.name //"Object" 总结：又是一片好文章，每个api的案例都很好。 参考资料js Object方法大全（自己整理） MDN–Object文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历方法总结]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2Fjs%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言学习一门语言，遍历是少不了的！！ gogogo,开始吧 标准操作 for循环 就是正常的for循环， 123456789var arr = ['element1', 'element2', 'element3'];for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(arr[i]);&#125;// element1// element2// element3 数组自带方法forEach 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值 123456789var arr = ['element1', 'element2', 'element3'];arr.forEach(function(value, index, arr) &#123; console.log(value);&#125;);// element1// element2// element3 说明：比较遗憾的是以上的代码未能按照我们的预期运行（break、continue等语句跨越了函数边界），所以这个看似完美的办法实际上只能一条道走到黑，像吃了炫迈一样根本停不下来。当数组很大，没办法通过提前终止遍历来节省资源。 for in循环 很强大！！1234567var arr = ['element1', 'element2', 'element3'];for (var i in arr) &#123; console.log(arr[i]);&#125;// element1// element2// element3 for in语句是一种精准的迭代语句，可以枚举对象的所有可枚举属性(可以使用Object.getOwnPropertyDescriptor(targetObj, attrName)方法来查看对象的某个属性是否可枚举)。It means that，可以用它来遍历对象： 12345678910111213var obj = &#123; a: 1, b: 1, c: 1&#125;;for (let attr in obj) &#123; console.log(attr, obj[attr]);&#125;// a 1// b 1// c 1 除了遍历对象、数组之外，for in循环还可兼职遍历字符串：1234567var str = 'I am a handsome boy!';for (var i in str) &#123; console.log(str[i]);&#125;// 太帅(chang)了，结果就不打印了 当然，也支持break、continue的操作，例子我就不写了。 缺点：123456789101112131415161718192021222324var father = &#123; fatherAttr: 1&#125;;// 以father为原型创建对象实例instancevar instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;for (var attr in instance) &#123; console.log(attr, instance[attr]);&#125;// a 1// b 1// c 1// fatherAttr 1// 获取instance实例的自有属性名console.log(Object.getOwnPropertyNames(instance));// ["a", "b", "c"] 上面这个例子中，首先以father对象为原型创建了一个对象实例instance，然后为这个实例instance添加了a、b、c三个属性，接着使用for in循环遍历这个对象。通过查看instance的自有属性可以发现，fatherAttr并不是instance的属性，而是其原型father的属性，for in循环会将对象的原型属性也一并列举出来。故使用此方法去遍历对象属性的时候，需要加多一层判断： 12345for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; // 是对象的自有属性，可以尽情的玩耍了 &#125;&#125; for of循环 通过for in循环可以解决传统for循环需要维护边界的问题，但也引入了一些新问题，跟搬砖工作者的日常操作“解决3个bug，引入8个新bug”场景极度相似。 所以换个es6定义的for of循环操作试试：12345678910111213let str = 'a 𠮷 c';for (let char of str) &#123; if (char === ' ') &#123; continue; &#125; else &#123; console.log(char); &#125;&#125;// a// 𠮷// c 从上面的例子来看，效果简直是perfect：索引去掉了，边界去掉了，想继续就继续，想退出就退出，还能顺便解决一下字符串的编码问题。 缺点： 运行环境为ES6及以上版本，所以兼容性没有for in循环以及传统的操作好，如果需要考虑兼容上世纪的浏览器，就不能使用这个东西 只能用于遍历可迭代对象，即存在生成器方法（用于产生迭代器）的对象，如果用于遍历不可迭代对象，分分钟报错没商量。可以通过检测对象的Symbol.iterator方法（相关内容将放在下一篇）是否为函数来判断对象是否可迭代。 实际上，大多数JavaScript的内置对象都支持迭代，例如：Array、Set、Map、String等，当使用for of循环遍历上述对象时，就会使用其默认的生成器生成的迭代器： 123456789101112131415161718192021let map = new Map([['a', 1], ['b', 1], ['c', 1], ['d', 1]]);// 正经操作for (let item of map) &#123; console.log(item);&#125;// ["a", 1]// ["b", 1]// ["c", 1]// ["d", 1]// 使用解构，方便读取值for (let [key, value] of map) &#123; console.log(key, value);&#125;// a 1// b 1// c 1// d 1 上面的例子使用了for of遍历了Map类型实例map，迭代对象为Map类型的默认生成器生成的迭代器。当然，像Array、Set、Map类型还提供了一些特殊的生成器，可以让搬砖工作者更方便的去处理其想关注的内容： entries() 返回一个迭代器，其返回值为键值对数组（Map集合的默认迭代器；对于Set集合，返回值数组的元素相同，即value） keys() 返回一个迭代器，其返回值为集合的键名（对于Set集合，此迭代器跟values迭代器返回值相同;对于数组，此迭代器返回值为索引） values() 返回一个迭代器，其返回值为集合的值（Array、Set集合的默认迭代器） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let arr = ['a', 'b', 'c', 'd']let set = new Set(arr);for (let item of set.entries()) &#123; console.log(item);&#125;for (let item of arr.entries()) &#123; console.log(item);&#125;// ["a", "a"]// ["b", "b"]// ["c", "c"]// ["d", "d"]// [0, "a"]// [1, "b"]// [2, "c"]// [3, "d"]for (let item of set.keys()) &#123; console.log(item);&#125;for (let item of arr.keys()) &#123; console.log(item);&#125;// a// b// c// d// 0// 1// 2// 3for (let item of set.values()) &#123; console.log(item);&#125;for (let item of arr.values()) &#123; console.log(item);&#125;// a// b// c// d// a// b// c// d 除了JavaScript的内置对象，一些DOM标准的类型如NodeList也可以使用for of循环进行遍历： 12345let containers = document.querySelectorAll('.container');for (let node of containers) &#123; // 搞事情专用注释&#125; 很遗憾的是，for of循环居然不支持自定义对象的遍历（心中一万匹***奔腾而过……），所以如果不想使用for in循环遍历对象，只能转个弯了。 遍历对象的转弯操作 Object.keys()获取键名数组 使用Object.keys()可以获取到对象实例的所有可枚举属性，其返回值为一个数组，数组元素为对象的键名： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;// 以father为原型创建对象实例instancelet instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.keys(instance)) &#123; console.log(key);&#125;// a// b// c 不了解Object.defineProperty，可以参考: 深入浅出Object.defineProperty(),文章写得同属易懂，每个api都有案例。 Object.defineProperty( obj, prop, desc ) desc主要有四个 属性（value,writable, enumerable, configurable） Object.getOwnPropertyNames()获取键名数组 此方法跟keys方法表现一样，所不同的是，其返回的数组包含了对象的不可枚举属性： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.getOwnPropertyNames(instance)) &#123; console.log(key);&#125;// a// b// c// d Object.entries()获取键值对数组 这个方法返回什么东西就无需多言了吧，看例子： 123456789101112131415161718192021222324let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.entries(instance)) &#123; console.log(key);&#125;// ["a", 1]// ["b", 1]// ["c", 1] Object.values()获取对象的属性值数组 获取对象的值。 Object.getOwnPropertySymbols()获取Symbol属性名上面提到的几个方法都无法获取到对象实例的Symbol类型的属性名，如果需要遍历这个玩意，需要使用Object.getOwnPropertySymbols()方法： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;instance[Symbol('I am a handsome boy!')] = 1;for (let key of Object.keys(instance)) &#123; console.log(key);&#125;// a// b// cfor (let key of Object.getOwnPropertySymbols(instance)) &#123; console.log(key);&#125;// Symbol(I am a handsome boy!) 结语ok！这篇文章也是抄的: avaScript骚操作之遍历、枚举与迭代（上篇） 觉得总结的蛮好的。 当然，还有部分遍历是数组特有的方法。 比如：map，reduce， filter, every, some等，都可以遍历数组 好了，文章写完了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之字符串]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[String构造器方法 raw(ES6)定义：raw() 方法基于ECMAScript 2015（ES6）规范，它是一个模板字符串的标签函数，防止转义 如下是python的字符串前缀r： 1234# 防止特殊字符串被转义print r'a\nb\tc' # 打印出来依然是 "a\nb\tc"# python中常用于正则表达式regExp = r'(?&lt;=123)[a-z]+' 如下是String.raw作为前缀的用法： 1234567// 防止特殊字符串被转义String.raw`a\nb\tc`; // 输出为 "a\nb\tc"// 支持内插表达式let name = "louis";String.raw`Hello \n $&#123;name&#125;`; // "Hello \n louis"// 内插表达式还可以运算String.raw`1+2=$&#123;1+2&#125;,2*3=$&#123;2*3&#125;`; // "1+2=3,2*3=6" String.raw作为函数来调用的场景不太多，如下是用法： 1234// 对象的raw属性值为字符串时，从第二个参数起，它们分别被插入到下标为0，1，2，...n的元素后面String.raw(&#123;raw: 'abcd'&#125;, 1, 2, 3); // "a1b2c3d"// 对象的raw属性值为数组时，从第二个参数起，它们分别被插入到数组下标为0，1，2，...n的元素后面String.raw(&#123;raw: ['a', 'b', 'c', 'd']&#125;, 1, 2, 3); // "a1b2c3d" String.prototype和其他所有对象一样，字符串实例的所有方法均来自String.prototype。以下是它的属性特性： 值 属性 writable false enumerable false configurable false 可见，字符串属性不可编辑，任何试图改变它属性的行为都将抛出错误 与html无关的字符串方法常用的方法有： charAt、charCodeAt、concat、indexOf、lastIndexOf、localeCompare match、replace、search、slice、split、substr substring、toLocaleLowerCase、toLocaleUpperCase、toLowerCase、toString、toUpperCase trim、valueof 等ES5支持的， 以及 codePointAt、contains、endsWith、normalize、repeat、startsWith 等ES6支持的， 还包括 quote、toSource、trimLeft、trimRight 等非标准的。 charAt 定义：charAt() 方法返回字符串中指定位置的字符。语法：str.charAt(index) charCodeAt 定义：charCodeAt() 返回指定索引处字符的 Unicode 数值。 语法：str.charCodeAt(index) index 为一个从0至length-1的整数。如果不是一个数值，则默认为 0，如果小于0或者大于字符串长度，则返回 NaN。 Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样. concat 定义：concat() 方法将一个或多个字符串拼接在一起，组成新的字符串并返回。 语法：str.concat(string2, string3, …) 但是 concat 的性能表现不佳，强烈推荐使用赋值操作符（+或+=）代替 concat。”+” 操作符大概快了 concat 几十倍。 indexOf &amp;&amp; lastIndexOf 定义：indexOf() 方法用于查找子字符串在字符串中首次出现的位置，没有则返回 -1。 语法：str.indexOf(searchValue [, fromIndex=0])，str.lastIndexOf(searchValue [, fromIndex=0]) match 定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 描述： 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 相关 RegExp 方法 若需测试字符串是否匹配正则，请参考 RegExp.test(str)。 若只需第一个匹配结果，请参考 RegExp.exec(str)。 123456var str = "World Internet Conference";console.log(str.match(/[a-d]/i)); // ["d", index: 4, input: "World Internet Conference"]console.log(str.match(/[a-d]/gi)); // ["d", "C", "c"]// RegExp 方法如下console.log(/[a-d]/gi.test(str)); // trueconsole.log(/[a-d]/gi.exec(str)); // ["d", index: 4, input: "World Internet Conference"] search 定义：search() 方法用于测试字符串对象是否包含某个正则匹配，相当于正则表达式的 test 方法，且该方法比 match() 方法更快。如果匹配成功，search() 返回正则表达式在字符串中首次匹配项的索引，否则返回-1。 语法：str.search(regexp) 12var str = "abcdefg";console.log(str.search(/[d-g]/)); // 3, 匹配到子串"defg",而d在原字符串中的索引为3 search() 方法不支持全局匹配（正则中包含g参数），如下：1console.log(str.search(/[d-g]/g)); // 3, 与无g参数时,返回相同 slice 定义：slice() 方法提取字符串的一部分，并返回新的字符串。该方法有些类似 Array.prototype.slice 方法。 语法：str.slice(start, end) split 定义：split() 方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的 其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素 如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组 limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 eg:123456789var str = "today is a sunny day";console.log(str.split()); // ["today is a sunny day"]console.log(str.split("")); // ["t", "o", "d", "a", "y", " ", "i", "s", " ", "a", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y"]console.log(str.split(" ")); // ["today", "is", "a", "sunny", "day"]console.log(str.split(/\s*is\s*/)); // ["today", "a sunny day"]console.log(str.split(/(\s*is\s*)/)); // ["today", " is ", "a sunny day"] substr 定义：substr() 方法返回字符串指定位置开始的指定数量的字符。 语法：str.substr(start[, length]) 参数： start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。 length 表示截取的字符长度。 eg:123var str = "Yesterday is history. Tomorrow is mystery. But today is a gift.";console.log(str.substr(47)); // today is a gift.console.log(str.substr(-16)); // today is a gift. substring 定义：substring() 方法返回字符串两个索引之间的子串。 语法：str.substring(indexA[, indexB]) indexA、indexB 表示字符串索引，其中 indexB 可选，如果省略，则表示返回从 indexA 到字符串末尾的子串。 描述: substring 要截取的是从 indexA 到 indexB（不包含）之间的字符，符合以下规律： 若 indexA == indexB，则返回一个空字符串； 若 省略 indexB，则提取字符一直到字符串末尾； 若 任一参数小于 0 或 NaN，则被当作 0； 若 任一参数大于 length，则被当作 length。 而 如果 indexA &gt; indexB，则 substring 的执行效果就像是两个参数调换一般。比如：str.substring(0, 1) == str.substring(1, 0)eg:123456var str = "Get outside every day. Miracles are waiting everywhere.";console.log(str.substring(1,1)); // ""console.log(str.substring(0)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(-1)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(0,100)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(22,NaN)); // Get outside every day. toLocaleLowerCase &amp; toLocaleUpperCase &amp; toLowerCase &amp; toUpperCase 定义：转换成大小写 语法：str.toLocaleLowerCase(), str.toLocaleUpperCase() toString &amp; valueOf 定义：这两个方法都是返回字符串本身。 语法：str.toString(), str.valueOf() trim 定义：trim() 方法清除字符串首尾的空白并返回。 语法：str.trim() includes(ES6) 定义：includes() 方法基于ECMAScript 2015（ES6）规范，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。 语法：str.includes(subString [, position]) eg:123var str = "Practice makes perfect.";console.log(str.includes("perfect")); // trueconsole.log(str.includes("perfect",100)); // false endsWith(ES6) 定义：endsWith() 方法基于ECMAScript 2015（ES6）规范，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。 语法：str.endsWith(substring [, position]) 与contains 方法不同，position 参数的默认值为字符串长度。123var str = "Learn and live.";console.log(str.endsWith("live.")); // trueconsole.log(str.endsWith("Learn",5)); // true normalize(ES6) 定义：normalize() 方法基于ECMAScript 2015（ES6）规范，它会按照指定的 Unicode 正规形式将原字符串正规化。 语法：str.normalize([form]) form 参数可省略，目前有四种 Unicode 正规形式，即 “NFC”、”NFD”、”NFKC” 以及 “NFKD”，form的默认值为 “NFC”。如果form 传入了非法的参数值，则会抛出 RangeError 错误。 123456var str = "\u4f60\u597d";console.log(str.normalize()); // 你好console.log(str.normalize("NFC")); // 你好console.log(str.normalize("NFD")); // 你好console.log(str.normalize("NFKC")); // 你好console.log(str.normalize("NFKD")); // 你好 repeat(ES6) 定义：repeat() 方法基于ECMAScript 2015（ES6）规范，它返回重复原字符串多次的新字符串。 语法：str.repeat(count) count 参数只能取大于等于0 的数字。若该数字不为整数，将自动转换为整数形式，若为负数或者其他值将报错。 12345var str = "A still tongue makes a wise head.";console.log(str.repeat(0)); // ""console.log(str.repeat(1)); // A still tongue makes a wise head.console.log(str.repeat(1.5)); // A still tongue makes a wise head.console.log(str.repeat(-1)); // RangeError:Invalid count value startsWith(ES6) 定义：startsWith() 方法基于ECMAScript 2015（ES6）规范，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false 语法：str.startsWith(subString [, position]) 与html相关的方法anchor &amp;&amp; link anchor 定义：anchor() 方法创建一个锚标签。 语法：str.anchor(name) 参数：name 指定被创建的a标签的name属性，使用该方法创建的锚点，将会成为 document.anchors 数组的元素。 123var str = "this is a anchor tag";document.body.innerHTML = document.body.innerHTML + str.anchor("anchor1"); // body末尾将会追加这些内容 &lt;a name="anchor1"&gt;this is a anchor tag&lt;/a&gt; link 定义：link() 方法同样创建一个a标签。 语法：str.link(url) 参数：url 指定被创建的a标签的href属性， 如果url中包含特殊字符，将自动进行编码。 例如 “ 会被转义为 &amp;\quot。 使用该方法创建的a标签，将会成为 document.links 数组中的元素。 123var str = "百度";document.write(str.link("https://www.baidu.com")); // &lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; 小结: 没错，这篇文章也是抄的，但是作者真的写得好啊！ 我想把他记录到我的博客里面，这样我想看的时候好找些。 加油！！！ 部分字符串方法之间存在很大的相似性，要注意区分他们的功能和使用场景。如： substr 和 substring，都是两个参数，作用基本相同，两者第一个参数含义相同，但用法不同，前者可为负数，后者值为负数或者非整数时将隐式转换为0。前者第二个参数表示截取字符串的长度，后者第二个参数表示截取字符串的下标；同时substring第一个参数大于第二个参数时，执行结果同位置调换后的结果。 search方法与indexOf方法作用基本一致，都是查询到了就返回子串第一次出现的下标，否则返回-1，唯一的区别就在于search默认会将子串转化为正则表达式形式，而indexOf不做此处理，也不能处理正则。 另外，还记得吗？concat方法由于效率问题，不推荐使用。 常用的方法就charAt、indexOf、lastIndexOf、match、replace、search、slice、split、substr、substring、toLowerCase、toUpperCase、trim、valueof 等这些。 参考JavaScript字符串所有API全解密]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之数组]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Array构造器12345678// 使用Array构造器var a = Array(8); // [undefined × 8]// 使用对象字面量var b = [];b.length = 8; // [undefined × 8]Array.of(8.0); // [8]Array(8); // [empty × 8] Array.of和Array的区别：很明显，当Array传入一个数字参数时，这个参数会作为数组的长度 Array.isArray我们至少有如下5种方式去判断一个值是否数组：1234567891011var a = [];// 1.基于instanceofa instanceof Array;// 2.基于constructora.constructor === Array;// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a);// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype;// 5.基于Object.prototype.toStringObject.prototype.toString.apply(a) === '[object Array]'; 还有Array.isArray():12Array.isArray([]); // trueArray.isArray(&#123;0: 'a', length: 1&#125;); // false 改变自身值的方法(9个)基于ES6，改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill。 pop pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。如果是栈的话，这个过程就是栈顶弹出。 push push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。如果是栈的话，这个过程就是栈顶压入语法：arr.push(element1, …, elementN) shift shift()方法删除数组的第一个元素，并返回这个元素。如果是栈的话，这个过程就是栈底弹出。语法：arr.shift() unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。语法：arr.unshift(element1, …, elementN) splice() 添加/删除数组元素 定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 语法： array.splice(index,howmany,item1,…..,itemX) reverse reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。语法：arr.reverse() ES6: copyWithin() 指定位置的成员复制到其他位置 定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。语法:1array.copyWithin(target, start = 0, end = this.length) 参数: 三个参数都是数值，如果不是，会自动转为数值. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。 eg:1234567// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]var a=['OB1','Koro1','OB2','Koro2','OB3','Koro3','OB4','Koro4','OB5','Koro5']// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换a.copyWithin(2,3,5)// ["OB1","Koro1","Koro2","OB3","OB3","Koro3","OB4","Koro4","OB5","Koro5"] ES6: fill() 填充数组 定义: 使用给定值，填充一个数组。语法： Array.fill( val, startp, endp )参数: 第一个元素(必须): 要填充数组的值 第二个元素(可选): 填充的开始位置,默认值为0 第三个元素(可选)：填充的结束位置，默认是为this.lengtheg:1234['a', 'b', 'c'].fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] sort sort()方法对数组元素进行排序，并返回这个数组。sort方法比较复杂，这里我将多花些篇幅来讲这块。语法：arr.sort([comparefn]) comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：12345678var array = ["apple","Boy","Cat","dog"];var array2 = array.sort();console.log(array); // ["Boy", "Cat", "apple", "dog"]console.log(array2 == array); // truearray = [10, 1, 3, 20];var array3 = array.sort();console.log(array3); // [1, 10, 20, 3] 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素： 若 comparefn(a, b) &lt; 0，那么a 将排到 b 前面； 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变； 若 comparefn(a, b) &gt; 0，那么a , b 将调换位置； 不改变原数组的方法(8个):ES5： slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、 ES7： includes slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。语法：array.slice(begin, end);参数： begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。 end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。语法： array.join(str) toLocaleString() 数组转字符串 定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。语法： array.toLocaleString()eg:12let a=[&#123;name:'OBKoro1'&#125;,23,'abcd',new Date()];let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 如上述栗子：调用数组的toLocaleString方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。 toString() 数组转字符串 不推荐 该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。 cancat 定义： 方法用于合并两个或多个数组，返回一个新数组。语法： var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) ES6扩展运算符…合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1语法: array.indexOf(searchElement,fromIndex) 参数:searchElement(必须):被查找的元素fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索:数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。indexOf()不能识别NaNeg:1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）与上面的indexOf相同 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值语法： array.includes(searchElement,fromIndex=0)参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 eg:12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组 遍历方法(12个):js中遍历数组并不会改变原始数组的方法总共有12个: ES5： forEach、every 、some、 filter、map、reduce、reduceRight、 ES6： find、findIndex、keys、values、entries forEach 定义: 按升序为数组中含有效值的每一项执行一次回调函数。 语法： array.forEach(function(currentValue, index, arr), thisValue) 参数: function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 关于forEach()你要知道： 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值。 需要注意： 1. 对于空数组是不会执行回调函数的 2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。 4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。 eg:12345678910111213let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)let obj = &#123; name: 'OBKoro1' &#125;;let result = a.forEach(function (value, index, array) &#123; a[3] = '改变元素'; a.push('添加到尾端，不会被遍历') console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log('不会执行，因为return 会执行下一次循环回调')&#125;, obj);console.log(result); // 即使return了一个值,也还是返回undefined// 回调函数也接受接头函数写法 every 检测数组所有元素是否都符合判断条件 定义: 方法用于检测数组所有元素是否都符合函数定义的条件 语法： array.every(function(currentValue, index, arr), thisValue) 方法返回值规则: 如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true。 some 数组中的是否有满足判断条件的元素 定义：数组中的是否有满足判断条件的元素 语法： array.some(function(currentValue, index, arr), thisValue) 方法返回值规则: 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false。 filter 过滤原始数组，返回新数组 定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。 语法： let new_array = arr.filter(function(currentValue, index, arr), thisArg)eg:12345let a = [32, 33, 16, 40];let result = a.filter(function (value, index, array) &#123; return value &gt;= 18; // 返回a数组中所有大于18的元素&#125;);console.log(result,a);// [32,33,40] [32,33,16,40] map 对数组中的每个元素进行处理，返回新的数组 定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法： let new_array = arr.map(function(currentValue, index, arr), thisArg) reduce 为数组提供累加器，合并为一个值 定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。 语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 参数： function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. total(必须)，初始值, 或者上一次调用回调返回的值 2. currentValue(必须),数组当前元素的值 3. index(可选), 当前元素的索引值 4. arr(可选),数组对象本身 回调第一次执行时: 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值； 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。 reduceRight 从右至左累加 这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。 ES6：find()&amp; findIndex() 根据条件找到数组成员 find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。 findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 语法： let new_array = arr.find(function(currentValue, index, arr), thisArg) let new_array = arr.findIndex(function(currentValue, index, arr), thisArg) ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值 定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。 语法： array.keys() array.values() array.entries() 添加两个没有的api Array.prototype.flat() Array.prototype.flatMap() Array.prototype.flat() 定义：flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 语法：var newArray = arr.flat(depth) 参数：depth （可选）指定要提取嵌套数组的结构深度，默认值为 1。 返回一个新数组 扁平化嵌套数组: eg:123456789101112131415var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]//使用 Infinity 作为深度，展开任意深度的嵌套数组arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6] 扁平化与空项 flat() 方法会移除数组中的空项: 123var arr4 = [1, 2, , 4, 5];arr4.flat();// [1, 2, 4, 5] Array.prototype.flatMap() 定义：flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 语法：var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素 return }[, thisArg]) 参数： currentValue –（必选）– 当前正在数组中处理的元素 index –（可选）– 数组中正在处理的当前元素的索引 array –（可选）– 当前数组 eg:1234567let arr = ["今天天气不错", "", "早上好"]arr.map(s =&gt; s.split(""))// [["今", "天", "天", "气", "不", "错"],[""],["早", "上", "好"]]arr.flatMap(s =&gt; s.split(''));// ["今", "天", "天", "气", "不", "错", "", "早", "上", "好"] 结语很早就看完并按照例子做一遍了，一直想写篇文章记录下，今天终于写了， 希望自己继续加油！！！ 参考资料 【干货】js 数组详细操作方法及解析合集 注：这篇文章就是参考的上面这篇文章，哈哈哈，真的觉得作者写得好，通过这篇文章也让我总结了js数组相关的知识 作者的github 作者的博客 本篇文章 MDN–Array–Api]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electorn初探]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F16%2Felectorn%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>桌面应用</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Next主题]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F14%2F%E9%85%8D%E7%BD%AENext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录一下配置过程配置背景图片修改文件：themes\next\source\css_custom\custom.styl，增加下面的代码： body{ background:url(http://curtaintan.club/hexo-bg.jpg); background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%; } // 修改主体透明度 .main-inner { background: #fff; opacity: 0.8; } // 修改菜单栏透明度 .header-inner { opacity: 0.8; } 修改背景动画粒子颜色修改文件：next\layout_scripts\vendors.swig，搜索找到：canvas_nest修改为： {% if theme.canvas_nest %} {% endif %} 修改后为： 设置加载本地图片 打开_config.yml文件，修改下述内容 post_asset_folder: true 安装插件： npm install hexo-asset-image –save 对插件进行修改： 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123;var config = hexo.config;if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125;&#125;&#125;); 注意： 如果你的主目录的_config.yml内的URL配置如下配置： 请修改为下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, &quot;/&quot; + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+ link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 其他详情请参考：最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 谢谢，文章写得不好---请见谅]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter配置web]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F13%2Fflutter%E9%85%8D%E7%BD%AEweb%2F</url>
    <content type="text"><![CDATA[flutter配置web今天配置了web端，记一下配置过程，配置还是蛮复杂的 第一步：下载web包 下载整个项目到本地， 运行：flutter pub global activate webdev 此时会提示：将.pub-cache/bin加入电脑的环境变量，他会把完整的路径给你，如果没有，你可以去自己flutterSDK的安装目录下找到，如下图： 找到一篇文章，看这篇文章吧—-点击跳转 写后感：写文章，还是要脑子的，但是我没有----]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fhexo-blog%2F2019%2F04%2F26%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一篇文章记录下，嘻嘻三级标题 列表一 列表二 a 子列表a b 子列表2 c 子列表3 列表三 链接测试-优秀博客 下面是关于字体斜体字字体加粗代码块引用&lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 这里是引用 hexo clean &amp;&amp; hexo ghexo s]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
