<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js遍历方法总结]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2Fjs%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言学习一门语言，遍历是少不了的！！ gogogo,开始吧 标准操作 for循环 就是正常的for循环， 123456789var arr = ['element1', 'element2', 'element3'];for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(arr[i]);&#125;// element1// element2// element3 数组自带方法forEach 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值 123456789var arr = ['element1', 'element2', 'element3'];arr.forEach(function(value, index, arr) &#123; console.log(value);&#125;);// element1// element2// element3 说明：比较遗憾的是以上的代码未能按照我们的预期运行（break、continue等语句跨越了函数边界），所以这个看似完美的办法实际上只能一条道走到黑，像吃了炫迈一样根本停不下来。当数组很大，没办法通过提前终止遍历来节省资源。 for in循环 很强大！！1234567var arr = ['element1', 'element2', 'element3'];for (var i in arr) &#123; console.log(arr[i]);&#125;// element1// element2// element3 for in语句是一种精准的迭代语句，可以枚举对象的所有可枚举属性(可以使用Object.getOwnPropertyDescriptor(targetObj, attrName)方法来查看对象的某个属性是否可枚举)。It means that，可以用它来遍历对象： 12345678910111213var obj = &#123; a: 1, b: 1, c: 1&#125;;for (let attr in obj) &#123; console.log(attr, obj[attr]);&#125;// a 1// b 1// c 1 除了遍历对象、数组之外，for in循环还可兼职遍历字符串：1234567var str = 'I am a handsome boy!';for (var i in str) &#123; console.log(str[i]);&#125;// 太帅(chang)了，结果就不打印了 当然，也支持break、continue的操作，例子我就不写了。 缺点：123456789101112131415161718192021222324var father = &#123; fatherAttr: 1&#125;;// 以father为原型创建对象实例instancevar instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;for (var attr in instance) &#123; console.log(attr, instance[attr]);&#125;// a 1// b 1// c 1// fatherAttr 1// 获取instance实例的自有属性名console.log(Object.getOwnPropertyNames(instance));// ["a", "b", "c"] 上面这个例子中，首先以father对象为原型创建了一个对象实例instance，然后为这个实例instance添加了a、b、c三个属性，接着使用for in循环遍历这个对象。通过查看instance的自有属性可以发现，fatherAttr并不是instance的属性，而是其原型father的属性，for in循环会将对象的原型属性也一并列举出来。故使用此方法去遍历对象属性的时候，需要加多一层判断： 12345for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; // 是对象的自有属性，可以尽情的玩耍了 &#125;&#125; for of循环 通过for in循环可以解决传统for循环需要维护边界的问题，但也引入了一些新问题，跟搬砖工作者的日常操作“解决3个bug，引入8个新bug”场景极度相似。 所以换个es6定义的for of循环操作试试：12345678910111213let str = 'a 𠮷 c';for (let char of str) &#123; if (char === ' ') &#123; continue; &#125; else &#123; console.log(char); &#125;&#125;// a// 𠮷// c 从上面的例子来看，效果简直是perfect：索引去掉了，边界去掉了，想继续就继续，想退出就退出，还能顺便解决一下字符串的编码问题。 缺点： 运行环境为ES6及以上版本，所以兼容性没有for in循环以及传统的操作好，如果需要考虑兼容上世纪的浏览器，就不能使用这个东西 只能用于遍历可迭代对象，即存在生成器方法（用于产生迭代器）的对象，如果用于遍历不可迭代对象，分分钟报错没商量。可以通过检测对象的Symbol.iterator方法（相关内容将放在下一篇）是否为函数来判断对象是否可迭代。 实际上，大多数JavaScript的内置对象都支持迭代，例如：Array、Set、Map、String等，当使用for of循环遍历上述对象时，就会使用其默认的生成器生成的迭代器： 123456789101112131415161718192021let map = new Map([['a', 1], ['b', 1], ['c', 1], ['d', 1]]);// 正经操作for (let item of map) &#123; console.log(item);&#125;// ["a", 1]// ["b", 1]// ["c", 1]// ["d", 1]// 使用解构，方便读取值for (let [key, value] of map) &#123; console.log(key, value);&#125;// a 1// b 1// c 1// d 1 上面的例子使用了for of遍历了Map类型实例map，迭代对象为Map类型的默认生成器生成的迭代器。当然，像Array、Set、Map类型还提供了一些特殊的生成器，可以让搬砖工作者更方便的去处理其想关注的内容： entries() 返回一个迭代器，其返回值为键值对数组（Map集合的默认迭代器；对于Set集合，返回值数组的元素相同，即value） keys() 返回一个迭代器，其返回值为集合的键名（对于Set集合，此迭代器跟values迭代器返回值相同;对于数组，此迭代器返回值为索引） values() 返回一个迭代器，其返回值为集合的值（Array、Set集合的默认迭代器） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let arr = ['a', 'b', 'c', 'd']let set = new Set(arr);for (let item of set.entries()) &#123; console.log(item);&#125;for (let item of arr.entries()) &#123; console.log(item);&#125;// ["a", "a"]// ["b", "b"]// ["c", "c"]// ["d", "d"]// [0, "a"]// [1, "b"]// [2, "c"]// [3, "d"]for (let item of set.keys()) &#123; console.log(item);&#125;for (let item of arr.keys()) &#123; console.log(item);&#125;// a// b// c// d// 0// 1// 2// 3for (let item of set.values()) &#123; console.log(item);&#125;for (let item of arr.values()) &#123; console.log(item);&#125;// a// b// c// d// a// b// c// d 除了JavaScript的内置对象，一些DOM标准的类型如NodeList也可以使用for of循环进行遍历： 12345let containers = document.querySelectorAll('.container');for (let node of containers) &#123; // 搞事情专用注释&#125; 很遗憾的是，for of循环居然不支持自定义对象的遍历（心中一万匹***奔腾而过……），所以如果不想使用for in循环遍历对象，只能转个弯了。 遍历对象的转弯操作 Object.keys()获取键名数组 使用Object.keys()可以获取到对象实例的所有可枚举属性，其返回值为一个数组，数组元素为对象的键名： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;// 以father为原型创建对象实例instancelet instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.keys(instance)) &#123; console.log(key);&#125;// a// b// c 不了解Object.defineProperty，可以参考: 深入浅出Object.defineProperty(),文章写得同属易懂，每个api都有案例。 Object.defineProperty( obj, prop, desc ) desc主要有四个 属性（value,writable, enumerable, configurable） Object.getOwnPropertyNames()获取键名数组 此方法跟keys方法表现一样，所不同的是，其返回的数组包含了对象的不可枚举属性： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.getOwnPropertyNames(instance)) &#123; console.log(key);&#125;// a// b// c// d Object.entries()获取键值对数组 这个方法返回什么东西就无需多言了吧，看例子： 123456789101112131415161718192021222324let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;Object.defineProperty(instance, 'd', &#123; writable: true, value: 1, enumerable: false, configurable: true&#125;);for (let key of Object.entries(instance)) &#123; console.log(key);&#125;// ["a", 1]// ["b", 1]// ["c", 1] Object.values()获取对象的属性值数组 获取对象的值。 Object.getOwnPropertySymbols()获取Symbol属性名上面提到的几个方法都无法获取到对象实例的Symbol类型的属性名，如果需要遍历这个玩意，需要使用Object.getOwnPropertySymbols()方法： 12345678910111213141516171819202122232425let father = &#123; fatherAttr: 1&#125;;let instance = Object.create(father);instance.a = 1;instance.b = 1;instance.c = 1;instance[Symbol('I am a handsome boy!')] = 1;for (let key of Object.keys(instance)) &#123; console.log(key);&#125;// a// b// cfor (let key of Object.getOwnPropertySymbols(instance)) &#123; console.log(key);&#125;// Symbol(I am a handsome boy!) 结语ok！这篇文章也是抄的: avaScript骚操作之遍历、枚举与迭代（上篇） 觉得总结的蛮好的。 当然，还有部分遍历是数组特有的方法。 比如：map，reduce， filter, every, some等，都可以遍历数组 好了，文章写完了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之字符串]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[String构造器方法 raw(ES6)定义：raw() 方法基于ECMAScript 2015（ES6）规范，它是一个模板字符串的标签函数，防止转义 如下是python的字符串前缀r： 1234# 防止特殊字符串被转义print r'a\nb\tc' # 打印出来依然是 "a\nb\tc"# python中常用于正则表达式regExp = r'(?&lt;=123)[a-z]+' 如下是String.raw作为前缀的用法： 1234567// 防止特殊字符串被转义String.raw`a\nb\tc`; // 输出为 "a\nb\tc"// 支持内插表达式let name = "louis";String.raw`Hello \n $&#123;name&#125;`; // "Hello \n louis"// 内插表达式还可以运算String.raw`1+2=$&#123;1+2&#125;,2*3=$&#123;2*3&#125;`; // "1+2=3,2*3=6" String.raw作为函数来调用的场景不太多，如下是用法： 1234// 对象的raw属性值为字符串时，从第二个参数起，它们分别被插入到下标为0，1，2，...n的元素后面String.raw(&#123;raw: 'abcd'&#125;, 1, 2, 3); // "a1b2c3d"// 对象的raw属性值为数组时，从第二个参数起，它们分别被插入到数组下标为0，1，2，...n的元素后面String.raw(&#123;raw: ['a', 'b', 'c', 'd']&#125;, 1, 2, 3); // "a1b2c3d" String.prototype和其他所有对象一样，字符串实例的所有方法均来自String.prototype。以下是它的属性特性： 值 属性 writable false enumerable false configurable false 可见，字符串属性不可编辑，任何试图改变它属性的行为都将抛出错误 与html无关的字符串方法常用的方法有： charAt、charCodeAt、concat、indexOf、lastIndexOf、localeCompare match、replace、search、slice、split、substr substring、toLocaleLowerCase、toLocaleUpperCase、toLowerCase、toString、toUpperCase trim、valueof 等ES5支持的， 以及 codePointAt、contains、endsWith、normalize、repeat、startsWith 等ES6支持的， 还包括 quote、toSource、trimLeft、trimRight 等非标准的。 charAt 定义：charAt() 方法返回字符串中指定位置的字符。语法：str.charAt(index) charCodeAt 定义：charCodeAt() 返回指定索引处字符的 Unicode 数值。 语法：str.charCodeAt(index) index 为一个从0至length-1的整数。如果不是一个数值，则默认为 0，如果小于0或者大于字符串长度，则返回 NaN。 Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样. concat 定义：concat() 方法将一个或多个字符串拼接在一起，组成新的字符串并返回。 语法：str.concat(string2, string3, …) 但是 concat 的性能表现不佳，强烈推荐使用赋值操作符（+或+=）代替 concat。”+” 操作符大概快了 concat 几十倍。 indexOf &amp;&amp; lastIndexOf 定义：indexOf() 方法用于查找子字符串在字符串中首次出现的位置，没有则返回 -1。 语法：str.indexOf(searchValue [, fromIndex=0])，str.lastIndexOf(searchValue [, fromIndex=0]) match 定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 描述： 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 相关 RegExp 方法 若需测试字符串是否匹配正则，请参考 RegExp.test(str)。 若只需第一个匹配结果，请参考 RegExp.exec(str)。 123456var str = "World Internet Conference";console.log(str.match(/[a-d]/i)); // ["d", index: 4, input: "World Internet Conference"]console.log(str.match(/[a-d]/gi)); // ["d", "C", "c"]// RegExp 方法如下console.log(/[a-d]/gi.test(str)); // trueconsole.log(/[a-d]/gi.exec(str)); // ["d", index: 4, input: "World Internet Conference"] search 定义：search() 方法用于测试字符串对象是否包含某个正则匹配，相当于正则表达式的 test 方法，且该方法比 match() 方法更快。如果匹配成功，search() 返回正则表达式在字符串中首次匹配项的索引，否则返回-1。 语法：str.search(regexp) 12var str = "abcdefg";console.log(str.search(/[d-g]/)); // 3, 匹配到子串"defg",而d在原字符串中的索引为3 search() 方法不支持全局匹配（正则中包含g参数），如下：1console.log(str.search(/[d-g]/g)); // 3, 与无g参数时,返回相同 slice 定义：slice() 方法提取字符串的一部分，并返回新的字符串。该方法有些类似 Array.prototype.slice 方法。 语法：str.slice(start, end) split 定义：split() 方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的 其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素 如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组 limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 eg:123456789var str = "today is a sunny day";console.log(str.split()); // ["today is a sunny day"]console.log(str.split("")); // ["t", "o", "d", "a", "y", " ", "i", "s", " ", "a", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y"]console.log(str.split(" ")); // ["today", "is", "a", "sunny", "day"]console.log(str.split(/\s*is\s*/)); // ["today", "a sunny day"]console.log(str.split(/(\s*is\s*)/)); // ["today", " is ", "a sunny day"] substr 定义：substr() 方法返回字符串指定位置开始的指定数量的字符。 语法：str.substr(start[, length]) 参数： start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。 length 表示截取的字符长度。 eg:123var str = "Yesterday is history. Tomorrow is mystery. But today is a gift.";console.log(str.substr(47)); // today is a gift.console.log(str.substr(-16)); // today is a gift. substring 定义：substring() 方法返回字符串两个索引之间的子串。 语法：str.substring(indexA[, indexB]) indexA、indexB 表示字符串索引，其中 indexB 可选，如果省略，则表示返回从 indexA 到字符串末尾的子串。 描述: substring 要截取的是从 indexA 到 indexB（不包含）之间的字符，符合以下规律： 若 indexA == indexB，则返回一个空字符串； 若 省略 indexB，则提取字符一直到字符串末尾； 若 任一参数小于 0 或 NaN，则被当作 0； 若 任一参数大于 length，则被当作 length。 而 如果 indexA &gt; indexB，则 substring 的执行效果就像是两个参数调换一般。比如：str.substring(0, 1) == str.substring(1, 0)eg:123456var str = "Get outside every day. Miracles are waiting everywhere.";console.log(str.substring(1,1)); // ""console.log(str.substring(0)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(-1)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(0,100)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(22,NaN)); // Get outside every day. toLocaleLowerCase &amp; toLocaleUpperCase &amp; toLowerCase &amp; toUpperCase 定义：转换成大小写 语法：str.toLocaleLowerCase(), str.toLocaleUpperCase() toString &amp; valueOf 定义：这两个方法都是返回字符串本身。 语法：str.toString(), str.valueOf() trim 定义：trim() 方法清除字符串首尾的空白并返回。 语法：str.trim() includes(ES6) 定义：includes() 方法基于ECMAScript 2015（ES6）规范，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。 语法：str.includes(subString [, position]) eg:123var str = "Practice makes perfect.";console.log(str.includes("perfect")); // trueconsole.log(str.includes("perfect",100)); // false endsWith(ES6) 定义：endsWith() 方法基于ECMAScript 2015（ES6）规范，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。 语法：str.endsWith(substring [, position]) 与contains 方法不同，position 参数的默认值为字符串长度。123var str = "Learn and live.";console.log(str.endsWith("live.")); // trueconsole.log(str.endsWith("Learn",5)); // true normalize(ES6) 定义：normalize() 方法基于ECMAScript 2015（ES6）规范，它会按照指定的 Unicode 正规形式将原字符串正规化。 语法：str.normalize([form]) form 参数可省略，目前有四种 Unicode 正规形式，即 “NFC”、”NFD”、”NFKC” 以及 “NFKD”，form的默认值为 “NFC”。如果form 传入了非法的参数值，则会抛出 RangeError 错误。 123456var str = "\u4f60\u597d";console.log(str.normalize()); // 你好console.log(str.normalize("NFC")); // 你好console.log(str.normalize("NFD")); // 你好console.log(str.normalize("NFKC")); // 你好console.log(str.normalize("NFKD")); // 你好 repeat(ES6) 定义：repeat() 方法基于ECMAScript 2015（ES6）规范，它返回重复原字符串多次的新字符串。 语法：str.repeat(count) count 参数只能取大于等于0 的数字。若该数字不为整数，将自动转换为整数形式，若为负数或者其他值将报错。 12345var str = "A still tongue makes a wise head.";console.log(str.repeat(0)); // ""console.log(str.repeat(1)); // A still tongue makes a wise head.console.log(str.repeat(1.5)); // A still tongue makes a wise head.console.log(str.repeat(-1)); // RangeError:Invalid count value startsWith(ES6) 定义：startsWith() 方法基于ECMAScript 2015（ES6）规范，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false 语法：str.startsWith(subString [, position]) 与html相关的方法anchor &amp;&amp; link anchor 定义：anchor() 方法创建一个锚标签。 语法：str.anchor(name) 参数：name 指定被创建的a标签的name属性，使用该方法创建的锚点，将会成为 document.anchors 数组的元素。 123var str = "this is a anchor tag";document.body.innerHTML = document.body.innerHTML + str.anchor("anchor1"); // body末尾将会追加这些内容 &lt;a name="anchor1"&gt;this is a anchor tag&lt;/a&gt; link 定义：link() 方法同样创建一个a标签。 语法：str.link(url) 参数：url 指定被创建的a标签的href属性， 如果url中包含特殊字符，将自动进行编码。 例如 “ 会被转义为 &amp;\quot。 使用该方法创建的a标签，将会成为 document.links 数组中的元素。 123var str = "百度";document.write(str.link("https://www.baidu.com")); // &lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; 小结: 没错，这篇文章也是抄的，但是作者真的写得好啊！ 我想把他记录到我的博客里面，这样我想看的时候好找些。 加油！！！ 部分字符串方法之间存在很大的相似性，要注意区分他们的功能和使用场景。如： substr 和 substring，都是两个参数，作用基本相同，两者第一个参数含义相同，但用法不同，前者可为负数，后者值为负数或者非整数时将隐式转换为0。前者第二个参数表示截取字符串的长度，后者第二个参数表示截取字符串的下标；同时substring第一个参数大于第二个参数时，执行结果同位置调换后的结果。 search方法与indexOf方法作用基本一致，都是查询到了就返回子串第一次出现的下标，否则返回-1，唯一的区别就在于search默认会将子串转化为正则表达式形式，而indexOf不做此处理，也不能处理正则。 另外，还记得吗？concat方法由于效率问题，不推荐使用。 常用的方法就charAt、indexOf、lastIndexOf、match、replace、search、slice、split、substr、substring、toLowerCase、toUpperCase、trim、valueof 等这些。 参考JavaScript字符串所有API全解密]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面学习js之数组]]></title>
    <url>%2Fhexo-blog%2F2019%2F07%2F29%2F%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0js%E4%B9%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Array构造器12345678// 使用Array构造器var a = Array(8); // [undefined × 8]// 使用对象字面量var b = [];b.length = 8; // [undefined × 8]Array.of(8.0); // [8]Array(8); // [empty × 8] Array.of和Array的区别：很明显，当Array传入一个数字参数时，这个参数会作为数组的长度 Array.isArray我们至少有如下5种方式去判断一个值是否数组：1234567891011var a = [];// 1.基于instanceofa instanceof Array;// 2.基于constructora.constructor === Array;// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a);// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype;// 5.基于Object.prototype.toStringObject.prototype.toString.apply(a) === '[object Array]'; 还有Array.isArray():12Array.isArray([]); // trueArray.isArray(&#123;0: 'a', length: 1&#125;); // false 改变自身值的方法(9个)基于ES6，改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill。 pop pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。如果是栈的话，这个过程就是栈顶弹出。 push push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。如果是栈的话，这个过程就是栈顶压入语法：arr.push(element1, …, elementN) shift shift()方法删除数组的第一个元素，并返回这个元素。如果是栈的话，这个过程就是栈底弹出。语法：arr.shift() unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。语法：arr.unshift(element1, …, elementN) splice() 添加/删除数组元素 定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 语法： array.splice(index,howmany,item1,…..,itemX) reverse reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。语法：arr.reverse() ES6: copyWithin() 指定位置的成员复制到其他位置 定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。语法:1array.copyWithin(target, start = 0, end = this.length) 参数: 三个参数都是数值，如果不是，会自动转为数值. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。 eg:1234567// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]var a=['OB1','Koro1','OB2','Koro2','OB3','Koro3','OB4','Koro4','OB5','Koro5']// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换a.copyWithin(2,3,5)// ["OB1","Koro1","Koro2","OB3","OB3","Koro3","OB4","Koro4","OB5","Koro5"] ES6: fill() 填充数组 定义: 使用给定值，填充一个数组。语法： Array.fill( val, startp, endp )参数: 第一个元素(必须): 要填充数组的值 第二个元素(可选): 填充的开始位置,默认值为0 第三个元素(可选)：填充的结束位置，默认是为this.lengtheg:1234['a', 'b', 'c'].fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] sort sort()方法对数组元素进行排序，并返回这个数组。sort方法比较复杂，这里我将多花些篇幅来讲这块。语法：arr.sort([comparefn]) comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：12345678var array = ["apple","Boy","Cat","dog"];var array2 = array.sort();console.log(array); // ["Boy", "Cat", "apple", "dog"]console.log(array2 == array); // truearray = [10, 1, 3, 20];var array3 = array.sort();console.log(array3); // [1, 10, 20, 3] 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素： 若 comparefn(a, b) &lt; 0，那么a 将排到 b 前面； 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变； 若 comparefn(a, b) &gt; 0，那么a , b 将调换位置； 不改变原数组的方法(8个):ES5： slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、 ES7： includes slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。语法：array.slice(begin, end);参数： begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。 end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。语法： array.join(str) toLocaleString() 数组转字符串 定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。语法： array.toLocaleString()eg:12let a=[&#123;name:'OBKoro1'&#125;,23,'abcd',new Date()];let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 如上述栗子：调用数组的toLocaleString方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。 toString() 数组转字符串 不推荐 该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。 cancat 定义： 方法用于合并两个或多个数组，返回一个新数组。语法： var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) ES6扩展运算符…合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1语法: array.indexOf(searchElement,fromIndex) 参数:searchElement(必须):被查找的元素fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索:数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。indexOf()不能识别NaNeg:1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）与上面的indexOf相同 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值语法： array.includes(searchElement,fromIndex=0)参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 eg:12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组 遍历方法(12个):js中遍历数组并不会改变原始数组的方法总共有12个: ES5： forEach、every 、some、 filter、map、reduce、reduceRight、 ES6： find、findIndex、keys、values、entries forEach 定义: 按升序为数组中含有效值的每一项执行一次回调函数。 语法： array.forEach(function(currentValue, index, arr), thisValue) 参数: function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 关于forEach()你要知道： 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值。 需要注意： 1. 对于空数组是不会执行回调函数的 2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。 4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。 eg:12345678910111213let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)let obj = &#123; name: 'OBKoro1' &#125;;let result = a.forEach(function (value, index, array) &#123; a[3] = '改变元素'; a.push('添加到尾端，不会被遍历') console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log('不会执行，因为return 会执行下一次循环回调')&#125;, obj);console.log(result); // 即使return了一个值,也还是返回undefined// 回调函数也接受接头函数写法 every 检测数组所有元素是否都符合判断条件 定义: 方法用于检测数组所有元素是否都符合函数定义的条件 语法： array.every(function(currentValue, index, arr), thisValue) 方法返回值规则: 如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true。 some 数组中的是否有满足判断条件的元素 定义：数组中的是否有满足判断条件的元素 语法： array.some(function(currentValue, index, arr), thisValue) 方法返回值规则: 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false。 filter 过滤原始数组，返回新数组 定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。 语法： let new_array = arr.filter(function(currentValue, index, arr), thisArg)eg:12345let a = [32, 33, 16, 40];let result = a.filter(function (value, index, array) &#123; return value &gt;= 18; // 返回a数组中所有大于18的元素&#125;);console.log(result,a);// [32,33,40] [32,33,16,40] map 对数组中的每个元素进行处理，返回新的数组 定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法： let new_array = arr.map(function(currentValue, index, arr), thisArg) reduce 为数组提供累加器，合并为一个值 定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。 语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 参数： function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. total(必须)，初始值, 或者上一次调用回调返回的值 2. currentValue(必须),数组当前元素的值 3. index(可选), 当前元素的索引值 4. arr(可选),数组对象本身 回调第一次执行时: 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值； 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。 reduceRight 从右至左累加 这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。 ES6：find()&amp; findIndex() 根据条件找到数组成员 find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。 findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 语法： let new_array = arr.find(function(currentValue, index, arr), thisArg) let new_array = arr.findIndex(function(currentValue, index, arr), thisArg) ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值 定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。 语法： array.keys() array.values() array.entries() 结语很早就看完并按照例子做一遍了，一直想写篇文章记录下，今天终于写了， 希望自己继续加油！！！ 参考资料 【干货】js 数组详细操作方法及解析合集 注：这篇文章就是参考的上面这篇文章，哈哈哈，真的觉得作者写得好，通过这篇文章也让我总结了js数组相关的知识 作者的github 作者的博客 本篇文章]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electorn初探]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F16%2Felectorn%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>桌面应用</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Next主题]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F14%2F%E9%85%8D%E7%BD%AENext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录一下配置过程配置背景图片修改文件：themes\next\source\css_custom\custom.styl，增加下面的代码： body{ background:url(http://curtaintan.club/hexo-bg.jpg); background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%; } // 修改主体透明度 .main-inner { background: #fff; opacity: 0.8; } // 修改菜单栏透明度 .header-inner { opacity: 0.8; } 修改背景动画粒子颜色修改文件：next\layout_scripts\vendors.swig，搜索找到：canvas_nest修改为： {% if theme.canvas_nest %} {% endif %} 修改后为： 设置加载本地图片 打开_config.yml文件，修改下述内容 post_asset_folder: true 安装插件： npm install hexo-asset-image –save 对插件进行修改： 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123;var config = hexo.config;if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125;&#125;&#125;); 注意： 如果你的主目录的_config.yml内的URL配置如下配置： 请修改为下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, &quot;/&quot; + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+ link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 其他详情请参考：最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 谢谢，文章写得不好---请见谅]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter配置web]]></title>
    <url>%2Fhexo-blog%2F2019%2F06%2F13%2Fflutter%E9%85%8D%E7%BD%AEweb%2F</url>
    <content type="text"><![CDATA[flutter配置web今天配置了web端，记一下配置过程，配置还是蛮复杂的 第一步：下载web包 下载整个项目到本地， 运行：flutter pub global activate webdev 此时会提示：将.pub-cache/bin加入电脑的环境变量，他会把完整的路径给你，如果没有，你可以去自己flutterSDK的安装目录下找到，如下图： 找到一篇文章，看这篇文章吧—-点击跳转 写后感：写文章，还是要脑子的，但是我没有----]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fhexo-blog%2F2019%2F04%2F26%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一篇文章记录下，嘻嘻三级标题 列表一 列表二 a 子列表a b 子列表2 c 子列表3 列表三 链接测试-优秀博客 下面是关于字体斜体字字体加粗代码块引用&lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 这里是引用 hexo clean &amp;&amp; hexo ghexo s]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
